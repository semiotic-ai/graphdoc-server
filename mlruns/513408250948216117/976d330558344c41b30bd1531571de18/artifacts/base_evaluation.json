{
  "overall_score": 1025.35,
  "scores": [
    16,
    9,
    1,
    9,
    9,
    9,
    16,
    9,
    9,
    9,
    16,
    4,
    9,
    16,
    9,
    16,
    16,
    16,
    9,
    16,
    16,
    9,
    1,
    16,
    16,
    16,
    4,
    16,
    9,
    9,
    9,
    16,
    9,
    9,
    1,
    9,
    16,
    9,
    9,
    9,
    9,
    9,
    9,
    4,
    9,
    9,
    16,
    9,
    9,
    9,
    9,
    9,
    9,
    9,
    16,
    9,
    16,
    16,
    4,
    9,
    4,
    9,
    9,
    9,
    9,
    16,
    16,
    16,
    1,
    9,
    1
  ],
  "results": [
    [
      "Example({'database_schema': '\"Description for table: UsageMetricsHourlySnapshot\"\\ntype UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hours\"\\n  hours: Int!\\n  \"Description for column: protocol\"\\n  protocol: LendingProtocol!\\n  \"Description for column: hourlyActiveUsers\"\\n  hourlyActiveUsers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: cumulativeUniqueTxSigners\"\\n  cumulativeUniqueTxSigners: Int!\\n  \"Description for column: hourlyTransactionCount\"\\n  hourlyTransactionCount: Int!\\n  \"Description for column: hourlyDepositCount\"\\n  hourlyDepositCount: Int!\\n  \"Description for column: hourlyWithdrawCount\"\\n  hourlyWithdrawCount: Int!\\n  \"Description for column: hourlyBorrowCount\"\\n  hourlyBorrowCount: Int!\\n  \"Description for column: hourlyRepayCount\"\\n  hourlyRepayCount: Int!\\n  \"Description for column: hourlyLiquidateCount\"\\n  hourlyLiquidateCount: Int!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}', 'documented_schema': 'type UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \" { # of hours since Unix epoch time } \"\\n  id: Bytes!\\n  \" Number of hours since Unix epoch time \"\\n  hours: Int!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: LendingProtocol!\\n  \" Number of unique hourly active users \"\\n  hourlyActiveUsers: Int!\\n  \" Number of cumulative unique users. e.g. accounts that spent gas to interact with this protocol \"\\n  cumulativeUniqueUsers: Int!\\n  \" Number of cumulative unique users. e.g. accounts that signed transactions to interact with this market \"\\n  cumulativeUniqueTxSigners: Int!\\n  \" Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface. \"\\n  hourlyTransactionCount: Int!\\n  \" Total number of deposits in an hour \"\\n  hourlyDepositCount: Int!\\n  \" Total number of withdrawals in an hour \"\\n  hourlyWithdrawCount: Int!\\n  \" Total number of borrows/mints in an hour \"\\n  hourlyBorrowCount: Int!\\n  \" Total number of repayments/burns in an hour \"\\n  hourlyRepayCount: Int!\\n  \" Total number of liquidations in an hour \"\\n  hourlyLiquidateCount: Int!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `UsageMetricsHourlySnapshot` with various fields, each representing a specific metric or identifier related to usage metrics on an hourly basis. The task is to ensure that each field is documented with a concise and factual description, focusing on the role and nature of each field within the context of the schema. The descriptions should be clear and directly related to the field's purpose without altering the schema structure.\",\n    documented_schema='\"Description for table: UsageMetricsHourlySnapshot\"\\ntype UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \"Unique identifier for the snapshot, represented as bytes.\"\\n  id: Bytes!\\n  \"The number of hours since a reference point, typically used to track time intervals.\"\\n  hours: Int!\\n  \"The lending protocol associated with the usage metrics.\"\\n  protocol: LendingProtocol!\\n  \"The number of unique users active within the hour.\"\\n  hourlyActiveUsers: Int!\\n  \"The total number of unique users recorded cumulatively up to this snapshot.\"\\n  cumulativeUniqueUsers: Int!\\n  \"The cumulative count of unique transaction signers up to this point.\"\\n  cumulativeUniqueTxSigners: Int!\\n  \"The total number of transactions that occurred within the hour.\"\\n  hourlyTransactionCount: Int!\\n  \"The number of deposit transactions that occurred within the hour.\"\\n  hourlyDepositCount: Int!\\n  \"The number of withdrawal transactions that occurred within the hour.\"\\n  hourlyWithdrawCount: Int!\\n  \"The number of borrow transactions that occurred within the hour.\"\\n  hourlyBorrowCount: Int!\\n  \"The number of repay transactions that occurred within the hour.\"\\n  hourlyRepayCount: Int!\\n  \"The number of liquidation transactions that occurred within the hour.\"\\n  hourlyLiquidateCount: Int!\\n  \"The block number at which the snapshot was taken.\"\\n  blockNumber: BigInt!\\n  \"The timestamp indicating when the snapshot was recorded.\"\\n  timestamp: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: VaultFee\"\\ntype VaultFee @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: feePercentage\"\\n  feePercentage: BigDecimal\\n  \"Description for column: feeType\"\\n  feeType: VaultFeeType!\\n}', 'documented_schema': 'type VaultFee @entity @regularPolling {\\n  \" { Vault fee type }-{ Vault address } \"\\n  id: ID!\\n  \" Fee as a percentage of the trade (swap) amount. Does not always apply \"\\n  feePercentage: BigDecimal\\n  \" Type of fee this vault uses \"\\n  feeType: VaultFeeType!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `VaultFee`, with three fields: `id`, `feePercentage`, and `feeType`. Each field has a specific type and a brief description. The `id` field is of type `ID!`, indicating it is a non-nullable unique identifier. The `feePercentage` field is of type `BigDecimal`, which suggests it stores a decimal value representing the percentage of the fee. The `feeType` field is of type `VaultFeeType!`, indicating it is a non-nullable field that likely represents the category or nature of the fee.',\n    documented_schema='\"Description for table: VaultFee\"\\ntype VaultFee @entity @regularPolling {\\n  \"Unique identifier for the VaultFee entity\"\\n  id: ID!\\n  \"Decimal value representing the percentage of the fee\"\\n  feePercentage: BigDecimal\\n  \"Category or nature of the fee\"\\n  feeType: VaultFeeType!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for enum type: Network\"\\nenum Network {\\n  \"Description for column: ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"Description for column: AURORA\"\\n  AURORA\\n  \"Description for column: AVALANCHE\"\\n  AVALANCHE\\n  \"Description for column: BSC\"\\n  BSC\\n  \"Description for column: CELO\"\\n  CELO\\n  \"Description for column: CRONOS\"\\n  CRONOS\\n  \"Description for column: MAINNET\"\\n  MAINNET\\n  \"Description for column: FANTOM\"\\n  FANTOM\\n  \"Description for column: FUSE\"\\n  FUSE\\n  \"Description for column: HARMONY\"\\n  HARMONY\\n  \"Description for column: JUNO\"\\n  JUNO\\n  \"Description for column: MOONBEAM\"\\n  MOONBEAM\\n  \"Description for column: MOONRIVER\"\\n  MOONRIVER\\n  \"Description for column: NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"Description for column: OPTIMISM\"\\n  OPTIMISM\\n  \"Description for column: MATIC\"\\n  MATIC\\n  \"Description for column: XDAI\"\\n  XDAI\\n}\\n\\n\"Description for enum type: ProtocolType\"\\nenum ProtocolType {\\n  \"Description for column: EXCHANGE\"\\n  EXCHANGE\\n  \"Description for column: LENDING\"\\n  LENDING\\n  \"Description for column: YIELD\"\\n  YIELD\\n  \"Description for column: BRIDGE\"\\n  BRIDGE\\n}\\n\\n\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: symbol\"\\n  symbol: String!\\n  \"Description for column: decimals\"\\n  decimals: Int!\\n  \"Description for column: lastPriceUSD\"\\n  lastPriceUSD: BigDecimal\\n  \"Description for column: lastPriceBlockNumber\"\\n  lastPriceBlockNumber: BigInt\\n  \"Description for column: _poolToken\"\\n  _poolToken: Token\\n}\\n\\n\"Description for enum type: RewardTokenType\"\\nenum RewardTokenType {\\n  \"Description for column: DEPOSIT\"\\n  DEPOSIT\\n  \"Description for column: BORROW\"\\n  BORROW\\n}\\n\\n\"Description for table: RewardToken\"\\ntype RewardToken @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: type\"\\n  type: RewardTokenType!\\n}\\n\\n\"Description for enum type: LiquidityPoolFeeType\"\\nenum LiquidityPoolFeeType {\\n  \"Description for column: FIXED_TRADING_FEE\"\\n  FIXED_TRADING_FEE\\n  \"Description for column: TIERED_TRADING_FEE\"\\n  TIERED_TRADING_FEE\\n  \"Description for column: DYNAMIC_TRADING_FEE\"\\n  DYNAMIC_TRADING_FEE\\n  \"Description for column: FIXED_LP_FEE\"\\n  FIXED_LP_FEE\\n  \"Description for column: DYNAMIC_LP_FEE\"\\n  DYNAMIC_LP_FEE\\n  \"Description for column: FIXED_PROTOCOL_FEE\"\\n  FIXED_PROTOCOL_FEE\\n  \"Description for column: DYNAMIC_PROTOCOL_FEE\"\\n  DYNAMIC_PROTOCOL_FEE\\n  \"Description for column: DEPOSIT_FEE\"\\n  DEPOSIT_FEE\\n  \"Description for column: WITHDRAWAL_FEE\"\\n  WITHDRAWAL_FEE\\n}\\n\\n\"Description for table: LiquidityPoolFee\"\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: feePercentage\"\\n  feePercentage: BigDecimal\\n  \"Description for column: feeType\"\\n  feeType: LiquidityPoolFeeType!\\n}\\n\\n\"Description for column: LiquidityPoolFee\"\\ninterface Protocol {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: type\"\\n  type: ProtocolType!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: dailyUsageMetrics\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: hourlyUsageMetrics\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: financialMetrics\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}\\n\\n\"Description for table: DexAmmProtocol\"\\ntype DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: type\"\\n  type: ProtocolType!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: dailyUsageMetrics\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: hourlyUsageMetrics\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: financialMetrics\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: pools\"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: _poolIDs\"\\n  _poolIDs: [ID!]!\\n  \"Description for column: _defaultTradingFeeRate\"\\n  _defaultTradingFeeRate: BigDecimal!\\n  \"Description for column: _networkFeeRate\"\\n  _networkFeeRate: BigDecimal!\\n  \"Description for column: _withdrawalFeeRate\"\\n  _withdrawalFeeRate: BigDecimal!\\n}\\n\\n\"Description for table: UsageMetricsDailySnapshot\"\\ntype UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: dailyActiveUsers\"\\n  dailyActiveUsers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: dailyTransactionCount\"\\n  dailyTransactionCount: Int!\\n  \"Description for column: dailyDepositCount\"\\n  dailyDepositCount: Int!\\n  \"Description for column: dailyWithdrawCount\"\\n  dailyWithdrawCount: Int!\\n  \"Description for column: dailySwapCount\"\\n  dailySwapCount: Int!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: UsageMetricsHourlySnapshot\"\\ntype UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: hourlyActiveUsers\"\\n  hourlyActiveUsers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: hourlyTransactionCount\"\\n  hourlyTransactionCount: Int!\\n  \"Description for column: hourlyDepositCount\"\\n  hourlyDepositCount: Int!\\n  \"Description for column: hourlyWithdrawCount\"\\n  hourlyWithdrawCount: Int!\\n  \"Description for column: hourlySwapCount\"\\n  hourlySwapCount: Int!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: dailyVolumeUSD\"\\n  dailyVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: dailySupplySideRevenueUSD\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyProtocolSideRevenueUSD\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyTotalRevenueUSD\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: LiquidityPool\"\\ntype LiquidityPool @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: rewardTokens\"\\n  rewardTokens: [RewardToken!]\\n  \"Description for column: fees\"\\n  fees: [LiquidityPoolFee!]!\\n  \"Description for column: isSingleSided\"\\n  isSingleSided: Boolean!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: createdBlockNumber\"\\n  createdBlockNumber: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: inputTokenBalances\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Description for column: inputTokenWeights\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Description for column: outputTokenSupply\"\\n  outputTokenSupply: BigInt\\n  \"Description for column: outputTokenPriceUSD\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"Description for column: dailySnapshots\"\\n  dailySnapshots: [LiquidityPoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: hourlySnapshots\"\\n  hourlySnapshots: [LiquidityPoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: deposits\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: withdraws\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: swaps\"\\n  swaps: [Swap!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: _tradingFeeRate\"\\n  _tradingFeeRate: BigDecimal!\\n  \"Description for column: _cumulativeTradingFeeAmountUSD\"\\n  _cumulativeTradingFeeAmountUSD: BigDecimal!\\n  \"Description for column: _cumulativeWithdrawalFeeAmountUSD\"\\n  _cumulativeWithdrawalFeeAmountUSD: BigDecimal!\\n  \"Description for column: _latestRewardProgramID\"\\n  _latestRewardProgramID: BigInt!\\n}\\n\\n\"Description for table: LiquidityPoolDailySnapshot\"\\ntype LiquidityPoolDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: dailySupplySideRevenueUSD\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyProtocolSideRevenueUSD\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: dailyTotalRevenueUSD\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: dailyVolumeUSD\"\\n  dailyVolumeUSD: BigDecimal!\\n  \"Description for column: dailyVolumeByTokenAmount\"\\n  dailyVolumeByTokenAmount: [BigInt!]!\\n  \"Description for column: dailyVolumeByTokenUSD\"\\n  dailyVolumeByTokenUSD: [BigDecimal!]!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: inputTokenBalances\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Description for column: inputTokenWeights\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Description for column: outputTokenSupply\"\\n  outputTokenSupply: BigInt\\n  \"Description for column: outputTokenPriceUSD\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n}\\n\\n\"Description for table: LiquidityPoolHourlySnapshot\"\\ntype LiquidityPoolHourlySnapshot @entity @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: hourlySupplySideRevenueUSD\"\\n  hourlySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: hourlyProtocolSideRevenueUSD\"\\n  hourlyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: hourlyTotalRevenueUSD\"\\n  hourlyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: hourlyVolumeUSD\"\\n  hourlyVolumeUSD: BigDecimal!\\n  \"Description for column: hourlyVolumeByTokenAmount\"\\n  hourlyVolumeByTokenAmount: [BigInt!]!\\n  \"Description for column: hourlyVolumeByTokenUSD\"\\n  hourlyVolumeByTokenUSD: [BigDecimal!]!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: inputTokenBalances\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Description for column: inputTokenWeights\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Description for column: outputTokenSupply\"\\n  outputTokenSupply: BigInt\\n  \"Description for column: outputTokenPriceUSD\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n}\\n\\n\"Description for column: LiquidityPoolHourlySnapshot\"\\ninterface Event {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: Deposit\"\\ntype Deposit implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: inputTokenAmounts\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Description for column: outputTokenAmount\"\\n  outputTokenAmount: BigInt\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n}\\n\\n\"Description for table: Withdraw\"\\ntype Withdraw implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: inputTokenAmounts\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Description for column: outputTokenAmount\"\\n  outputTokenAmount: BigInt\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: _withdrawalFeeAmount\"\\n  _withdrawalFeeAmount: BigInt!\\n  \"Description for column: _withdrawalFeeAmountUSD\"\\n  _withdrawalFeeAmountUSD: BigDecimal!\\n}\\n\\n\"Description for table: Swap\"\\ntype Swap implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: tokenIn\"\\n  tokenIn: Token!\\n  \"Description for column: amountIn\"\\n  amountIn: BigInt!\\n  \"Description for column: amountInUSD\"\\n  amountInUSD: BigDecimal!\\n  \"Description for column: tokenOut\"\\n  tokenOut: Token!\\n  \"Description for column: amountOut\"\\n  amountOut: BigInt!\\n  \"Description for column: amountOutUSD\"\\n  amountOutUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: _tradingFeeAmount\"\\n  _tradingFeeAmount: BigInt!\\n  \"Description for column: _tradingFeeAmountUSD\"\\n  _tradingFeeAmountUSD: BigDecimal!\\n}\\n\\n\"Description for table: Account\"\\ntype Account @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n}\\n\\n\"Description for table: ActiveAccount\"\\ntype ActiveAccount @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n}\\n\\n\"Description for table: RewardProgram\"\\ntype RewardProgram @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: enabled\"\\n  enabled: Boolean!\\n  \"Description for column: totalRewards\"\\n  totalRewards: BigInt!\\n  \"Description for column: startTime\"\\n  startTime: BigInt!\\n  \"Description for column: endTime\"\\n  endTime: BigInt!\\n  \"Description for column: rewardsRate\"\\n  rewardsRate: BigInt!\\n}', 'documented_schema': '\" Network enum for the schema \"\\nenum Network {\\n  \" The ARBITRUM_ONE network \"\\n  ARBITRUM_ONE\\n  \" The AURORA network \"\\n  AURORA\\n  \" The AVALANCHE network \"\\n  AVALANCHE\\n  \" The BSC network \"\\n  BSC\\n  \" The CELO network \"\\n  CELO\\n  \" The CRONOS network \"\\n  CRONOS\\n  \" The ETHEREUM_MAINNET network \"\\n  MAINNET\\n  \" The FANTOM network \"\\n  FANTOM\\n  \" The FUSE network \"\\n  FUSE\\n  \" The HARMONY network \"\\n  HARMONY\\n  \" The JUNO network \"\\n  JUNO\\n  \" The MOONBEAM network \"\\n  MOONBEAM\\n  \" The MOONRIVER network \"\\n  MOONRIVER\\n  \" The NEAR_MAINNET network \"\\n  NEAR_MAINNET\\n  \" The OPTIMISM network \"\\n  OPTIMISM\\n  \" The MATIC network \"\\n  MATIC\\n  \" The XDAI network \"\\n  XDAI\\n}\\n\\n\" Protocol type enum for the schema \"\\nenum ProtocolType {\\n  \" The EXCHANGE protocol type \"\\n  EXCHANGE\\n  \" The LENDING protocol type \"\\n  LENDING\\n  \" The YIELD protocol type \"\\n  YIELD\\n  \" The BRIDGE protocol type \"\\n  BRIDGE\\n}\\n\\ntype Token @entity @regularPolling {\\n  \" Smart contract address of the token \"\\n  id: ID!\\n  \" Name of the token, mirrored from the smart contract \"\\n  name: String!\\n  \" Symbol of the token, mirrored from the smart contract \"\\n  symbol: String!\\n  \" The number of decimal places this token uses, default to 18 \"\\n  decimals: Int!\\n  \" Optional field to track the price of a token, mostly for caching purposes \"\\n  lastPriceUSD: BigDecimal\\n  \" Optional field to track the block number of the last token price \"\\n  lastPriceBlockNumber: BigInt\\n  _poolToken: Token\\n}\\n\\nenum RewardTokenType {\\n  \" For reward tokens awarded to LPs/lenders \"\\n  DEPOSIT\\n  \" For reward tokens awarded to borrowers \"\\n  BORROW\\n}\\n\\ntype RewardToken @entity @regularPolling {\\n  \" { Reward token type }-{ Smart contract address of the reward token } \"\\n  id: ID!\\n  \" Reference to the actual token \"\\n  token: Token!\\n  \" The type of the reward token \"\\n  type: RewardTokenType!\\n}\\n\\nenum LiquidityPoolFeeType {\\n  \" Total fixed fee paid by the user per trade, as a percentage of the traded amount. e.g. 0.3% for Uniswap v2, 0.3% for Sushiswap, 0.04% for Curve v1. \"\\n  FIXED_TRADING_FEE\\n  \" Some protocols use tiered fees instead of fixed fee (e.g. DYDX, DODO). Set `feePercentage` as 0 but handle the tiered fees in the mapping code. \"\\n  TIERED_TRADING_FEE\\n  \" Some protocols use dynamic fees instead of fixed fee (e.g. Balancer v2). Set `feePercentage` as 0 but handle the dynamic fees in the mapping code. \"\\n  DYNAMIC_TRADING_FEE\\n  \" Fixed fee that\\'s paid to the LP, as a percentage of the traded amount. e.g. 0.25% for Sushiswap, 0.02% for Curve v1. \"\\n  FIXED_LP_FEE\\n  \" Some protocols use dynamic LP fees (e.g., Bancor v2). Set `feePercentage` as 0 but handle the dynamic fees in the mapping code. \"\\n  DYNAMIC_LP_FEE\\n  \" Fixed fee that\\'s paid to the protocol, as a percentage of the traded amount. e.g. 0.05% for Sushiswap, 0.02% for Curve v1. \"\\n  FIXED_PROTOCOL_FEE\\n  \" Some protocols use dynamic protocol fees (e.g., Bancor v2). Set `feePercentage` as 0 but handle the dynamic fees in the mapping code. \"\\n  DYNAMIC_PROTOCOL_FEE\\n  \" One-time fee charged by the protocol during deposit, in percentages of the deposit token \"\\n  DEPOSIT_FEE\\n  \" One-time fee charged by the protocol (e.g. Bancor v3) during withdrawal, in percentages of the withdrawal token \"\\n  WITHDRAWAL_FEE\\n}\\n\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \" { Fee type }-{ Pool address } \"\\n  id: ID!\\n  \" Fee as a percentage of the trade (swap) amount. Does not always apply \"\\n  feePercentage: BigDecimal\\n  \" Type of fee this pool uses \"\\n  feeType: LiquidityPoolFeeType!\\n}\\n\\ninterface Protocol {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: ID!\\n  \" Name of the protocol, including version. e.g. Uniswap v3 \"\\n  name: String!\\n  \" Slug of protocol, including version. e.g. uniswap-v3 \"\\n  slug: String!\\n  \" Version of the subgraph schema, in SemVer format (e.g. 1.0.0) \"\\n  schemaVersion: String!\\n  \" Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) \"\\n  subgraphVersion: String!\\n  \" Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) \"\\n  methodologyVersion: String!\\n  \" The blockchain network this subgraph is indexing on \"\\n  network: Network!\\n  \" The type of protocol (e.g. DEX, Lending, Yield, etc) \"\\n  type: ProtocolType!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" # of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Daily usage metrics for this protocol \"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Hourly usage metrics for this protocol \"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Daily financial metrics for this protocol \"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}\\n\\ntype DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: ID!\\n  \" Name of the protocol, including version. e.g. Uniswap v3 \"\\n  name: String!\\n  \" Slug of protocol, including version. e.g. uniswap-v3 \"\\n  slug: String!\\n  \" Version of the subgraph schema, in SemVer format (e.g. 1.0.0) \"\\n  schemaVersion: String!\\n  \" Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) \"\\n  subgraphVersion: String!\\n  \" Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) \"\\n  methodologyVersion: String!\\n  \" The blockchain network this subgraph is indexing on \"\\n  network: Network!\\n  \" The type of protocol (e.g. DEX, Lending, Yield, etc) \"\\n  type: ProtocolType!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" All historical volume in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" # of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Daily usage metrics for this protocol \"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Hourly usage metrics for this protocol \"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Daily financial metrics for this protocol \"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" All pools that belong to this protocol \"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \" Liquidity pool IDs \"\\n  _poolIDs: [ID!]!\\n  \" Default trading fee rate (0-1) that applies at the protocol level \"\\n  _defaultTradingFeeRate: BigDecimal!\\n  \" Netfork fee rate (0-1) that applies at the protocol level. It goes to protocol fee \"\\n  _networkFeeRate: BigDecimal!\\n  \" Withdrawal fee rate (0-1) that applies at the protocol level. Occurs whenver user withdraws. It goes to protocol fee \"\\n  _withdrawalFeeRate: BigDecimal!\\n}\\n\\ntype UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: ID!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" # of unique daily active users \"\\n  dailyActiveUsers: Int!\\n  \" # of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface. \"\\n  dailyTransactionCount: Int!\\n  \" Total number of deposits (add liquidity) in a day \"\\n  dailyDepositCount: Int!\\n  \" Total number of withdrawals (remove liquidity) in a day \"\\n  dailyWithdrawCount: Int!\\n  \" Total number of trades (swaps) in a day \"\\n  dailySwapCount: Int!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}\\n\\ntype UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \" { # of hours since Unix epoch time } \"\\n  id: ID!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" # of unique hourly active users \"\\n  hourlyActiveUsers: Int!\\n  \" # of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface. \"\\n  hourlyTransactionCount: Int!\\n  \" Total number of deposits (add liquidity) in an hour \"\\n  hourlyDepositCount: Int!\\n  \" Total number of withdrawals (remove liquidity) in an hour \"\\n  hourlyWithdrawCount: Int!\\n  \" Total number of trades (swaps) in an hour \"\\n  hourlySwapCount: Int!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}\\n\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: ID!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" All trade volume occurred in a given day, in USD \"\\n  dailyVolumeUSD: BigDecimal!\\n  \" All historical trade volume in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}\\n\\ntype LiquidityPool @entity @regularPolling {\\n  \" Smart contract address of the pool \"\\n  id: ID!\\n  \" The protocol this pool belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT) \"\\n  name: String\\n  \" Symbol of liquidity pool (e.g. 3CRV) \"\\n  symbol: String\\n  \" Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer \"\\n  inputTokens: [Token!]!\\n  \" Token that is minted to track ownership of position in protocol \"\\n  outputToken: Token\\n  \" Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon \"\\n  rewardTokens: [RewardToken!]\\n  \" Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee. ) \"\\n  fees: [LiquidityPoolFee!]!\\n  \" Whether this pool is single-sided (e.g. Bancor, Platypus\\'s Alternative Pool). The specifics of the implementation depends on the protocol. \"\\n  isSingleSided: Boolean!\\n  \" Creation timestamp \"\\n  createdTimestamp: BigInt!\\n  \" Creation block number \"\\n  createdBlockNumber: BigInt!\\n  \" Current TVL (Total Value Locked) of this pool in USD \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" All historical trade volume occurred in this pool, in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Amount of input tokens in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalances: [BigInt!]!\\n  \" Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool \"\\n  inputTokenWeights: [BigDecimal!]!\\n  \" Total supply of output token. Note that certain DEXes don\\'t have an output token (e.g. Bancor) \"\\n  outputTokenSupply: BigInt\\n  \" Price per share of output token in USD \"\\n  outputTokenPriceUSD: BigDecimal\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day, in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \" Liquidity pool daily snapshots \"\\n  dailySnapshots: [LiquidityPoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" Liquidity pool hourly snapshots \"\\n  hourlySnapshots: [LiquidityPoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" All deposit (add liquidity) events occurred in this pool \"\\n  deposits: [Deposit!]! @derivedFrom(field: \"pool\")\\n  \" All withdraw (remove liquidity) events occurred in this pool \"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"pool\")\\n  \" All trade (swap) events occurred in this pool \"\\n  swaps: [Swap!]! @derivedFrom(field: \"pool\")\\n  \" Trading fee rate (0-1) that applies at pool level \"\\n  _tradingFeeRate: BigDecimal!\\n  \" Cumulative trading fee in USD \"\\n  _cumulativeTradingFeeAmountUSD: BigDecimal!\\n  \" Cumulative withdrawal fee in USD \"\\n  _cumulativeWithdrawalFeeAmountUSD: BigDecimal!\\n  \" The latest reward program. It matches latestProgramId from the StandardRewards contract \"\\n  _latestRewardProgramID: BigInt!\\n}\\n\\ntype LiquidityPoolDailySnapshot @entity @dailySnapshot {\\n  \" { Smart contract address of the pool }-{ # of days since Unix epoch time } \"\\n  id: ID!\\n  \" The protocol this snapshot belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" The pool this snapshot belongs to \"\\n  pool: LiquidityPool!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n  \" Current TVL (Total Value Locked) of this pool \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Daily revenue generated by the liquidity pool, accrued to the supply side. \"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" Daily revenue generated by the liquidity pool, accrued to the protocol. \"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Daily revenue generated by the liquidity pool. \"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \" All trade volume occurred in a given day, in USD \"\\n  dailyVolumeUSD: BigDecimal!\\n  \" All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  dailyVolumeByTokenAmount: [BigInt!]!\\n  \" All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  dailyVolumeByTokenUSD: [BigDecimal!]!\\n  \" All historical trade volume occurred in this pool, in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Amount of input tokens in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalances: [BigInt!]!\\n  \" Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool \"\\n  inputTokenWeights: [BigDecimal!]!\\n  \" Total supply of output token. Note that certain DEXes don\\'t have an output token (e.g. Bancor) \"\\n  outputTokenSupply: BigInt\\n  \" Price per share of output token in USD \"\\n  outputTokenPriceUSD: BigDecimal\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day, in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n}\\n\\ntype LiquidityPoolHourlySnapshot @entity @hourlySnapshot {\\n  \" { Smart contract address of the pool }-{ # of hours since Unix epoch time } \"\\n  id: ID!\\n  \" The protocol this snapshot belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" The pool this snapshot belongs to \"\\n  pool: LiquidityPool!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n  \" Current TVL (Total Value Locked) of this pool \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Hourly revenue generated by the liquidity pool, accrued to the supply side. \"\\n  hourlySupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" Hourly revenue generated by the liquidity pool, accrued to the protocol. \"\\n  hourlyProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Hourly revenue generated by the liquidity pool. \"\\n  hourlyTotalRevenueUSD: BigDecimal!\\n  \" All trade volume occurred in a given hour, in USD \"\\n  hourlyVolumeUSD: BigDecimal!\\n  \" All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  hourlyVolumeByTokenAmount: [BigInt!]!\\n  \" All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  hourlyVolumeByTokenUSD: [BigDecimal!]!\\n  \" All historical trade volume occurred in this pool, in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Amount of input tokens in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalances: [BigInt!]!\\n  \" Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool \"\\n  inputTokenWeights: [BigDecimal!]!\\n  \" Total supply of output token. Note that certain DEXes don\\'t have an output token (e.g. Bancor) \"\\n  outputTokenSupply: BigInt\\n  \" Price per share of output token in USD \"\\n  outputTokenPriceUSD: BigDecimal\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day (not hour), in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n}\\n\\n\"\"\"\\nAn event is any user action that occurs in a protocol. Generally, they are Ethereum events\\nemitted by a function in the smart contracts, stored in transaction receipts as event logs.\\nHowever, some user actions of interest are function calls that don\\'t emit events. For example,\\nthe deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still\\nstore them as events, although they are not technically Ethereum events emitted by smart\\ncontracts.\\n\"\"\"\\ninterface Event {\\n  \" { Event type }-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n}\\n\\ntype Deposit implements Event @entity @transaction {\\n  \" deposit-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool \"\\n  inputTokens: [Token!]!\\n  \" Output token of the pool. E.g. the UNI-LP token \"\\n  outputToken: Token\\n  \" Amount of input tokens in the token\\'s native unit \"\\n  inputTokenAmounts: [BigInt!]!\\n  \" Amount of output tokens in the token\\'s native unit \"\\n  outputTokenAmount: BigInt\\n  \" USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool) \"\\n  amountUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n}\\n\\ntype Withdraw implements Event @entity @transaction {\\n  \" withdraw-{ Transaction hash }-{ Log index }\"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool \"\\n  inputTokens: [Token!]!\\n  \" Output token of the pool (not output token of the event/transaction). E.g. the UNI-LP token \"\\n  outputToken: Token\\n  \" Amount of input tokens in the token\\'s native unit \"\\n  inputTokenAmounts: [BigInt!]!\\n  \" Amount of output tokens in the token\\'s native unit \"\\n  outputTokenAmount: BigInt\\n  \" USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool) \"\\n  amountUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n  _withdrawalFeeAmount: BigInt!\\n  _withdrawalFeeAmountUSD: BigDecimal!\\n}\\n\\ntype Swap implements Event @entity @transaction {\\n  \" swap-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Token deposited into pool \"\\n  tokenIn: Token!\\n  \" Amount of token deposited into pool in native units \"\\n  amountIn: BigInt!\\n  \" Amount of token deposited into pool in USD \"\\n  amountInUSD: BigDecimal!\\n  \" Token withdrawn from pool \"\\n  tokenOut: Token!\\n  \" Amount of token withdrawn from pool in native units \"\\n  amountOut: BigInt!\\n  \" Amount of token withdrawn from pool in USD \"\\n  amountOutUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n  _tradingFeeAmount: BigInt!\\n  _tradingFeeAmountUSD: BigDecimal!\\n}\\n\\ntype Account @entity @regularPolling {\\n  \" Address of the account \"\\n  id: ID!\\n}\\n\\ntype ActiveAccount @entity {\\n  \" { daily/hourly }-{ Address of the account }-{ Days/hours since Unix epoch } \"\\n  id: ID!\\n}\\n\\ntype RewardProgram @entity {\\n  id: ID!\\n  pool: LiquidityPool!\\n  enabled: Boolean!\\n  totalRewards: BigInt!\\n  startTime: BigInt!\\n  endTime: BigInt!\\n  rewardsRate: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema includes several types, enums, and interfaces, each with specific fields. Each field is already accompanied by a description, which is consistent with the task requirements. The descriptions are concise and factual, directly reflecting the field names and their purposes. The schema is well-documented, with each field having a clear and direct description that aligns with its name and expected data type. Therefore, the task of generating precise descriptions for the columns is already fulfilled by the existing documentation in the schema.',\n    documented_schema='\"Description for enum type: Network\"\\nenum Network {\\n  \"Description for column: ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"Description for column: AURORA\"\\n  AURORA\\n  \"Description for column: AVALANCHE\"\\n  AVALANCHE\\n  \"Description for column: BSC\"\\n  BSC\\n  \"Description for column: CELO\"\\n  CELO\\n  \"Description for column: CRONOS\"\\n  CRONOS\\n  \"Description for column: MAINNET\"\\n  MAINNET\\n  \"Description for column: FANTOM\"\\n  FANTOM\\n  \"Description for column: FUSE\"\\n  FUSE\\n  \"Description for column: HARMONY\"\\n  HARMONY\\n  \"Description for column: JUNO\"\\n  JUNO\\n  \"Description for column: MOONBEAM\"\\n  MOONBEAM\\n  \"Description for column: MOONRIVER\"\\n  MOONRIVER\\n  \"Description for column: NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"Description for column: OPTIMISM\"\\n  OPTIMISM\\n  \"Description for column: MATIC\"\\n  MATIC\\n  \"Description for column: XDAI\"\\n  XDAI\\n}\\n\\n\"Description for enum type: ProtocolType\"\\nenum ProtocolType {\\n  \"Description for column: EXCHANGE\"\\n  EXCHANGE\\n  \"Description for column: LENDING\"\\n  LENDING\\n  \"Description for column: YIELD\"\\n  YIELD\\n  \"Description for column: BRIDGE\"\\n  BRIDGE\\n}\\n\\n\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: symbol\"\\n  symbol: String!\\n  \"Description for column: decimals\"\\n  decimals: Int!\\n  \"Description for column: lastPriceUSD\"\\n  lastPriceUSD: BigDecimal\\n  \"Description for column: lastPriceBlockNumber\"\\n  lastPriceBlockNumber: BigInt\\n  \"Description for column: _poolToken\"\\n  _poolToken: Token\\n}\\n\\n\"Description for enum type: RewardTokenType\"\\nenum RewardTokenType {\\n  \"Description for column: DEPOSIT\"\\n  DEPOSIT\\n  \"Description for column: BORROW\"\\n  BORROW\\n}\\n\\n\"Description for table: RewardToken\"\\ntype RewardToken @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: type\"\\n  type: RewardTokenType!\\n}\\n\\n\"Description for enum type: LiquidityPoolFeeType\"\\nenum LiquidityPoolFeeType {\\n  \"Description for column: FIXED_TRADING_FEE\"\\n  FIXED_TRADING_FEE\\n  \"Description for column: TIERED_TRADING_FEE\"\\n  TIERED_TRADING_FEE\\n  \"Description for column: DYNAMIC_TRADING_FEE\"\\n  DYNAMIC_TRADING_FEE\\n  \"Description for column: FIXED_LP_FEE\"\\n  FIXED_LP_FEE\\n  \"Description for column: DYNAMIC_LP_FEE\"\\n  DYNAMIC_LP_FEE\\n  \"Description for column: FIXED_PROTOCOL_FEE\"\\n  FIXED_PROTOCOL_FEE\\n  \"Description for column: DYNAMIC_PROTOCOL_FEE\"\\n  DYNAMIC_PROTOCOL_FEE\\n  \"Description for column: DEPOSIT_FEE\"\\n  DEPOSIT_FEE\\n  \"Description for column: WITHDRAWAL_FEE\"\\n  WITHDRAWAL_FEE\\n}\\n\\n\"Description for table: LiquidityPoolFee\"\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: feePercentage\"\\n  feePercentage: BigDecimal\\n  \"Description for column: feeType\"\\n  feeType: LiquidityPoolFeeType!\\n}\\n\\n\"Description for column: LiquidityPoolFee\"\\ninterface Protocol {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: schemaVersion\"'\n)",
      1
    ],
    [
      "Example({'database_schema': '\"Description for table: Protocol\"\\ntype Protocol @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: type\"\\n  type: ProtocolType!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeDepositVolumeUSD\"\\n  cumulativeDepositVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeWithdrawalVolumeUSD\"\\n  cumulativeWithdrawalVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalVolumeUSD\"\\n  cumulativeTotalVolumeUSD: BigDecimal!\\n  \"Description for column: netVolumeUSD\"\\n  netVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeUniqueDepositors\"\\n  cumulativeUniqueDepositors: Int!\\n  \"Description for column: cumulativeUniqueWithdrawers\"\\n  cumulativeUniqueWithdrawers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: cumulativeDepositCount\"\\n  cumulativeDepositCount: Int!\\n  \"Description for column: cumulativeWithdrawalCount\"\\n  cumulativeWithdrawalCount: Int!\\n  \"Description for column: cumulativeTransactionCount\"\\n  cumulativeTransactionCount: Int!\\n  \"Description for column: totalEigenPodCount\"\\n  totalEigenPodCount: Int!\\n  \"Description for column: totalStrategyCount\"\\n  totalStrategyCount: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: pools\"\\n  pools: [Pool!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: dailyUsageMetrics\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: hourlyUsageMetrics\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: financialMetrics\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}', 'documented_schema': 'type Protocol @entity @regularPolling {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: Bytes!\\n  \" Name of the protocol, including version. e.g. Uniswap v3 \"\\n  name: String!\\n  \" Slug of protocol, including version. e.g. uniswap-v3 \"\\n  slug: String!\\n  \" Version of the subgraph schema, in SemVer format (e.g. 1.0.0) \"\\n  schemaVersion: String!\\n  \" Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) \"\\n  subgraphVersion: String!\\n  \" Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) \"\\n  methodologyVersion: String!\\n  \" The blockchain network this subgraph is indexing on \"\\n  network: Network!\\n  \" The type of protocol (e.g. DEX, Lending, Yield, etc) \"\\n  type: ProtocolType!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Cumulative value of staked eth deposited \"\\n  cumulativeDepositVolumeUSD: BigDecimal!\\n  \" Cumulative value of restaked eth withdrawn \"\\n  cumulativeWithdrawalVolumeUSD: BigDecimal!\\n  \" Volume deposited plus volume withdrawn \"\\n  cumulativeTotalVolumeUSD: BigDecimal!\\n  \" Volume deposited minus volume withdrawn \"\\n  netVolumeUSD: BigDecimal!\\n  \" Number of cumulative unique addresses that deposited staked eth \"\\n  cumulativeUniqueDepositors: Int!\\n  \" Number of cumulative unique addresses that withdrew restaked eth \"\\n  cumulativeUniqueWithdrawers: Int!\\n  \" Number of cumulative unique addresses \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of deposits \"\\n  cumulativeDepositCount: Int!\\n  \" Total number of withdrawals \"\\n  cumulativeWithdrawalCount: Int!\\n  \" Total number of transactions \"\\n  cumulativeTransactionCount: Int!\\n  \" Total number of EigenPods \"\\n  totalEigenPodCount: Int!\\n  \" Total number of Strategies \"\\n  totalStrategyCount: Int!\\n  \" Total number of (EigenPods plus Strategies) \"\\n  totalPoolCount: Int!\\n  \" All pools that belong to this protocol \"\\n  pools: [Pool!]! @derivedFrom(field: \"protocol\")\\n  \" Daily usage metrics for this protocol \"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Hourly usage metrics for this protocol \"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Daily financial metrics for this protocol \"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type named `Protocol` with various fields, each having a specific data type and some with directives like `@entity`, `@regularPolling`, and `@derivedFrom`. The task is to document each field with a concise description based on the field names and types. The descriptions should be factual and directly related to the field's purpose or data type, without altering the schema structure.\",\n    documented_schema='\"Description for table: Protocol\"\\ntype Protocol @entity @regularPolling {\\n  \"Unique identifier for the protocol.\"\\n  id: Bytes!\\n  \"Name of the protocol.\"\\n  name: String!\\n  \"URL-friendly version of the protocol name.\"\\n  slug: String!\\n  \"Version of the schema used by the protocol.\"\\n  schemaVersion: String!\\n  \"Version of the subgraph for the protocol.\"\\n  subgraphVersion: String!\\n  \"Version of the methodology applied to the protocol.\"\\n  methodologyVersion: String!\\n  \"Network on which the protocol operates.\"\\n  network: Network!\\n  \"Type of the protocol.\"\\n  type: ProtocolType!\\n  \"Total value locked in USD within the protocol.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Value controlled by the protocol in USD.\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Cumulative revenue from the supply side in USD.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue from the protocol side in USD.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Total cumulative revenue in USD.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Cumulative volume of deposits in USD.\"\\n  cumulativeDepositVolumeUSD: BigDecimal!\\n  \"Cumulative volume of withdrawals in USD.\"\\n  cumulativeWithdrawalVolumeUSD: BigDecimal!\\n  \"Total cumulative transaction volume in USD.\"\\n  cumulativeTotalVolumeUSD: BigDecimal!\\n  \"Net volume in USD after accounting for deposits and withdrawals.\"\\n  netVolumeUSD: BigDecimal!\\n  \"Total number of unique depositors.\"\\n  cumulativeUniqueDepositors: Int!\\n  \"Total number of unique withdrawers.\"\\n  cumulativeUniqueWithdrawers: Int!\\n  \"Total number of unique users interacting with the protocol.\"\\n  cumulativeUniqueUsers: Int!\\n  \"Total count of deposit transactions.\"\\n  cumulativeDepositCount: Int!\\n  \"Total count of withdrawal transactions.\"\\n  cumulativeWithdrawalCount: Int!\\n  \"Total count of all transactions.\"\\n  cumulativeTransactionCount: Int!\\n  \"Total number of eigen pods associated with the protocol.\"\\n  totalEigenPodCount: Int!\\n  \"Total number of strategies implemented by the protocol.\"\\n  totalStrategyCount: Int!\\n  \"Total number of pools available in the protocol.\"\\n  totalPoolCount: Int!\\n  \"List of pools derived from the protocol.\"\\n  pools: [Pool!]! @derivedFrom(field: \"protocol\")\\n  \"Daily snapshots of usage metrics derived from the protocol.\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Hourly snapshots of usage metrics derived from the protocol.\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Daily snapshots of financial metrics derived from the protocol.\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Position\"\\ntype Position @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: account\"\\n  account: Account!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: hashOpened\"\\n  hashOpened: Bytes!\\n  \"Description for column: hashClosed\"\\n  hashClosed: Bytes\\n  \"Description for column: blockNumberOpened\"\\n  blockNumberOpened: BigInt!\\n  \"Description for column: timestampOpened\"\\n  timestampOpened: BigInt!\\n  \"Description for column: blockNumberClosed\"\\n  blockNumberClosed: BigInt\\n  \"Description for column: timestampClosed\"\\n  timestampClosed: BigInt\\n  \"Description for column: tickLower\"\\n  tickLower: Tick\\n  \"Description for column: tickUpper\"\\n  tickUpper: Tick\\n  \"Description for column: liquidityToken\"\\n  liquidityToken: Token\\n  \"Description for column: liquidityTokenType\"\\n  liquidityTokenType: TokenType\\n  \"Description for column: liquidity\"\\n  liquidity: BigInt!\\n  \"Description for column: liquidityUSD\"\\n  liquidityUSD: BigDecimal!\\n  \"Description for column: cumulativeDepositTokenAmounts\"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \"Description for column: cumulativeDepositUSD\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Description for column: cumulativeWithdrawTokenAmounts\"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \"Description for column: cumulativeWithdrawUSD\"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \"Description for column: cumulativeRewardUSD\"\\n  cumulativeRewardUSD: [BigInt!]\\n  \"Description for column: depositCount\"\\n  depositCount: Int!\\n  \"Description for column: deposits\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \"Description for column: withdrawCount\"\\n  withdrawCount: Int!\\n  \"Description for column: withdraws\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \"Description for column: snapshots\"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n}', 'documented_schema': 'type Position @entity @regularPolling {\\n  \" { Account address }-{ Market address }-{ Count } \"\\n  id: Bytes!\\n  \" Account that owns this position \"\\n  account: Account!\\n  \" The liquidity pool in which this position was opened \"\\n  pool: LiquidityPool!\\n  \" The hash of the transaction that opened this position \"\\n  hashOpened: Bytes!\\n  \" The hash of the transaction that closed this position \"\\n  hashClosed: Bytes\\n  \" Block number of when the position was opened \"\\n  blockNumberOpened: BigInt!\\n  \" Timestamp when the position was opened \"\\n  timestampOpened: BigInt!\\n  \" Block number of when the position was closed (0 if still open) \"\\n  blockNumberClosed: BigInt\\n  \" Timestamp when the position was closed (0 if still open) \"\\n  timestampClosed: BigInt\\n  \" lower tick of the position \"\\n  tickLower: Tick\\n  \" upper tick of the position \"\\n  tickUpper: Tick\\n  \" Token that is to represent ownership of liquidity \"\\n  liquidityToken: Token\\n  \" Type of token used to track liquidity \"\\n  liquidityTokenType: TokenType\\n  \" total position liquidity \"\\n  liquidity: BigInt!\\n  \" total position liquidity in USD \"\\n  liquidityUSD: BigDecimal!\\n  \" amount of tokens ever deposited to position \"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \" amount of tokens in USD deposited to position \"\\n  cumulativeDepositUSD: BigDecimal!\\n  \" amount of tokens ever withdrawn from position (without fees) \"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \" amount of tokens in USD withdrawn from position (without fees) \"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \" Total reward token accumulated under this position, in USD \"\\n  cumulativeRewardUSD: [BigInt!]\\n  \" Number of deposits related to this position \"\\n  depositCount: Int!\\n  \" All deposit events of this position \"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \" Number of withdrawals related to this position \"\\n  withdrawCount: Int!\\n  \" All withdraw events of this position \"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \" Position daily snapshots for open positions \"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Position` type with various fields, each having a specific data type and some with additional directives. The task is to generate concise and factual descriptions for each field based on the information given in the schema. The descriptions should be clear and directly related to the field's purpose or data type, without adding any speculative information. The documentation should be formatted correctly to ensure clarity and maintain the structure of the schema.\",\n    documented_schema='\"Description for table: Position\"\\ntype Position @entity @regularPolling {\\n  \"Unique identifier for the position\"\\n  id: Bytes!\\n  \"Reference to the account associated with the position\"\\n  account: Account!\\n  \"Reference to the liquidity pool associated with the position\"\\n  pool: LiquidityPool!\\n  \"Hash value when the position was opened\"\\n  hashOpened: Bytes!\\n  \"Hash value when the position was closed, if applicable\"\\n  hashClosed: Bytes\\n  \"Block number when the position was opened\"\\n  blockNumberOpened: BigInt!\\n  \"Timestamp when the position was opened\"\\n  timestampOpened: BigInt!\\n  \"Block number when the position was closed, if applicable\"\\n  blockNumberClosed: BigInt\\n  \"Timestamp when the position was closed, if applicable\"\\n  timestampClosed: BigInt\\n  \"Lower tick boundary for the position\"\\n  tickLower: Tick\\n  \"Upper tick boundary for the position\"\\n  tickUpper: Tick\\n  \"Token representing liquidity in the position\"\\n  liquidityToken: Token\\n  \"Type of the liquidity token\"\\n  liquidityTokenType: TokenType\\n  \"Amount of liquidity in the position\"\\n  liquidity: BigInt!\\n  \"USD value of the liquidity in the position\"\\n  liquidityUSD: BigDecimal!\\n  \"Cumulative amounts of deposit tokens\"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \"Cumulative USD value of deposits\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Cumulative amounts of withdrawn tokens\"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \"Cumulative USD value of withdrawals\"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \"Cumulative USD value of rewards\"\\n  cumulativeRewardUSD: [BigInt!]\\n  \"Number of deposits made\"\\n  depositCount: Int!\\n  \"List of deposits associated with the position\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \"Number of withdrawals made\"\\n  withdrawCount: Int!\\n  \"List of withdrawals associated with the position\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \"List of snapshots capturing the state of the position over time\"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: _ActivityHelper\"\\ntype _ActivityHelper @entity {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hourlyActiveUsers\"\\n  hourlyActiveUsers: Int!\\n  \"Description for column: dailyActiveUsers\"\\n  dailyActiveUsers: Int!\\n  \"Description for column: hourlyActiveTransferSenders\"\\n  hourlyActiveTransferSenders: Int!\\n  \"Description for column: dailyActiveTransferSenders\"\\n  dailyActiveTransferSenders: Int!\\n  \"Description for column: hourlyActiveTransferReceivers\"\\n  hourlyActiveTransferReceivers: Int!\\n  \"Description for column: dailyActiveTransferReceivers\"\\n  dailyActiveTransferReceivers: Int!\\n  \"Description for column: hourlyActiveMessageSenders\"\\n  hourlyActiveMessageSenders: Int!\\n  \"Description for column: dailyActiveMessageSenders\"\\n  dailyActiveMessageSenders: Int!\\n  \"Description for column: hourlyActiveLiquidityProviders\"\\n  hourlyActiveLiquidityProviders: Int!\\n  \"Description for column: dailyActiveLiquidityProviders\"\\n  dailyActiveLiquidityProviders: Int!\\n}', 'documented_schema': 'type _ActivityHelper @entity {\\n  id: Bytes!\\n  hourlyActiveUsers: Int!\\n  dailyActiveUsers: Int!\\n  hourlyActiveTransferSenders: Int!\\n  dailyActiveTransferSenders: Int!\\n  hourlyActiveTransferReceivers: Int!\\n  dailyActiveTransferReceivers: Int!\\n  hourlyActiveMessageSenders: Int!\\n  dailyActiveMessageSenders: Int!\\n  hourlyActiveLiquidityProviders: Int!\\n  dailyActiveLiquidityProviders: Int!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `_ActivityHelper`, with various fields that track different types of user activity over hourly and daily periods. Each field is clearly named to indicate the specific type of activity and the time frame it covers. The task is to ensure that each field is documented with a concise and factual description that aligns with its name and purpose, without altering the underlying schema.',\n    documented_schema='\"Description for table: _ActivityHelper\"\\ntype _ActivityHelper @entity {\\n  \"Unique identifier for the activity record\"\\n  id: Bytes!\\n  \"Number of users active in the last hour\"\\n  hourlyActiveUsers: Int!\\n  \"Number of users active in the last day\"\\n  dailyActiveUsers: Int!\\n  \"Number of users who sent transfers in the last hour\"\\n  hourlyActiveTransferSenders: Int!\\n  \"Number of users who sent transfers in the last day\"\\n  dailyActiveTransferSenders: Int!\\n  \"Number of users who received transfers in the last hour\"\\n  hourlyActiveTransferReceivers: Int!\\n  \"Number of users who received transfers in the last day\"\\n  dailyActiveTransferReceivers: Int!\\n  \"Number of users who sent messages in the last hour\"\\n  hourlyActiveMessageSenders: Int!\\n  \"Number of users who sent messages in the last day\"\\n  dailyActiveMessageSenders: Int!\\n  \"Number of liquidity providers active in the last hour\"\\n  hourlyActiveLiquidityProviders: Int!\\n  \"Number of liquidity providers active in the last day\"\\n  dailyActiveLiquidityProviders: Int!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transactionHash\"\\n  transactionHash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: isBundle\"\\n  isBundle: Boolean!\\n  \"Description for column: collection\"\\n  collection: Collection!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: priceETH\"\\n  priceETH: BigDecimal!\\n  \"Description for column: strategy\"\\n  strategy: SaleStrategy!\\n  \"Description for column: buyer\"\\n  buyer: String!\\n  \"Description for column: seller\"\\n  seller: String!\\n}', 'documented_schema': '\" Trades exist such as a combination of taker/order and bid/ask. \"\\ntype Trade @entity @transaction {\\n  \" The id for a trade is combination of the following components: { Transaction hash }-{ Log index }-{ (optional) ID within bundle } \"\\n  id: ID!\\n  \" The transaction has that the trade is executed in. This is a unique identifier for the transaction. It is possible that multiple trades are executed in a single transaction. \"\\n  transactionHash: String!\\n  \" This represents the index of the log within the transaction. It is a unique identifier for the log within the transaction. The event corresponds to a trade event. \"\\n  logIndex: Int\\n  \" Block timestamp where the trade is executed. This is based on the timestamp of the block where the trade is executed. \"\\n  timestamp: BigInt!\\n  \" Block number where the trade is executed. A block is a collection of transactions that are executed on the blockchain. \"\\n  blockNumber: BigInt!\\n  \" Whether the trade is in a bundle. Trades can be in a bundle, which means that multiple NFTs are traded together. \"\\n  isBundle: Boolean!\\n  \" Collection involved. This is the collection that the trade, and corresponding NFT, is associated with. \"\\n  collection: Collection!\\n  \" The token ID is the unique identifier for the NFT that is traded. It is unique within the collection. \"\\n  tokenId: BigInt!\\n  \" The amount of token to transfer. It is set at 1 except for ERC1155 batch. \"\\n  amount: BigInt!\\n  \" Price (in ETH). If only 1 tokenId is involved, then the price is determined by the token only. If the trade is incurred by a batch purchasing (available in x2y2), then the price is the average price in the batch. \"\\n  priceETH: BigDecimal!\\n  \" The strategy that the trade is executed with. This is a sale strategy that is used to execute the trade. It is defined by the SaleStrategy Enum. \"\\n  strategy: SaleStrategy!\\n  \" The buyer account address is the address of the account that is purchasing the NFT(s). \"\\n  buyer: String!\\n  \" The seller account address is the address of the account that is selling the NFT(s). \"\\n  seller: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Trade` entity with various fields, each representing a specific attribute of a trade transaction. The task is to document each field with a concise and factual description based on the information given in the schema. The descriptions should be clear and directly related to the field's purpose or data type, without altering the schema structure.\",\n    documented_schema='\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Unique identifier for the trade\"\\n  id: ID!\\n  \"Hash of the transaction\"\\n  transactionHash: String!\\n  \"Index of the log entry in the transaction\"\\n  logIndex: Int\\n  \"Timestamp of when the trade occurred\"\\n  timestamp: BigInt!\\n  \"Block number in which the trade was included\"\\n  blockNumber: BigInt!\\n  \"Indicates if the trade is part of a bundle\"\\n  isBundle: Boolean!\\n  \"Collection associated with the trade\"\\n  collection: Collection!\\n  \"Identifier for the token involved in the trade\"\\n  tokenId: BigInt!\\n  \"Amount of tokens traded\"\\n  amount: BigInt!\\n  \"Price of the trade in ETH\"\\n  priceETH: BigDecimal!\\n  \"Strategy used for the sale\"\\n  strategy: SaleStrategy!\\n  \"Address of the buyer\"\\n  buyer: String!\\n  \"Address of the seller\"\\n  seller: String!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt\\n  \"Description for column: nftStandard\"\\n  nftStandard: NftStandard!\\n  \"Description for column: royaltyFee\"\\n  royaltyFee: BigDecimal!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: buyerCount\"\\n  buyerCount: Int!\\n  \"Description for column: sellerCount\"\\n  sellerCount: Int!\\n  \"Description for column: trades\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}', 'documented_schema': 'type Collection @entity @regularPolling {\\n  \" Contract address. \"\\n  id: ID!\\n  \" Collection name, mirrored from the smart contract. Leave null if not available. \"\\n  name: String\\n  \" Collection symbol, mirrored from the smart contract. Leave null if not available. \"\\n  symbol: String\\n  \" Total supply of the collection, mirrored from the smart contract. \"\\n  totalSupply: BigInt\\n  \" NFT Standard the collection uses. \"\\n  nftStandard: NftStandard!\\n  \" Royalty fee rate in percentage. E.g. 2.5% should be 2.5 \"\\n  royaltyFee: BigDecimal!\\n  \" Cumulative trade volume (in ETH) \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" Revenue that goes to the marketplace protocol, aka protocol fee. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" Revenue that goes to creator, aka royalty fee. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" Sum of marketplaceRevenue and creatorRevenue. \"\\n  totalRevenueETH: BigDecimal!\\n  \" Trade count of the collection on the marketplace. \"\\n  tradeCount: Int!\\n  \" Buyer count. \"\\n  buyerCount: Int!\\n  \" Seller count. \"\\n  sellerCount: Int!\\n  \" Trades of the collection. \"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Collection` type with various fields, each having a specific data type and some with non-null constraints. The task is to generate concise and factual descriptions for each field based on the schema. The descriptions should be clear and directly related to the field's purpose or data type, without altering the schema structure.\",\n    documented_schema='\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Unique identifier for the collection\"\\n  id: ID!\\n  \"Name of the collection\"\\n  name: String\\n  \"Symbol representing the collection\"\\n  symbol: String\\n  \"Total supply of items in the collection\"\\n  totalSupply: BigInt\\n  \"Standard of the NFTs in the collection\"\\n  nftStandard: NftStandard!\\n  \"Royalty fee percentage for the collection\"\\n  royaltyFee: BigDecimal!\\n  \"Cumulative trade volume in ETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Revenue generated by the marketplace in ETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Revenue generated by the creator in ETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Total revenue generated in ETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Number of trades involving the collection\"\\n  tradeCount: Int!\\n  \"Number of unique buyers in the collection\"\\n  buyerCount: Int!\\n  \"Number of unique sellers in the collection\"\\n  sellerCount: Int!\\n  \"List of trades associated with the collection\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: CreatorContractSetting\"\\ntype CreatorContractSetting @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: factoryContract\"\\n  factoryContract: Bytes!\\n  \"Description for column: kodaSalesSettingsContract\"\\n  kodaSalesSettingsContract: Bytes!\\n  \"Description for column: platform\"\\n  platform: Bytes!\\n  \"Description for column: platformPrimaryCommission\"\\n  platformPrimaryCommission: BigInt!\\n  \"Description for column: platformSecondaryCommission\"\\n  platformSecondaryCommission: BigInt!\\n  \"Description for column: MODULO\"\\n  MODULO: BigInt!\\n}', 'documented_schema': '\" A table of creator contract settings. \"\\ntype CreatorContractSetting @entity {\\n  \" The unique identifier for the creator contract setting. \"\\n  id: ID!\\n  \" The factory contract of the creator contract. \"\\n  factoryContract: Bytes!\\n  \" The KODA sales settings contract of the creator contract. \"\\n  kodaSalesSettingsContract: Bytes!\\n  \" The platform of the creator contract. \"\\n  platform: Bytes!\\n  \" The platform primary commission. \"\\n  platformPrimaryCommission: BigInt!\\n  \" The platform secondary commission. \"\\n  platformSecondaryCommission: BigInt!\\n  \" The modulo for the platform. \"\\n  MODULO: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a single entity, `CreatorContractSetting`, with several fields. Each field has a type and a brief description. The task is to ensure that each field is documented with a concise and factual description, maintaining the original structure and format of the schema. The descriptions should be clear and directly related to the field's purpose or data type.\",\n    documented_schema='\"Description for table: CreatorContractSetting\"\\ntype CreatorContractSetting @entity {\\n  \"Unique identifier for the creator contract setting\"\\n  id: ID!\\n  \"Address of the factory contract associated with the creator\"\\n  factoryContract: Bytes!\\n  \"Address of the KODA sales settings contract\"\\n  kodaSalesSettingsContract: Bytes!\\n  \"Platform address related to the creator contract\"\\n  platform: Bytes!\\n  \"Commission percentage for primary sales on the platform\"\\n  platformPrimaryCommission: BigInt!\\n  \"Commission percentage for secondary sales on the platform\"\\n  platformSecondaryCommission: BigInt!\\n  \"Constant value used for commission calculations\"\\n  MODULO: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt\\n  \"Description for column: nftStandard\"\\n  nftStandard: NftStandard!\\n  \"Description for column: royaltyFee\"\\n  royaltyFee: BigDecimal!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: buyerCount\"\\n  buyerCount: Int!\\n  \"Description for column: sellerCount\"\\n  sellerCount: Int!\\n  \"Description for column: trades\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}', 'documented_schema': '\" A collection is a group of NFTs that are created by the same creator. This is a unique entity that maps to collections on the marketplace. \"\\ntype Collection @entity @regularPolling {\\n  \" This is the unique identifier for the collection, and is the contract address of the collection. \"\\n  id: ID!\\n  \" This is the name of the collection, and is the name that is given to the collection by the creator. It is mirrored from the smart contract, and left null if not available. \"\\n  name: String\\n  \" This is the symbol of the collection, and is the symbol that is given to the collection by the creator. It is mirrored from the smart contract, and left null if not available. \"\\n  symbol: String\\n  \" This is the total supply of the collection (number of NFTs within a given collection), and is mirrored from the smart contract. \"\\n  totalSupply: BigInt\\n  \" This is the NFT standard that the collection uses. This can be either ERC721, ERC1155, or Unknown. It must be one of the values present within the NftStandard Enum. \"\\n  nftStandard: NftStandard!\\n  \" This is the fee that is taken by the creator of the NFT when it is traded. It is akin to a royalty fee. It is a fee rte in percentage. E.g. 2.5% should be 2.5. \"\\n  royaltyFee: BigDecimal!\\n  \" The cumulative trade volume in ETH that has occurred for the collection. This is the total value of all trades that have occurred for the collection (in ETH). \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The revenue that is collected by the marketplace protocol for facilitating trades of the collection (in ETH). This is akin to a protocol fee. It is represented in ETH. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" The revenue that is collected by the creator of the NFT when it is traded (in ETH). This is akin to a royalty fee. It is represented in ETH. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" The total revenue that has been generated by the collection (in ETH). This is calculated by adding the marketplace revenue and the creator revenue. It is represented in ETH. \"\\n  totalRevenueETH: BigDecimal!\\n  \" This is the number of trades that have occurred for the collection on the marketplace. Each trade is a unique transaction. \"\\n  tradeCount: Int!\\n  \" The total number of unique buyers that have participated in trades for the collection. \"\\n  buyerCount: Int!\\n  \" The total number of unique sellers that have participated in trades for the collection. \"\\n  sellerCount: Int!\\n  \" This maps to the Trade entity, and is a list of trades that have occurred for the collection. \"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Collection` type with various fields, each having a specific data type and some with non-null constraints. The task is to generate concise and factual descriptions for each field based on the schema. The descriptions should be clear and directly related to the field's purpose or data type, without altering the schema structure.\",\n    documented_schema='\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Unique identifier for the collection\"\\n  id: ID!\\n  \"Name of the collection\"\\n  name: String\\n  \"Symbol representing the collection\"\\n  symbol: String\\n  \"Total supply of items in the collection\"\\n  totalSupply: BigInt\\n  \"Standard of the NFTs in the collection\"\\n  nftStandard: NftStandard!\\n  \"Royalty fee percentage for the collection\"\\n  royaltyFee: BigDecimal!\\n  \"Cumulative trade volume in ETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Revenue generated by the marketplace in ETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Revenue generated by the creator in ETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Total revenue generated in ETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Number of trades involving the collection\"\\n  tradeCount: Int!\\n  \"Number of unique buyers in the collection\"\\n  buyerCount: Int!\\n  \"Number of unique sellers in the collection\"\\n  sellerCount: Int!\\n  \"List of trades associated with the collection\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: NameChanged\"\\ntype NameChanged implements ResolverEvent @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: resolver\"\\n  resolver: Resolver!\\n  \"Description for column: blockNumber\"\\n  blockNumber: Int!\\n  \"Description for column: transactionID\"\\n  transactionID: Bytes!\\n  \"Description for column: name\"\\n  name: String!\\n}', 'documented_schema': '\" A table of name changed events. A name changed event is an event that occurs when a resolver is used to update a name. This implements the ResolverEvent interface. \"\\ntype NameChanged implements ResolverEvent @entity {\\n  \" The unique identifier for the event. Type: ID! \"\\n  id: ID!\\n  \" The resolver associated with the event. References the Resolver entity that is associated with the event. Type: Resolver! \"\\n  resolver: Resolver!\\n  \" The block number at which the event occurred. Type: Int! \"\\n  blockNumber: Int!\\n  \" The transaction ID for the transaction in which the event occurred. Type: Bytes! \"\\n  transactionID: Bytes!\\n  \" The new ENS name value. Type: String! \"\\n  name: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `NameChanged` which implements the `ResolverEvent` interface. Each field within this type is already accompanied by a description. The task is to ensure that these descriptions are clear and concise, focusing on the specific role of each field within the `NameChanged` type. The descriptions should be factual and directly related to the schema's structure.\",\n    documented_schema='\"Description for table: NameChanged\"\\ntype NameChanged implements ResolverEvent @entity {\\n  \"Unique identifier for the NameChanged event\"\\n  id: ID!\\n  \"Reference to the resolver associated with the event\"\\n  resolver: Resolver!\\n  \"Block number in which the event was recorded\"\\n  blockNumber: Int!\\n  \"Identifier for the transaction in which the event occurred\"\\n  transactionID: Bytes!\\n  \"Name that was changed in the event\"\\n  name: String!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for enum type: Network\"\\nenum Network {\\n  \"Description for column: ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"Description for column: ARWEAVE_MAINNET\"\\n  ARWEAVE_MAINNET\\n  \"Description for column: AURORA\"\\n  AURORA\\n  \"Description for column: AVALANCHE\"\\n  AVALANCHE\\n  \"Description for column: BASE\"\\n  BASE\\n  \"Description for column: BOBA\"\\n  BOBA\\n  \"Description for column: BSC\"\\n  BSC\\n  \"Description for column: CELO\"\\n  CELO\\n  \"Description for column: COSMOS\"\\n  COSMOS\\n  \"Description for column: CRONOS\"\\n  CRONOS\\n  \"Description for column: MAINNET\"\\n  MAINNET\\n  \"Description for column: FANTOM\"\\n  FANTOM\\n  \"Description for column: HARMONY\"\\n  HARMONY\\n  \"Description for column: JUNO\"\\n  JUNO\\n  \"Description for column: MOONBEAM\"\\n  MOONBEAM\\n  \"Description for column: MOONRIVER\"\\n  MOONRIVER\\n  \"Description for column: NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"Description for column: OPTIMISM\"\\n  OPTIMISM\\n  \"Description for column: OSMOSIS\"\\n  OSMOSIS\\n  \"Description for column: MATIC\"\\n  MATIC\\n  \"Description for column: XDAI\"\\n  XDAI\\n}', 'documented_schema': '\" Network enum for the schema \"\\nenum Network {\\n  \" The ARBITRUM_ONE network \"\\n  ARBITRUM_ONE\\n  \" The ARWEAVE_MAINNET network \"\\n  ARWEAVE_MAINNET\\n  \" The AURORA network \"\\n  AURORA\\n  \" The AVALANCHE network \"\\n  AVALANCHE\\n  \" The BASE network \"\\n  BASE\\n  \" The BOBA network \"\\n  BOBA\\n  \" The BSC network \"\\n  BSC\\n  \" The CELO network \"\\n  CELO\\n  \" The COSMOS network \"\\n  COSMOS\\n  \" The CRONOS network \"\\n  CRONOS\\n  \" The MAINNET network \"\\n  MAINNET\\n  \" The FANTOM network \"\\n  FANTOM\\n  \" The FUSE network \"\\n  HARMONY\\n  \" The JUNO network \"\\n  JUNO\\n  \" The MOONBEAM network \"\\n  MOONBEAM\\n  \" The MOONRIVER network \"\\n  MOONRIVER\\n  \" The NEAR_MAINNET network \"\\n  NEAR_MAINNET\\n  \" The OPTIMISM network \"\\n  OPTIMISM\\n  \" The OSMOSIS network \"\\n  OSMOSIS\\n  \" The MATIC network \"\\n  MATIC\\n  \" The XDAI network \"\\n  XDAI\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema is an enumeration type named `Network`, which lists various blockchain networks. Each entry in the enum represents a specific network, and the description for each entry is simply the name of the network itself. The task is to ensure that each network name is documented as a description for its corresponding enum value, without altering the schema structure.',\n    documented_schema='\"Description for enum type: Network\"\\nenum Network {\\n  \"ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"ARWEAVE_MAINNET\"\\n  ARWEAVE_MAINNET\\n  \"AURORA\"\\n  AURORA\\n  \"AVALANCHE\"\\n  AVALANCHE\\n  \"BASE\"\\n  BASE\\n  \"BOBA\"\\n  BOBA\\n  \"BSC\"\\n  BSC\\n  \"CELO\"\\n  CELO\\n  \"COSMOS\"\\n  COSMOS\\n  \"CRONOS\"\\n  CRONOS\\n  \"MAINNET\"\\n  MAINNET\\n  \"FANTOM\"\\n  FANTOM\\n  \"HARMONY\"\\n  HARMONY\\n  \"JUNO\"\\n  JUNO\\n  \"MOONBEAM\"\\n  MOONBEAM\\n  \"MOONRIVER\"\\n  MOONRIVER\\n  \"NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"OPTIMISM\"\\n  OPTIMISM\\n  \"OSMOSIS\"\\n  OSMOSIS\\n  \"MATIC\"\\n  MATIC\\n  \"XDAI\"\\n  XDAI\\n}'\n)",
      4
    ],
    [
      "Example({'database_schema': '\"Description for table: ParameterUpdateEvent\"\\ntype ParameterUpdateEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: param\"\\n  param: String!\\n}', 'documented_schema': '\"\"\"\\nParameterUpdateEvent entities are created for every emitted ParameterUpdate event.\\n\"\"\"\\ntype ParameterUpdateEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  \"Parameter that was updated\"\\n  param: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `ParameterUpdateEvent` which implements an `Event` and is marked with the `@entity` directive, indicating it is an entity in the database. Each field within this type has a description that succinctly explains its purpose. The `id` field is a unique identifier of type `ID!`. The `transaction` field is a reference to a `Transaction` type, indicating a relationship. The `timestamp` field is an integer representing the time of the event. The `round` field is a reference to a `Round` type, suggesting another relationship. Lastly, the `param` field is a string that likely holds a parameter value related to the event.',\n    documented_schema='\"Description for table: ParameterUpdateEvent\"\\ntype ParameterUpdateEvent implements Event @entity {\\n  \"Unique identifier for the event\"\\n  id: ID!\\n  \"Associated transaction for the event\"\\n  transaction: Transaction!\\n  \"Time when the event occurred, represented as an integer\"\\n  timestamp: Int!\\n  \"Associated round for the event\"\\n  round: Round!\\n  \"Parameter value related to the event\"\\n  param: String!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: dailyVolumeUSD\"\\n  dailyVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: dailySupplySideRevenueUSD\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyProtocolSideRevenueUSD\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyTotalRevenueUSD\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}', 'documented_schema': 'type FinancialsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: ID!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" All trade volume occurred in a given day, in USD \"\\n  dailyVolumeUSD: BigDecimal!\\n  \" All historical trade volume in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `FinancialsDailySnapshot` with various fields, each representing a specific financial metric or identifier related to a decentralized exchange automated market maker (DexAmmProtocol). The task is to document each field with a concise and factual description based on the field names and types, without altering the schema structure.',\n    documented_schema='\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Unique identifier for the financial snapshot.\"\\n  id: ID!\\n  \"Reference to the decentralized exchange automated market maker protocol.\"\\n  protocol: DexAmmProtocol!\\n  \"Total value locked in USD at the time of the snapshot.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Value controlled by the protocol in USD.\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Volume of transactions in USD for the day.\"\\n  dailyVolumeUSD: BigDecimal!\\n  \"Cumulative volume of transactions in USD up to the snapshot.\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Revenue generated for liquidity providers in USD for the day.\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue generated for liquidity providers in USD up to the snapshot.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Revenue generated for the protocol in USD for the day.\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue generated for the protocol in USD up to the snapshot.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Total revenue generated in USD for the day.\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Cumulative total revenue generated in USD up to the snapshot.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Block number at the time of the snapshot.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of the snapshot.\"\\n  timestamp: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: PollTally\"\\ntype PollTally @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: yes\"\\n  yes: BigDecimal!\\n  \"Description for column: no\"\\n  no: BigDecimal!\\n}', 'documented_schema': '\"\"\"Stake weighted tally associated with a poll\"\"\"\\ntype PollTally @entity {\\n  \"Poll address\"\\n  id: ID!\\n  \"Stake voted yes\"\\n  yes: BigDecimal!\\n  \"Stake voted no\"\\n  no: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `PollTally`, with three fields: `id`, `yes`, and `no`. Each field is accompanied by a placeholder for a description. The task is to generate precise descriptions for these fields based on their names and types. The `id` field is typically a unique identifier, while `yes` and `no` are likely to represent tallies or counts of votes, given their type `BigDecimal`, which suggests they are numerical values.',\n    documented_schema='\"Description for table: PollTally\"\\ntype PollTally @entity {\\n  \"Unique identifier for the poll tally\"\\n  id: ID!\\n  \"Number of affirmative votes\"\\n  yes: BigDecimal!\\n  \"Number of negative votes\"\\n  no: BigDecimal!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: TranscoderDeactivatedEvent\"\\ntype TranscoderDeactivatedEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: delegate\"\\n  delegate: Transcoder!\\n  \"Description for column: deactivationRound\"\\n  deactivationRound: BigInt!\\n}', 'documented_schema': '\"\"\"\\nTranscoderDeactivatedEvent entities are created for every emitted TranscoderDeactivated event.\\n\"\"\"\\ntype TranscoderDeactivatedEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  \"Reference to the delegate that will become deactive\"\\n  delegate: Transcoder!\\n  \"Future round in which the delegate will become deactive\"\\n  deactivationRound: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `TranscoderDeactivatedEvent` which implements the `Event` interface. Each field within this type is associated with a specific data type and has a brief description. The task is to ensure that these descriptions are clear and concise, accurately reflecting the purpose of each field without altering the underlying schema structure.',\n    documented_schema='\"Description for table: TranscoderDeactivatedEvent\"\\ntype TranscoderDeactivatedEvent implements Event @entity {\\n  \"Unique identifier for the event\"\\n  id: ID!\\n  \"Associated transaction details\"\\n  transaction: Transaction!\\n  \"Time when the event occurred, represented as an integer\"\\n  timestamp: Int!\\n  \"Round during which the event took place\"\\n  round: Round!\\n  \"Transcoder that was delegated\"\\n  delegate: Transcoder!\\n  \"Round in which the transcoder was deactivated\"\\n  deactivationRound: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: AuthorisationChanged\"\\ntype AuthorisationChanged implements ResolverEvent @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: resolver\"\\n  resolver: Resolver!\\n  \"Description for column: blockNumber\"\\n  blockNumber: Int!\\n  \"Description for column: transactionID\"\\n  transactionID: Bytes!\\n  \"Description for column: owner\"\\n  owner: Bytes!\\n  \"Description for column: target\"\\n  target: Bytes!\\n  \"Description for column: isAuthorized\"\\n  isAuthorized: Boolean!\\n}', 'documented_schema': '\" A table of authorisation changed events. An authorisation changed event is an event that occurs when an authorisation is changed wihtin the resolver. This implements the ResolverEvent interface. \"\\ntype AuthorisationChanged implements ResolverEvent @entity {\\n  \" The unique identifier for the event. Type: ID! \"\\n  id: ID!\\n  \" The resolver associated with the event. References the Resolver entity that is associated with the event. Type: Resolver! \"\\n  resolver: Resolver!\\n  \" The block number at which the event occurred. Type: Int! \"\\n  blockNumber: Int!\\n  \" The transaction hash associated with the event. Type: Bytes! \"\\n  transactionID: Bytes!\\n  \" The owner of the authorisation. Type: Bytes! \"\\n  owner: Bytes!\\n  \" The target of the authorisation. Type: Bytes! \"\\n  target: Bytes!\\n  \" Whether the authorisation was added or removed. Type: Boolean! \"\\n  isAuthorized: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The task requires adding precise descriptions to each field in the GraphQL schema for the `AuthorisationChanged` type. The descriptions should be factual and based on the information provided in the schema. Each field in the schema represents a specific piece of data related to an authorization change event, and the descriptions should reflect their purpose and data type.',\n    documented_schema='\"Description for table: AuthorisationChanged\"\\ntype AuthorisationChanged implements ResolverEvent @entity {\\n  \"Unique identifier for the authorization change event\"\\n  id: ID!\\n  \"Reference to the resolver associated with the event\"\\n  resolver: Resolver!\\n  \"Block number in which the authorization change occurred\"\\n  blockNumber: Int!\\n  \"Transaction ID associated with the authorization change\"\\n  transactionID: Bytes!\\n  \"Address of the owner involved in the authorization change\"\\n  owner: Bytes!\\n  \"Address of the target involved in the authorization change\"\\n  target: Bytes!\\n  \"Indicates whether the target is authorized\"\\n  isAuthorized: Boolean!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: MulticoinAddrChanged\"\\ntype MulticoinAddrChanged implements ResolverEvent @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: resolver\"\\n  resolver: Resolver!\\n  \"Description for column: blockNumber\"\\n  blockNumber: Int!\\n  \"Description for column: transactionID\"\\n  transactionID: Bytes!\\n  \"Description for column: coinType\"\\n  coinType: BigInt!\\n  \"Description for column: addr\"\\n  addr: Bytes!\\n}', 'documented_schema': '\" A table of multicoin addr changed events. A multicoin addr changed event is an event that occurs when a resolver\\'s address is changed for a specific coin type. This implements the ResolverEvent interface. \"\\ntype MulticoinAddrChanged implements ResolverEvent @entity {\\n  \" The unique identifier for the event. Type: ID! \"\\n  id: ID!\\n  \" The resolver associated with the event. References the Resolver entity that is associated with the event. Type: Resolver! \"\\n  resolver: Resolver!\\n  \" The block number at which the event occurred. Type: Int! \"\\n  blockNumber: Int!\\n  \" The transaction ID for the transaction in which the event occurred. Type: Bytes! \"\\n  transactionID: Bytes!\\n  \" The coin type of the changed address. Type: BigInt! \"\\n  coinType: BigInt!\\n  \" The new address value for the given coin type. Type: Bytes! \"\\n  addr: Bytes!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The task requires adding precise descriptions to the columns of the table in the provided GraphQL schema. The schema is for a table named `MulticoinAddrChanged`, which implements the `ResolverEvent` interface. Each field in the schema is already accompanied by a placeholder for a description. The goal is to provide concise and factual descriptions for each field based on their names and types.',\n    documented_schema='\"Description for table: MulticoinAddrChanged\"\\ntype MulticoinAddrChanged implements ResolverEvent @entity {\\n  \"Unique identifier for the event\"\\n  id: ID!\\n  \"Reference to the resolver associated with the event\"\\n  resolver: Resolver!\\n  \"Block number in which the event was included\"\\n  blockNumber: Int!\\n  \"Identifier of the transaction that triggered the event\"\\n  transactionID: Bytes!\\n  \"Type of cryptocurrency associated with the address change\"\\n  coinType: BigInt!\\n  \"New address associated with the specified coin type\"\\n  addr: Bytes!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: token\"\\n  token: Token\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector!\\n  \"Description for column: bidder\"\\n  bidder: Collector!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: weiValue\"\\n  weiValue: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: lockedUntil\"\\n  lockedUntil: BigInt\\n  \"Description for column: isActive\"\\n  isActive: Boolean!\\n}', 'documented_schema': '\" A table of offers. Encapsulates all offers either on editions or tokens. \"\\ntype Offer @entity {\\n  \" The unique identifier for the offer. This is edition ID or token ID. Type: ID! \"\\n  id: ID!\\n  \" The version. This is the version of the KODA schema used to record the offer. Type: BigInt! \"\\n  version: BigInt!\\n  \" The type. This is the type of the offer, either Token or Edition. Type: String! \"\\n  type: String!\\n  \" The sales type. This is the current sales mechnic being used on this offer. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The token in the offer. This is a nullable token, as editions dont have tokens attached. Type: Token! \"\\n  token: Token\\n  \" The edition in the offer. All offers must be from an edition. Type: Edition! \"\\n  edition: Edition!\\n  \" The current owner of the offer, refering to the collection the offer is from. This is either the token holder or the edition artist. Type: Collector! \"\\n  currentOwner: Collector!\\n  \" The bidder. This is the address of account making the bid. This references the Collector entity. Type: Collector! \"\\n  bidder: Collector!\\n  \" The eth value of the offer. This is human readable eth value of the offer. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The wei value of the offer. This is the wei value, meaning the non-converted value of ETh, of the offer. Type: BigInt! \"\\n  weiValue: BigInt!\\n  \" The timestamp of the offer. This is the timestamp of the offer. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the offer. This is the transaction hash of the offer. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The locked until timestamp of the offer. For V3 offers, they will be locked for a certain amount of time. Type: BigInt! \"\\n  lockedUntil: BigInt\\n  \" The active flag of the offer. This is a boolean that indicates if the offer is active, as only active offers can be seen in the UI. Type: Boolean! \"\\n  isActive: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines an \"Offer\" entity with various fields, each having a specific data type and a brief description. The task is to ensure that each field is documented with a concise and factual description, maintaining the original schema structure and format. The descriptions should be clear and directly related to the field\\'s purpose or data type.',\n    documented_schema='\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Unique identifier for the offer\"\\n  id: ID!\\n  \"Version number of the offer\"\\n  version: BigInt!\\n  \"Type of the offer\"\\n  type: String!\\n  \"Sales type identifier\"\\n  salesType: BigInt!\\n  \"Associated token for the offer\"\\n  token: Token\\n  \"Edition associated with the offer\"\\n  edition: Edition!\\n  \"Current owner of the offer\"\\n  currentOwner: Collector!\\n  \"Bidder involved in the offer\"\\n  bidder: Collector!\\n  \"Value of the offer in Ethereum\"\\n  ethValue: BigDecimal!\\n  \"Value of the offer in Wei\"\\n  weiValue: BigInt!\\n  \"Timestamp of the offer creation\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction\"\\n  transactionHash: Bytes!\\n  \"Time until the offer is locked\"\\n  lockedUntil: BigInt\\n  \"Indicates if the offer is active\"\\n  isActive: Boolean!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Withdraw\"\\ntype Withdraw implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: YieldAggregator!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: asset\"\\n  asset: Token!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: vault\"\\n  vault: Vault!\\n}', 'documented_schema': 'type Withdraw implements Event @entity @transaction {\\n  \" { Transaction hash }-{ Log index }\"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: YieldAggregator!\\n  \" Address that received tokens \"\\n  to: String!\\n  \" Market that tokens are withdrawn from \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Token withdrawn \"\\n  asset: Token!\\n  \" Amount of token withdrawn in native units \"\\n  amount: BigInt!\\n  \" Amount of token withdrawn in USD \"\\n  amountUSD: BigDecimal!\\n  \" The vault involving this transaction \"\\n  vault: Vault!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `Withdraw` which implements the `Event` interface and includes several fields, each with a specific type and a brief description. The task is to ensure that each field is documented with a concise and factual description, focusing on the role and data type of each field within the `Withdraw` type. The descriptions should be clear and directly related to the field's purpose without altering the schema structure.\",\n    documented_schema='\"Description for table: Withdraw\"\\ntype Withdraw implements Event @entity @transaction {\\n  \"Unique identifier for the withdraw event\"\\n  id: ID!\\n  \"Transaction hash associated with the withdraw event\"\\n  hash: String!\\n  \"Index of the log entry in the transaction\"\\n  logIndex: Int!\\n  \"Protocol involved in the withdraw event\"\\n  protocol: YieldAggregator!\\n  \"Recipient address of the withdrawn assets\"\\n  to: String!\\n  \"Sender address of the withdrawn assets\"\\n  from: String!\\n  \"Block number when the withdraw event occurred\"\\n  blockNumber: BigInt!\\n  \"Timestamp of when the withdraw event occurred\"\\n  timestamp: BigInt!\\n  \"Token being withdrawn\"\\n  asset: Token!\\n  \"Amount of the asset withdrawn\"\\n  amount: BigInt!\\n  \"USD value of the withdrawn amount\"\\n  amountUSD: BigDecimal!\\n  \"Vault from which the assets are withdrawn\"\\n  vault: Vault!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: MarketplaceDailySnapshot\"\\ntype MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: marketplace\"\\n  marketplace: Marketplace!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: collectionCount\"\\n  collectionCount: Int!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: cumulativeUniqueTraders\"\\n  cumulativeUniqueTraders: Int!\\n  \"Description for column: dailyActiveTraders\"\\n  dailyActiveTraders: Int!\\n  \"Description for column: dailyTradedCollectionCount\"\\n  dailyTradedCollectionCount: Int!\\n  \"Description for column: dailyTradedItemCount\"\\n  dailyTradedItemCount: Int!\\n}', 'documented_schema': 'type MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \" { Contract address }-{# of days since Unix epoch time} \"\\n  id: ID!\\n  \" The marketplace that this snapshot belongs to. \"\\n  marketplace: Marketplace!\\n  \" Block number where the snapshot is taken. \"\\n  blockNumber: BigInt!\\n  \" Block timestamp when the snapshot is taken. \"\\n  timestamp: BigInt!\\n  \" Number of collections listed on the marketplace. \"\\n  collectionCount: Int!\\n  \" Cumulative trade volume (in ETH) \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" Revenue that goes to the marketplace protocol, aka protocol fee. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" Revenue that goes to creator, aka royalty fee. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" Sum of marketplaceRevenueETH and creatorRevenueETH. \"\\n  totalRevenueETH: BigDecimal!\\n  \" Trade count of the all collections on the marketplace. \"\\n  tradeCount: Int!\\n  \" Cumulative unique traders \"\\n  cumulativeUniqueTraders: Int!\\n  \" Daily active traders \"\\n  dailyActiveTraders: Int!\\n  \" Number of traded collections of the day \"\\n  dailyTradedCollectionCount: Int!\\n  \" Number of traded items of the day \"\\n  dailyTradedItemCount: Int!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The task requires adding precise descriptions to each column in the `MarketplaceDailySnapshot` table based on the provided GraphQL schema. The descriptions should be concise and factual, reflecting the purpose or nature of each column without altering the schema structure. The descriptions should be formatted correctly to fit within the GraphQL documentation style.',\n    documented_schema='\"Description for table: MarketplaceDailySnapshot\"\\ntype MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \"Unique identifier for the snapshot\"\\n  id: ID!\\n  \"Reference to the associated marketplace\"\\n  marketplace: Marketplace!\\n  \"Block number at the time of the snapshot\"\\n  blockNumber: BigInt!\\n  \"Timestamp of the snapshot\"\\n  timestamp: BigInt!\\n  \"Number of collections at the time of the snapshot\"\\n  collectionCount: Int!\\n  \"Total trade volume in ETH up to the snapshot\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Revenue generated by the marketplace in ETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Revenue generated by creators in ETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Total revenue in ETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Number of trades executed\"\\n  tradeCount: Int!\\n  \"Total number of unique traders up to the snapshot\"\\n  cumulativeUniqueTraders: Int!\\n  \"Number of active traders on the day of the snapshot\"\\n  dailyActiveTraders: Int!\\n  \"Number of collections traded on the day of the snapshot\"\\n  dailyTradedCollectionCount: Int!\\n  \"Number of items traded on the day of the snapshot\"\\n  dailyTradedItemCount: Int!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: ArtistMintingConfig\"\\ntype ArtistMintingConfig @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: mints\"\\n  mints: BigInt!\\n  \"Description for column: firstMintInPeriod\"\\n  firstMintInPeriod: BigInt!\\n  \"Description for column: frequencyOverride\"\\n  frequencyOverride: Boolean!\\n}', 'documented_schema': '\" A table of artist minting configurations. \"\\ntype ArtistMintingConfig @entity {\\n  \" The unique identifier for the artist minting configuration. \"\\n  id: ID!\\n  \" The total number of mints. \"\\n  mints: BigInt!\\n  \" The first mint in the period. \"\\n  firstMintInPeriod: BigInt!\\n  \" Whether the user can mint as much as possible. \"\\n  frequencyOverride: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `ArtistMintingConfig`, with four fields. Each field is already accompanied by a brief description. The task is to ensure that these descriptions are clear and concise, focusing on the specific role of each field within the entity. The descriptions should be factual and directly related to the schema without adding any speculative information.',\n    documented_schema='\"Description for table: ArtistMintingConfig\"\\ntype ArtistMintingConfig @entity {\\n  \"Unique identifier for the artist minting configuration\"\\n  id: ID!\\n  \"Total number of mints associated with the artist\"\\n  mints: BigInt!\\n  \"Timestamp of the first mint within a specified period\"\\n  firstMintInPeriod: BigInt!\\n  \"Indicates if the minting frequency is overridden\"\\n  frequencyOverride: Boolean!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: TokenEvent\"\\ntype TokenEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: buyer\"\\n  buyer: Collector\\n  \"Description for column: bidder\"\\n  bidder: Collector\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: TransferEvent\"\\ntype TransferEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: from\"\\n  from: Bytes!\\n  \"Description for column: to\"\\n  to: Bytes!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: AuctionEvent\"\\ntype AuctionEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: bidder\"\\n  bidder: Bytes!\\n  \"Description for column: caller\"\\n  caller: Bytes!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: lockupUntil\"\\n  lockupUntil: BigInt\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: ActivityEvent\"\\ntype ActivityEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: eventType\"\\n  eventType: String!\\n  \"Description for column: edition\"\\n  edition: Edition\\n  \"Description for column: token\"\\n  token: Token\\n  \"Description for column: creator\"\\n  creator: Bytes!\\n  \"Description for column: creatorCommission\"\\n  creatorCommission: BigInt\\n  \"Description for column: collaborator\"\\n  collaborator: Bytes\\n  \"Description for column: collaboratorCommission\"\\n  collaboratorCommission: BigInt\\n  \"Description for column: triggeredBy\"\\n  triggeredBy: Bytes\\n  \"Description for column: buyer\"\\n  buyer: Bytes\\n  \"Description for column: seller\"\\n  seller: Bytes\\n  \"Description for column: stakeholderAddresses\"\\n  stakeholderAddresses: [Bytes!]!\\n  \"Description for column: contractAddress\"\\n  contractAddress: Bytes\\n  \"Description for column: eventValueInWei\"\\n  eventValueInWei: BigInt\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: _Schema_\"\\ntype _Schema_ @fulltext(name: \"listedTokenSearch\", language: en, algorithm: rank, include: [{entity: \"ListedToken\", fields: [{name: \"metadataName\"}, {name: \"metadataArtist\"}, {name: \"metadataArtistAccount\"}, {name: \"metadataTagString\"}, {name: \"primaryAssetShortType\"}, {name: \"primaryAssetActualType\"}]}]) @fulltext(name: \"editionSearch\", language: en, algorithm: rank, include: [{entity: \"Edition\", fields: [{name: \"metadataName\"}, {name: \"metadataArtist\"}, {name: \"metadataArtistAccount\"}, {name: \"metadataTagString\"}, {name: \"metadataFormat\"}, {name: \"metadataTheme\"}, {name: \"primaryAssetShortType\"}, {name: \"primaryAssetActualType\"}]}])\\n\\n\"Description for table: Day\"\\ntype Day @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: date\"\\n  date: String!\\n  \"Description for column: transferCount\"\\n  transferCount: BigInt!\\n  \"Description for column: editionsCount\"\\n  editionsCount: BigInt!\\n  \"Description for column: bidsAcceptedCount\"\\n  bidsAcceptedCount: BigInt!\\n  \"Description for column: bidsPlacedCount\"\\n  bidsPlacedCount: BigInt!\\n  \"Description for column: bidsRejectedCount\"\\n  bidsRejectedCount: BigInt!\\n  \"Description for column: bidsWithdrawnCount\"\\n  bidsWithdrawnCount: BigInt!\\n  \"Description for column: bidsIncreasedCount\"\\n  bidsIncreasedCount: BigInt!\\n  \"Description for column: totalValuePlaceInBids\"\\n  totalValuePlaceInBids: BigDecimal!\\n  \"Description for column: totalValueCycledInBids\"\\n  totalValueCycledInBids: BigDecimal!\\n  \"Description for column: secondarySalesValue\"\\n  secondarySalesValue: BigDecimal!\\n  \"Description for column: issuedCount\"\\n  issuedCount: BigInt!\\n  \"Description for column: salesCount\"\\n  salesCount: BigInt!\\n  \"Description for column: totalValueInEth\"\\n  totalValueInEth: BigDecimal!\\n  \"Description for column: highestValueInEth\"\\n  highestValueInEth: BigDecimal!\\n  \"Description for column: highestValueToken\"\\n  highestValueToken: Token\\n  \"Description for column: issued\"\\n  issued: [Token!]!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n}\\n\\n\"Description for table: PlatformConfig\"\\ntype PlatformConfig @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: royaltiesRegistry\"\\n  royaltiesRegistry: Bytes\\n  \"Description for column: tokenUriResolver\"\\n  tokenUriResolver: Bytes\\n  \"Description for column: modulo\"\\n  modulo: BigInt\\n  \"Description for column: primarySaleCommission\"\\n  primarySaleCommission: BigInt\\n  \"Description for column: secondarySaleRoyalty\"\\n  secondarySaleRoyalty: BigInt\\n  \"Description for column: marketplaceSecondarySaleRoyalty\"\\n  marketplaceSecondarySaleRoyalty: BigInt\\n  \"Description for column: minBidAmount\"\\n  minBidAmount: BigInt\\n  \"Description for column: mintingPeriod\"\\n  mintingPeriod: BigInt\\n  \"Description for column: maxMintsInPeriod\"\\n  maxMintsInPeriod: BigInt\\n  \"Description for column: merkleProofRoot\"\\n  merkleProofRoot: Bytes\\n  \"Description for column: merkleProofIpfsHash\"\\n  merkleProofIpfsHash: String\\n}\\n\\n\"Description for table: Token\"\\ntype Token @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: transferCount\"\\n  transferCount: BigInt!\\n  \"Description for column: editionNumber\"\\n  editionNumber: String!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: tokenURI\"\\n  tokenURI: String!\\n  \"Description for column: metadata\"\\n  metadata: MetaData\\n  \"Description for column: birthTimestamp\"\\n  birthTimestamp: BigInt!\\n  \"Description for column: primaryValueInEth\"\\n  primaryValueInEth: BigDecimal!\\n  \"Description for column: totalPurchaseValue\"\\n  totalPurchaseValue: BigDecimal!\\n  \"Description for column: totalPurchaseCount\"\\n  totalPurchaseCount: BigInt!\\n  \"Description for column: largestSecondaryValueInEth\"\\n  largestSecondaryValueInEth: BigDecimal!\\n  \"Description for column: largestSalePriceEth\"\\n  largestSalePriceEth: BigDecimal!\\n  \"Description for column: lastSalePriceInEth\"\\n  lastSalePriceInEth: BigDecimal!\\n  \"Description for column: lastTransferTimestamp\"\\n  lastTransferTimestamp: BigInt!\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector\\n  \"Description for column: allOwners\"\\n  allOwners: [Collector!]!\\n  \"Description for column: transfers\"\\n  transfers: [TransferEvent!]!\\n  \"Description for column: tokenEvents\"\\n  tokenEvents: [TokenEvent!]!\\n  \"Description for column: openOffer\"\\n  openOffer: TokenOffer\\n  \"Description for column: currentTopBidder\"\\n  currentTopBidder: Bytes\\n  \"Description for column: artistAccount\"\\n  artistAccount: Bytes!\\n  \"Description for column: editionActive\"\\n  editionActive: Boolean!\\n  \"Description for column: revokedApproval\"\\n  revokedApproval: Boolean!\\n  \"Description for column: isListed\"\\n  isListed: Boolean!\\n  \"Description for column: listPrice\"\\n  listPrice: BigDecimal\\n  \"Description for column: lister\"\\n  lister: Collector\\n  \"Description for column: listingTimestamp\"\\n  listingTimestamp: BigInt\\n  \"Description for column: listing\"\\n  listing: ListedToken\\n  \"Description for column: creatorContract\"\\n  creatorContract: CreatorContract\\n}\\n\\n\"Description for table: ListedToken\"\\ntype ListedToken @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: editionNumber\"\\n  editionNumber: String!\\n  \"Description for column: revokedApproval\"\\n  revokedApproval: Boolean!\\n  \"Description for column: listPrice\"\\n  listPrice: BigDecimal!\\n  \"Description for column: lister\"\\n  lister: Collector!\\n  \"Description for column: listingTimestamp\"\\n  listingTimestamp: BigInt!\\n  \"Description for column: seriesNumber\"\\n  seriesNumber: BigInt\\n  \"Description for column: isFirstEdition\"\\n  isFirstEdition: Boolean\\n  \"Description for column: isLastEdition\"\\n  isLastEdition: Boolean\\n  \"Description for column: isGenesisEdition\"\\n  isGenesisEdition: Boolean\\n  \"Description for column: metadataName\"\\n  metadataName: String!\\n  \"Description for column: metadataArtist\"\\n  metadataArtist: String!\\n  \"Description for column: metadataArtistAccount\"\\n  metadataArtistAccount: String!\\n  \"Description for column: metadataTagString\"\\n  metadataTagString: String!\\n  \"Description for column: primaryAssetShortType\"\\n  primaryAssetShortType: String!\\n  \"Description for column: primaryAssetActualType\"\\n  primaryAssetActualType: String!\\n  \"Description for column: fullToken\"\\n  fullToken: Token!\\n  \"Description for column: reserveAuctionSeller\"\\n  reserveAuctionSeller: Bytes!\\n  \"Description for column: reserveAuctionBidder\"\\n  reserveAuctionBidder: Bytes!\\n  \"Description for column: reservePrice\"\\n  reservePrice: BigInt!\\n  \"Description for column: reserveAuctionBid\"\\n  reserveAuctionBid: BigInt!\\n  \"Description for column: reserveAuctionStartDate\"\\n  reserveAuctionStartDate: BigInt!\\n  \"Description for column: previousReserveAuctionEndTimestamp\"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionEndTimestamp\"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionNumTimesExtended\"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \"Description for column: isReserveAuctionInSuddenDeath\"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \"Description for column: reserveAuctionTotalExtensionLengthInSeconds\"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \"Description for column: isReserveAuctionResulted\"\\n  isReserveAuctionResulted: Boolean!\\n  \"Description for column: isReserveAuctionResultedDateTime\"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \"Description for column: reserveAuctionResulter\"\\n  reserveAuctionResulter: Bytes!\\n  \"Description for column: reserveAuctionCanEmergencyExit\"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \"Description for column: creatorContract\"\\n  creatorContract: CreatorContract\\n}\\n\\n\"Description for table: Composable\"\\ntype Composable @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: items\"\\n  items: [ComposableItem!]\\n}\\n\\n\"Description for table: ComposableItem\"\\ntype ComposableItem @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: address\"\\n  address: String!\\n  \"Description for column: tokenID\"\\n  tokenID: String!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: value\"\\n  value: BigInt!\\n}\\n\\n\"Description for table: CollectiveHandlers\"\\ntype CollectiveHandlers @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: active\"\\n  active: Boolean!\\n  \"Description for column: lastUpdatedTimestamp\"\\n  lastUpdatedTimestamp: BigInt!\\n  \"Description for column: lastUpdatedTransactionHash\"\\n  lastUpdatedTransactionHash: Bytes!\\n}\\n\\n\"Description for table: Collective\"\\ntype Collective @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: baseHandler\"\\n  baseHandler: Bytes!\\n  \"Description for column: creator\"\\n  creator: Bytes!\\n  \"Description for column: recipients\"\\n  recipients: [Bytes!]!\\n  \"Description for column: splits\"\\n  splits: [BigInt!]!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n  \"Description for column: isDeployed\"\\n  isDeployed: Boolean!\\n}\\n\\n\"Description for table: Edition\"\\ntype Edition @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: editionNmber\"\\n  editionNmber: String!\\n  \"Description for column: editionType\"\\n  editionType: BigInt!\\n  \"Description for column: editionData\"\\n  editionData: Bytes\\n  \"Description for column: creatorContract\"\\n  creatorContract: CreatorContract\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: revokedApproval\"\\n  revokedApproval: Boolean!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: tokenIds\"\\n  tokenIds: [String!]!\\n  \"Description for column: tokens\"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \"Description for column: tokenURI\"\\n  tokenURI: String!\\n  \"Description for column: artistAccount\"\\n  artistAccount: Bytes!\\n  \"Description for column: artistCommission\"\\n  artistCommission: BigInt!\\n  \"Description for column: optionalCommissionAccount\"\\n  optionalCommissionAccount: Bytes\\n  \"Description for column: optionalCommissionRate\"\\n  optionalCommissionRate: BigInt\\n  \"Description for column: collaborators\"\\n  collaborators: [Bytes!]!\\n  \"Description for column: collective\"\\n  collective: Collective\\n  \"Description for column: offersOnly\"\\n  offersOnly: Boolean!\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt!\\n  \"Description for column: totalAvailable\"\\n  totalAvailable: BigInt!\\n  \"Description for column: remainingSupply\"\\n  remainingSupply: BigInt!\\n  \"Description for column: totalSold\"\\n  totalSold: BigInt!\\n  \"Description for column: totalBurnt\"\\n  totalBurnt: BigInt!\\n  \"Description for column: originalEditionSize\"\\n  originalEditionSize: BigInt!\\n  \"Description for column: secondaryRoyaltyV4EditionOverride\"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \"Description for column: sales\"\\n  sales: [Token!]!\\n  \"Description for column: totalEthSpentOnEdition\"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \"Description for column: active\"\\n  active: Boolean!\\n  \"Description for column: metadata\"\\n  metadata: MetaData\\n  \"Description for column: isGenesisEdition\"\\n  isGenesisEdition: Boolean!\\n  \"Description for column: isEnhancedEdition\"\\n  isEnhancedEdition: Boolean!\\n  \"Description for column: isOpenEdition\"\\n  isOpenEdition: Boolean\\n  \"Description for column: hasCoverImage\"\\n  hasCoverImage: Boolean!\\n  \"Description for column: artist\"\\n  artist: Artist\\n  \"Description for column: startDate\"\\n  startDate: BigInt!\\n  \"Description for column: endDate\"\\n  endDate: BigInt!\\n  \"Description for column: reserveAuctionSeller\"\\n  reserveAuctionSeller: Bytes!\\n  \"Description for column: reserveAuctionBidder\"\\n  reserveAuctionBidder: Bytes!\\n  \"Description for column: reservePrice\"\\n  reservePrice: BigInt!\\n  \"Description for column: reserveAuctionBid\"\\n  reserveAuctionBid: BigInt!\\n  \"Description for column: reserveAuctionStartDate\"\\n  reserveAuctionStartDate: BigInt!\\n  \"Description for column: previousReserveAuctionEndTimestamp\"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionEndTimestamp\"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionNumTimesExtended\"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \"Description for column: isReserveAuctionInSuddenDeath\"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \"Description for column: reserveAuctionTotalExtensionLengthInSeconds\"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \"Description for column: isReserveAuctionResulted\"\\n  isReserveAuctionResulted: Boolean!\\n  \"Description for column: isReserveAuctionResultedDateTime\"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \"Description for column: reserveAuctionResulter\"\\n  reserveAuctionResulter: Bytes!\\n  \"Description for column: reserveAuctionCanEmergencyExit\"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \"Description for column: priceInWei\"\\n  priceInWei: BigInt!\\n  \"Description for column: stepSaleBasePrice\"\\n  stepSaleBasePrice: BigInt!\\n  \"Description for column: stepSaleStepPrice\"\\n  stepSaleStepPrice: BigInt!\\n  \"Description for column: currentStep\"\\n  currentStep: BigInt!\\n  \"Description for column: auctionEnabled\"\\n  auctionEnabled: Boolean!\\n  \"Description for column: activeBid\"\\n  activeBid: AuctionEvent\\n  \"Description for column: gatedSale\"\\n  gatedSale: GatedSale\\n  \"Description for column: biddingHistory\"\\n  biddingHistory: [AuctionEvent!]!\\n  \"Description for column: transfers\"\\n  transfers: [TransferEvent!]!\\n  \"Description for column: allOwners\"\\n  allOwners: [Collector!]!\\n  \"Description for column: currentOwners\"\\n  currentOwners: [Collector!]!\\n  \"Description for column: primaryOwners\"\\n  primaryOwners: [Collector!]!\\n  \"Description for column: metadataName\"\\n  metadataName: String!\\n  \"Description for column: metadataArtist\"\\n  metadataArtist: String!\\n  \"Description for column: metadataTagString\"\\n  metadataTagString: String!\\n  \"Description for column: metadataArtistAccount\"\\n  metadataArtistAccount: String!\\n  \"Description for column: metadataPrice\"\\n  metadataPrice: BigInt!\\n  \"Description for column: metadataFormat\"\\n  metadataFormat: String\\n  \"Description for column: metadataTheme\"\\n  metadataTheme: String\\n  \"Description for column: primaryAssetShortType\"\\n  primaryAssetShortType: String\\n  \"Description for column: primaryAssetActualType\"\\n  primaryAssetActualType: String\\n}\\n\\n\"Description for table: MetaData\"\\ntype MetaData @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: description\"\\n  description: String\\n  \"Description for column: image\"\\n  image: String\\n  \"Description for column: image_type\"\\n  image_type: String\\n  \"Description for column: image_size_in_bytes\"\\n  image_size_in_bytes: BigInt\\n  \"Description for column: cover_image\"\\n  cover_image: String\\n  \"Description for column: cover_image_type\"\\n  cover_image_type: String\\n  \"Description for column: cover_image_size_in_bytes\"\\n  cover_image_size_in_bytes: BigInt\\n  \"Description for column: animation_url\"\\n  animation_url: String\\n  \"Description for column: image_sphere\"\\n  image_sphere: Boolean\\n  \"Description for column: scarcity\"\\n  scarcity: String\\n  \"Description for column: artist\"\\n  artist: String\\n  \"Description for column: tags\"\\n  tags: [String!]\\n  \"Description for column: production_year\"\\n  production_year: String\\n  \"Description for column: format\"\\n  format: String\\n  \"Description for column: theme\"\\n  theme: String\\n  \"Description for column: nsfw\"\\n  nsfw: Boolean\\n}\\n\\n\"Description for table: TokenOffer\"\\ntype TokenOffer @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: ownerAtTimeOfBid\"\\n  ownerAtTimeOfBid: Collector!\\n  \"Description for column: bidder\"\\n  bidder: Collector!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: token\"\\n  token: Token\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector!\\n  \"Description for column: bidder\"\\n  bidder: Collector!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: weiValue\"\\n  weiValue: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: lockedUntil\"\\n  lockedUntil: BigInt\\n  \"Description for column: isActive\"\\n  isActive: Boolean!\\n}\\n\\n\"Description for table: PhaseMintCount\"\\ntype PhaseMintCount @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: saleId\"\\n  saleId: String!\\n  \"Description for column: editionId\"\\n  editionId: String!\\n  \"Description for column: phaseId\"\\n  phaseId: String!\\n  \"Description for column: minter\"\\n  minter: String!\\n  \"Description for column: count\"\\n  count: BigInt!\\n}\\n\\n\"Description for table: Phase\"\\ntype Phase @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: saleId\"\\n  saleId: String!\\n  \"Description for column: editionId\"\\n  editionId: String!\\n  \"Description for column: phaseId\"\\n  phaseId: String!\\n  \"Description for column: startTime\"\\n  startTime: BigInt!\\n  \"Description for column: endTime\"\\n  endTime: BigInt!\\n  \"Description for column: walletMintLimit\"\\n  walletMintLimit: BigInt!\\n  \"Description for column: priceInWei\"\\n  priceInWei: BigInt!\\n  \"Description for column: mintCap\"\\n  mintCap: BigInt!\\n  \"Description for column: mintCount\"\\n  mintCount: BigInt!\\n  \"Description for column: merkleRoot\"\\n  merkleRoot: Bytes\\n  \"Description for column: merkleIPFSHash\"\\n  merkleIPFSHash: String\\n}\\n\\n\"Description for table: GatedSale\"\\ntype GatedSale @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: editionId\"\\n  editionId: String!\\n  \"Description for column: paused\"\\n  paused: Boolean!\\n  \"Description for column: primarySaleCommission\"\\n  primarySaleCommission: BigInt!\\n  \"Description for column: artistAccount\"\\n  artistAccount: String\\n  \"Description for column: mintCount\"\\n  mintCount: BigInt!\\n  \"Description for column: phases\"\\n  phases: [Phase!]!\\n}\\n\\n\"Description for table: CreatorContract\"\\ntype CreatorContract @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: implementation\"\\n  implementation: Bytes!\\n  \"Description for column: deployer\"\\n  deployer: Bytes!\\n  \"Description for column: creator\"\\n  creator: Bytes!\\n  \"Description for column: paused\"\\n  paused: Boolean!\\n  \"Description for column: owner\"\\n  owner: Bytes!\\n  \"Description for column: secondaryRoyaltyPercentage\"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \"Description for column: minter\"\\n  minter: Bytes!\\n  \"Description for column: defaultFundsHandler\"\\n  defaultFundsHandler: Bytes!\\n  \"Description for column: defaultFundsRecipients\"\\n  defaultFundsRecipients: [Bytes!]!\\n  \"Description for column: defaultFundsShares\"\\n  defaultFundsShares: [BigInt!]!\\n  \"Description for column: ERC165InterfaceID\"\\n  ERC165InterfaceID: Bytes\\n  \"Description for column: isBatchBuyItNow\"\\n  isBatchBuyItNow: Boolean!\\n  \"Description for column: isHidden\"\\n  isHidden: Boolean!\\n  \"Description for column: transferState\"\\n  transferState: BigInt!\\n  \"Description for column: totalNumOfEditions\"\\n  totalNumOfEditions: BigInt!\\n  \"Description for column: totalNumOfTokensSold\"\\n  totalNumOfTokensSold: BigInt!\\n  \"Description for column: totalEthValueOfSales\"\\n  totalEthValueOfSales: BigDecimal!\\n  \"Description for column: totalNumOfTransfers\"\\n  totalNumOfTransfers: BigInt!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: filterRegistry\"\\n  filterRegistry: Bytes\\n}\\n\\n\"Description for table: CreatorContractSetting\"\\ntype CreatorContractSetting @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: factoryContract\"\\n  factoryContract: Bytes!\\n  \"Description for column: kodaSalesSettingsContract\"\\n  kodaSalesSettingsContract: Bytes!\\n  \"Description for column: platform\"\\n  platform: Bytes!\\n  \"Description for column: platformPrimaryCommission\"\\n  platformPrimaryCommission: BigInt!\\n  \"Description for column: platformSecondaryCommission\"\\n  platformSecondaryCommission: BigInt!\\n  \"Description for column: MODULO\"\\n  MODULO: BigInt!\\n}\\n\\n\"Description for table: ArtistMintingConfig\"\\ntype ArtistMintingConfig @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: mints\"\\n  mints: BigInt!\\n  \"Description for column: firstMintInPeriod\"\\n  firstMintInPeriod: BigInt!\\n  \"Description for column: frequencyOverride\"\\n  frequencyOverride: Boolean!\\n}\\n\\n\"Description for table: Artist\"\\ntype Artist @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: address\"\\n  address: Bytes!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: editionsCount\"\\n  editionsCount: BigInt!\\n  \"Description for column: ccEditionsCount\"\\n  ccEditionsCount: BigInt!\\n  \"Description for column: supply\"\\n  supply: BigInt!\\n  \"Description for column: issuedCount\"\\n  issuedCount: BigInt!\\n  \"Description for column: totalValueInEth\"\\n  totalValueInEth: BigDecimal!\\n  \"Description for column: salesCount\"\\n  salesCount: BigInt!\\n  \"Description for column: totalPrimarySales\"\\n  totalPrimarySales: BigInt!\\n  \"Description for column: totalPrimarySalesInEth\"\\n  totalPrimarySalesInEth: BigDecimal!\\n  \"Description for column: totalSecondarySales\"\\n  totalSecondarySales: BigInt!\\n  \"Description for column: totalSecondarySalesInEth\"\\n  totalSecondarySalesInEth: BigDecimal!\\n  \"Description for column: highestSaleValueInEth\"\\n  highestSaleValueInEth: BigDecimal!\\n  \"Description for column: highestSaleToken\"\\n  highestSaleToken: Token\\n  \"Description for column: firstEdition\"\\n  firstEdition: Edition\\n  \"Description for column: firstEditionTimestamp\"\\n  firstEditionTimestamp: BigInt!\\n  \"Description for column: lastEdition\"\\n  lastEdition: Edition\\n  \"Description for column: lastEditionTimestamp\"\\n  lastEditionTimestamp: BigInt!\\n  \"Description for column: editions\"\\n  editions: [Edition!]! @derivedFrom(field: \"artist\")\\n  \"Description for column: editionIds\"\\n  editionIds: [Edition!]!\\n  \"Description for column: mintingConfig\"\\n  mintingConfig: ArtistMintingConfig!\\n  \"Description for column: creatorContracts\"\\n  creatorContracts: [CreatorContract!]\\n}\\n\\n\"Description for table: Collector\"\\ntype Collector @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: address\"\\n  address: Bytes!\\n  \"Description for column: firstSeen\"\\n  firstSeen: BigInt!\\n  \"Description for column: firstPurchaseTimeStamp\"\\n  firstPurchaseTimeStamp: BigInt!\\n  \"Description for column: lastPurchaseTimeStamp\"\\n  lastPurchaseTimeStamp: BigInt!\\n  \"Description for column: primaryPurchaseCount\"\\n  primaryPurchaseCount: BigInt!\\n  \"Description for column: primaryPurchaseEthSpent\"\\n  primaryPurchaseEthSpent: BigDecimal!\\n  \"Description for column: secondarySaleCount\"\\n  secondarySaleCount: BigInt!\\n  \"Description for column: secondarySaleEthTotal\"\\n  secondarySaleEthTotal: BigDecimal!\\n  \"Description for column: secondaryPurchaseCount\"\\n  secondaryPurchaseCount: BigInt!\\n  \"Description for column: secondaryPurchaseEthSpent\"\\n  secondaryPurchaseEthSpent: BigDecimal!\\n  \"Description for column: totalPurchaseCount\"\\n  totalPurchaseCount: BigInt!\\n  \"Description for column: totalPurchaseEthSpent\"\\n  totalPurchaseEthSpent: BigDecimal!\\n  \"Description for column: tokens\"\\n  tokens: [Token!]! @derivedFrom(field: \"currentOwner\")\\n  \"Description for column: tokenIds\"\\n  tokenIds: [Token!]!\\n}', 'documented_schema': '\" TokenEvent is a table for recording events related to tokens \"\\ntype TokenEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the event. Type: BigInt! \"\\n  version: BigInt!\\n  \" The name of the event. Type: String! \"\\n  name: String!\\n  \" The token associated with the event. References the Token entity. Type: Token! \"\\n  token: Token!\\n  \" The edition associated with the event. References the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The buyer associated with the event. References the Collector entity. Type: Collector \"\\n  buyer: Collector\\n  \" The bidder associated with the event. References the Collector entity. Type: Collector \"\\n  bidder: Collector\\n  \" The current owner associated with the event. References the Collector entity. Type: Collector \"\\n  currentOwner: Collector\\n  \" The value of the event in ETH. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. Type: BigInt! \"\\n  blockNumber: BigInt!\\n}\\n\\n\" TransferEvent is a table for recording events related to transfers of tokens \"\\ntype TransferEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the event. Type: BigInt! \"\\n  version: BigInt!\\n  \" The from address of the transfer. The address of the account that initiated the transfer. Type: Bytes! \"\\n  from: Bytes!\\n  \" The to address of the transfer. The address of the account that received the transfer. Type: Bytes! \"\\n  to: Bytes!\\n  \" The token ID of the transfer. The ID of the token being transferred. Type: BigInt! \"\\n  tokenId: BigInt!\\n  \" The edition associated with the transfer. References the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. \"\\n  blockNumber: BigInt!\\n}\\n\\n\" AuctionEvent is a table for recording events related to primary sale auctions \"\\ntype AuctionEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the event. Type: BigInt! \"\\n  version: BigInt!\\n  \" The edition associated with the auction. References the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The name of the auction. Type: String! \"\\n  name: String!\\n  \" The bidder associated with the auction. This is the address of the person who placed the bid. Type: Bytes! \"\\n  bidder: Bytes!\\n  \" The caller associated with the auction. This is the address of the person who called the auction. Type: Bytes! \"\\n  caller: Bytes!\\n  \" The value of the auction in ETH. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The lockupUntil timestamp of the auction. When set the bidder who set this is locked out. Type: BigInt! \"\\n  lockupUntil: BigInt\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. Type: BigInt! \"\\n  blockNumber: BigInt!\\n}\\n\\n\" ActivityEvent is a table for recording events related to various types of activities \"\\ntype ActivityEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The type of the event. Is either Token, Edition or Creator Contract. Type: String! \"\\n  type: String!\\n  \" The version of the KODA schema used to record the event. KODA 2 or 3. Type: BigInt! \"\\n  version: BigInt!\\n  \" The type of the event. e.g. [\\'EditionCreated\\', \\'Purchase\\', \\'BidPlaced\\', \\'BidAccepted\\', \\'BidIncreased\\', \\'BidRejected\\', \\'BidWithdrawn\\']. Type: String! \"\\n  eventType: String!\\n  \" The edition associated with the event. References the Edition entity. All events relate to an edition unless it\\'s v3. Type: Edition! \"\\n  edition: Edition\\n  \" The token associated with the event. References the Token entity. Type: Token! \"\\n  token: Token\\n  \" The creator associated with the event. This is the address of the person who created the edition. Type: Bytes! \"\\n  creator: Bytes!\\n  \" The creator\\'s commission rate. This is the percentage of the sale price that the creator receives, only valid if the event has a value. Type: BigInt! \"\\n  creatorCommission: BigInt\\n  \" The collaborator associated with the event. This is the address of the person who collaborated on the edition. Type: Bytes! \"\\n  collaborator: Bytes\\n  \" The collaborator\\'s commission rate. This is the percentage of the sale price that the collaborator receives, only valid if the event has a value. Type: BigInt! \"\\n  collaboratorCommission: BigInt\\n  \" The buyer associated with the event. This is the account that triggered the transaction. Type: Bytes! \"\\n  triggeredBy: Bytes\\n  \" The buyer associated with the event. This is the account that serves as the buyer. Type: Bytes! \"\\n  buyer: Bytes\\n  \" The seller associated with the event. This is the account that serves as the seller. Type: Bytes! \"\\n  seller: Bytes\\n  \" The stakeholder addresses associated with the event. This is the list of accounts that interacted during the event. Type: [Bytes!]! \"\\n  stakeholderAddresses: [Bytes!]!\\n  \" The contract address associated with the event. This is the address of the contract that recorded the event. Type: Bytes! \"\\n  contractAddress: Bytes\\n  \" The value of the event in WEI. Type: BigInt! \"\\n  eventValueInWei: BigInt\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. Type: BigInt! \"\\n  blockNumber: BigInt!\\n}\\n\\ntype _Schema_ @fulltext(name: \"listedTokenSearch\", language: en, algorithm: rank, include: [{entity: \"ListedToken\", fields: [{name: \"metadataName\"}, {name: \"metadataArtist\"}, {name: \"metadataArtistAccount\"}, {name: \"metadataTagString\"}, {name: \"primaryAssetShortType\"}, {name: \"primaryAssetActualType\"}]}]) @fulltext(name: \"editionSearch\", language: en, algorithm: rank, include: [{entity: \"Edition\", fields: [{name: \"metadataName\"}, {name: \"metadataArtist\"}, {name: \"metadataArtistAccount\"}, {name: \"metadataTagString\"}, {name: \"metadataFormat\"}, {name: \"metadataTheme\"}, {name: \"primaryAssetShortType\"}, {name: \"primaryAssetActualType\"}]}])\\n\\n\" Day is a table for recording rolled up counts for a given day \"\\ntype Day @entity {\\n  \" The unique identifier for the day. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The date of the day. Type: String! \"\\n  date: String!\\n  \" The total number of transfers made in the day. Type: BigInt! \"\\n  transferCount: BigInt!\\n  \" The total number of editions created in the day. Type: BigInt! \"\\n  editionsCount: BigInt!\\n  \" The total number of bids accepted in the day. Type: BigInt! \"\\n  bidsAcceptedCount: BigInt!\\n  \" The total number of bids placed in the day. Type: BigInt! \"\\n  bidsPlacedCount: BigInt!\\n  \" The total number of bids rejected in the day. Type: BigInt! \"\\n  bidsRejectedCount: BigInt!\\n  \" The total number of bids withdrawn in the day. Type: BigInt! \"\\n  bidsWithdrawnCount: BigInt!\\n  \" The total number of bids increased in the day. This is when the value of the bid is increased. Type: BigInt! \"\\n  bidsIncreasedCount: BigInt!\\n  \" The total value of bids placed in the day. This is the total value of all bids placed in the day. Type: BigDecimal! \"\\n  totalValuePlaceInBids: BigDecimal!\\n  \" The total value of bids cycled in the day. This is the total value of all bids cycled in the day. Type: BigDecimal! \"\\n  totalValueCycledInBids: BigDecimal!\\n  \" The total value of secondary sales in the day. This is recorded in ETH. Type: BigDecimal! \"\\n  secondarySalesValue: BigDecimal!\\n  \" The total number of sales in the day. Type: BigInt! \"\\n  issuedCount: BigInt!\\n  \" The total number of sales in the day. Type: BigInt! \"\\n  salesCount: BigInt!\\n  \" The total value of sales in the day. This is recorded in ETH. Type: BigDecimal! \"\\n  totalValueInEth: BigDecimal!\\n  \" The highest value of a sale in the day. This is recorded in ETH. Type: BigDecimal! \"\\n  highestValueInEth: BigDecimal!\\n  \" The highest value token of a sale in the day. This is recorded in ETH. Type: BigDecimal! \"\\n  highestValueToken: Token\\n  \" The list of tokens issued in the day. Derived from the Token entity. Type: [Token!]! \"\\n  issued: [Token!]!\\n  \" The list of editions issued in the day. Derived from the Edition entity. Type: [Edition!]! \"\\n  editions: [Edition!]!\\n}\\n\\n\" PlatformConfig is a table for recording the platform configuration \"\\ntype PlatformConfig @entity {\\n  \" The unique identifier for the platform configuration. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The address of the royalties registry. This references an address. Type: Bytes! \"\\n  royaltiesRegistry: Bytes\\n  \" The address of the token URI resolver. This references an address. Type: Bytes! \"\\n  tokenUriResolver: Bytes\\n  \" The modulo value for the platform. This is a number. Type: BigInt! \"\\n  modulo: BigInt\\n  \" The primary sale commission rate. This is a percentage. Type: BigInt! \"\\n  primarySaleCommission: BigInt\\n  \" The secondary sale royalty rate. This is a percentage. Type: BigInt! \"\\n  secondarySaleRoyalty: BigInt\\n  \" The marketplace secondary sale royalty rate. This is a percentage. Type: BigInt! \"\\n  marketplaceSecondarySaleRoyalty: BigInt\\n  \" The minimum bid amount. This is a number. Type: BigInt! \"\\n  minBidAmount: BigInt\\n  \" The minting period. This is a number that represents the period that minting is allowed during. Type: BigInt! \"\\n  mintingPeriod: BigInt\\n  \" The maximum number of mints in a period. This is a number that represents the maximum number of mints that can be made during the minting period. Type: BigInt! \"\\n  maxMintsInPeriod: BigInt\\n  \" The merkle proof root. This is a hash of the merkle tree. Type: Bytes! \"\\n  merkleProofRoot: Bytes\\n  \" The merkle proof IPFS hash. This is a hash of the merkle tree. Type: String! \"\\n  merkleProofIpfsHash: String\\n}\\n\\n\" Token is a table for recording the details of a token \"\\ntype Token @entity {\\n  \" The unique identifier for the token. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the token. KODA 2, 3 or 4. Type: BigInt! \"\\n  version: BigInt!\\n  \" The current sales mechanic being used on this edition. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The token ID. This is a number. Type: BigInt! \"\\n  tokenId: BigInt!\\n  \" The total number of transfers made for this token. Type: BigInt! \"\\n  transferCount: BigInt!\\n  \" The edition number. This is a composite ID made from the edition ID and the optional contract address for the creator contract. Type: String! \"\\n  editionNumber: String!\\n  \" The edition associated with the token. This references the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The token URI. This is a string. Type: String! \"\\n  tokenURI: String!\\n  \" The metadata associated with the token. This references the MetaData entity. Type: MetaData! \"\\n  metadata: MetaData\\n  \" The birth timestamp. This is a number that represents the timestamp of the first transfer of the token from the zero address. Type: BigInt! \"\\n  birthTimestamp: BigInt!\\n  \" The primary value in ETH when the token was sold from an edition on KO. Type: BigDecimal! \"\\n  primaryValueInEth: BigDecimal!\\n  \" The total purchase value in ETH. This is the total value of all purchases (primary & secondary). Type: BigDecimal! \"\\n  totalPurchaseValue: BigDecimal!\\n  \" The total purchase count. This is the total number of purchases (primary & secondary). Type: BigInt! \"\\n  totalPurchaseCount: BigInt!\\n  \" The largest secondary sale in ETH. This is the largest secondary sale in ETH. Type: BigDecimal! \"\\n  largestSecondaryValueInEth: BigDecimal!\\n  \" The largest sale price in ETH. This is set to the highest sale price for the token, primary or secondary. Type: BigDecimal! \"\\n  largestSalePriceEth: BigDecimal!\\n  \" The last sale price in ETH. This is the last sale price for the token, primary or secondary. Type: BigDecimal! \"\\n  lastSalePriceInEth: BigDecimal!\\n  \" The last transfer timestamp. This is the timestamp of the last transfer of the token. Type: BigInt! \"\\n  lastTransferTimestamp: BigInt!\\n  \" The current owner of the token. This also has a derived field linking to this from Collector.tokens. Type: Collector! \"\\n  currentOwner: Collector\\n  \" The list of all owners of the token. This is a list of all unique owners of the token. Type: [Collector!]! \"\\n  allOwners: [Collector!]!\\n  \" The list of all transfers made for the token. Type: [TransferEvent!]! \"\\n  transfers: [TransferEvent!]!\\n  \" The list of all token events such as secondary sales and transfers. Type: [TokenEvent!]! \"\\n  tokenEvents: [TokenEvent!]!\\n  \" The current top active offer on a token. Type: TokenOffer! \"\\n  openOffer: TokenOffer\\n  \" The current active top bidder on the secondary market for this token. The current active top bidder is the top bidder on the secondary market for this token. Type: Bytes! \"\\n  currentTopBidder: Bytes\\n  \" The artist account associated with the token. This references the artist account. Type: Bytes! \"\\n  artistAccount: Bytes!\\n  \" The edition active flag. This is a boolean that indicates if the edition is active. Type: Boolean! \"\\n  editionActive: Boolean!\\n  \" The revoked approval flag. This is a boolean that indicates if the seller has revoked approved the marketplace. Type: Boolean! \"\\n  revokedApproval: Boolean!\\n  \" The listed flag. This is a boolean that indicates if the token is listed. Type: Boolean! \"\\n  isListed: Boolean!\\n  \" The list price. This is a number. Type: BigDecimal! \"\\n  listPrice: BigDecimal\\n  \" The lister. This references the Collector entity. Type: Collector! \"\\n  lister: Collector\\n  \" The listing timestamp. This is a number that represents the timestamp of the listing. Type: BigInt! \"\\n  listingTimestamp: BigInt\\n  \" The complete attached token. This references the ListedToken entity. Type: ListedToken! \"\\n  listing: ListedToken\\n  \" The creator contract. This references the CreatorContract entity. Optionally capture creator contract address if it is version 4. Type: CreatorContract! \"\\n  creatorContract: CreatorContract\\n}\\n\\n\" ListedToken is a table for recording the details of a token listed on the secondary market. Only applicable for KODA V2/3. \"\\ntype ListedToken @entity {\\n  \" The unique identifier for the listed token. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the token. KODA 2 or 3. Type: BigInt! \"\\n  version: BigInt!\\n  \" The edition number for the listed token. Type: String! \"\\n  editionNumber: String!\\n  \" The revoked approval flag. This is a boolean that indicates if the seller has revoked approved the marketplace. Type: Boolean! \"\\n  revokedApproval: Boolean!\\n  \" The list price. This is a number representing the price the token was listed at. Type: BigDecimal! \"\\n  listPrice: BigDecimal!\\n  \" The lister. This references the Collector entity. Type: Collector! \"\\n  lister: Collector!\\n  \" The listing timestamp. This is a number that represents the timestamp of the listing. Type: BigInt! \"\\n  listingTimestamp: BigInt!\\n  \" The series number for the token. This is similar to the edition number in a series (i.e. edition no. in the series i.e. #10 from the an edition of 10). Type: BigInt! \"\\n  seriesNumber: BigInt\\n  \" The first edition flag. This is a boolean that indicates if the token is the first edition. Type: Boolean! \"\\n  isFirstEdition: Boolean\\n  \" The last edition flag. This is a boolean that indicates if the token is the last edition. Type: Boolean! \"\\n  isLastEdition: Boolean\\n  \" The genesis edition flag. This is a boolean that indicates if the token is the genesis edition. The genesis edition is the first edition of an artist. Type: Boolean! \"\\n  isGenesisEdition: Boolean\\n  \" The name of the token, flattened from the metadata. Type: String! \"\\n  metadataName: String!\\n  \" The artist of the token, flattened from the metadata. Type: String! \"\\n  metadataArtist: String!\\n  \" The artist account of the token, flattened from the metadata. Type: String! \"\\n  metadataArtistAccount: String!\\n  \" The tag string of the token, flattened from the metadata. Type: String! \"\\n  metadataTagString: String!\\n  \" The primary asset short type of the token, flattened from the metadata. Type: String! \"\\n  primaryAssetShortType: String!\\n  \" The primary asset actual type of the token, flattened from the metadata. Type: String! \"\\n  primaryAssetActualType: String!\\n  \" The complete attached token. This references the Token entity. Type: Token! \"\\n  fullToken: Token!\\n  \" The reserve auction seller. This references the edition seller. Type: Bytes! \"\\n  reserveAuctionSeller: Bytes!\\n  \" The reserve auction bidder. This references the current bidder. Type: Bytes! \"\\n  reserveAuctionBidder: Bytes!\\n  \" The reserve price. This is a number, listed for the reserve auction. Type: BigInt! \"\\n  reservePrice: BigInt!\\n  \" The current bid. This is a number, the current bid for the auction. Type: BigInt! \"\\n  reserveAuctionBid: BigInt!\\n  \" The auction start timestamp. This is a number, the timestamp of the auction start time. Type: BigInt! \"\\n  reserveAuctionStartDate: BigInt!\\n  \" The previous reserve auction end timestamp. This is a number, set to the same as reserve unless an extension is in flight. Type: BigInt! \"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction end timestamp. This is a number, the timestamp of the auction end time. Type: BigInt! \"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \" The number of times the auction has been extended. This is a number, the number of times the auction has been extended. Type: BigInt! \"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \" The sudden death flag. This is a boolean that indicates if the auction is in sudden death. Type: Boolean! \"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \" The total extension length in seconds. This is a number, the total length of the extension. Type: BigInt! \"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \" The reserve auction resulted flag. This is a boolean that indicates if the auction has resulted. Type: Boolean! \"\\n  isReserveAuctionResulted: Boolean!\\n  \" The reserve auction resulted timestamp. This is a number, the timestamp of the auction result. Type: BigInt! \"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \" The reserve auction resulter. This references the bytes of the auction resulter. Type: Bytes! \"\\n  reserveAuctionResulter: Bytes!\\n  \" The reserve auction can emergency exit flag. This is a boolean that indicates if the auction can emergency exit. Type: Boolean! \"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \" The creator contract. This references the CreatorContract entity. Optionally capture creator contract address if this is version 4. Type: CreatorContract! \"\\n  creatorContract: CreatorContract\\n}\\n\\n\" Composable is a table for recording the details of a composable item. A composable is a combination of a V3 NFT and a set number of tokens. \"\\ntype Composable @entity {\\n  \" The unique identifier for the composable. This is the address of the composable. Type: ID! \"\\n  id: ID!\\n  \" The list of composable items. This is an array of composable items. Type: [ComposableItem!]! \"\\n  items: [ComposableItem!]\\n}\\n\\n\" A table of composable items. A composable item is one token attached to a composable. \"\\ntype ComposableItem @entity {\\n  \" The unique identifier for the composable item. This is the ID made up of combined tokenID/composing contract/composing IDs. Type: ID! \"\\n  id: ID!\\n  \" The address of the ERC20/ERC721 token. Type: String! \"\\n  address: String!\\n  \" The token ID. This can be thought of as the token ticker. Type: String! \"\\n  tokenID: String!\\n  \" The type of token. This is the technical spec of the token, such as ERC20, ERC721 etc. Type: String! \"\\n  type: String!\\n  \" The value of the token. This is the number of tokens attached or the ERC721 token ID. Type: BigInt! \"\\n  value: BigInt!\\n}\\n\\n\" A table of approved collective handlers. A collective handler is a contract which is cloned and used to handle the collective. \"\\ntype CollectiveHandlers @entity {\\n  \" The unique identifier for the collective handler. This is the base address of the collective handler. Type: ID! \"\\n  id: ID!\\n  \" The active flag. This is a boolean that indicates if the collective handler is active. Type: Boolean! \"\\n  active: Boolean!\\n  \" The last updated timestamp. This is a number, the timestamp of the last update to the collective handler. Type: BigInt! \"\\n  lastUpdatedTimestamp: BigInt!\\n  \" The last updated transaction hash. This is the transaction hash of the last update to the collective handler. Type: Bytes! \"\\n  lastUpdatedTransactionHash: Bytes!\\n}\\n\\n\" A table of collective contracts. \"\\ntype Collective @entity {\\n  \" The unique identifier for the collective. This is the deployed address of the collective. Type: ID! \"\\n  id: ID!\\n  \" The base handler. This is the clone which this is based on. Type: Bytes! \"\\n  baseHandler: Bytes!\\n  \" The creator. This is the address of the creator who deployed the collective. Type: Bytes! \"\\n  creator: Bytes!\\n  \" The recipients. This is an array of addresses who are recipients for the deployed collab. Type: [Bytes!]! \"\\n  recipients: [Bytes!]!\\n  \" The splits. This is an array of numbers who are splits for the deployed collab. Type: [BigInt!]! \"\\n  splits: [BigInt!]!\\n  \" The created timestamp. This is a number, the timestamp of the creation of the collective. Type: BigInt! \"\\n  createdTimestamp: BigInt!\\n  \" The transaction hash. This is the transaction hash of the creation of the collective. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The editions. This is an array of editions assigned to the collective. Type: [Edition!]! \"\\n  editions: [Edition!]!\\n  \" The deployed flag. This is a boolean that indicates if the collective is deployed. Type: Boolean! \"\\n  isDeployed: Boolean!\\n}\\n\\n\" A table of editions. An edition is a collection of tokens. \"\\ntype Edition @entity {\\n  \" The unique identifier for the edition. This is the composite ID made up of the edition ID and the optional contract address for the creator contract. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the edition. KODA 2, 3 or 4. Type: BigInt! \"\\n  version: BigInt!\\n  \" The edition number. This is the edition number. This is not a composite key. Type: String! \"\\n  editionNmber: String!\\n  \" The edition type. This is a legacy field from KODA V2. Type: BigInt! \"\\n  editionType: BigInt!\\n  \" The edition data. This is a legacy field from KODA V2 which contains some additional data about the edition. Type: Bytes! \"\\n  editionData: Bytes\\n  \" The creator contract. This references the CreatorContract entity. Type: CreatorContract! \"\\n  creatorContract: CreatorContract\\n  \" The sales type. This is the current sales mechanic being used on this edition. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The revoked approval flag. This is a boolean that indicates if the seller has revoked approved the marketplace, which is set to true once if the seller has revoked approved the marketplace. Type: Boolean! \"\\n  revokedApproval: Boolean!\\n  \" The created timestamp. This is a number, the timestamp of the creation of the edition. Type: BigInt! \"\\n  createdTimestamp: BigInt!\\n  \" The token IDs. This is an array of token IDs. Type: [String!]! \"\\n  tokenIds: [String!]!\\n  \" The tokens. This is an array of tokens. Type: [Token!]! \"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \" The token URI. This is a string, the URI of the token. Type: String! \"\\n  tokenURI: String!\\n  \" The artist account. This is the address of the artist for the edition. Type: Bytes! \"\\n  artistAccount: Bytes!\\n  \" The artist commission. This is the base artists commission. Type: BigInt! \"\\n  artistCommission: BigInt!\\n  \" The optional commission account. This is the address of the optional commission account. NOTE: deprecated - V2 only - use collaborators for this. Type: Bytes! \"\\n  optionalCommissionAccount: Bytes\\n  \" The optional commission rate. This is the rate of the optional commission. Type: BigInt! \"\\n  optionalCommissionRate: BigInt\\n  \" The collaborators. This is an array of addresses who have collaborated on this edition. Type: [Bytes!]! \"\\n  collaborators: [Bytes!]!\\n  \" The collective. This references the Collective entity. NOTE: nullable V3 collective i.e. its split funds. Type: Collective! \"\\n  collective: Collective\\n  \" The offers only flag. This is a boolean that indicates if the edition is only for offers. Type: Boolean! \"\\n  offersOnly: Boolean!\\n  \" The total supply. This is the total purchases or mints i.e. total number of primary transfers. Type: BigInt! \"\\n  totalSupply: BigInt!\\n  \" The total available. This is the total number available to be purchased i.e. edition size. Type: BigInt! \"\\n  totalAvailable: BigInt!\\n  \" The remaining supply. This is the total remaining i.e. number of primary sale tokens left to buy from this edition. Type: BigInt! \"\\n  remainingSupply: BigInt!\\n  \" The total sold. This is the total number sold i.e. number of primary sale tokens sold. sold = purchase/bid accepted with price > 0. Type: BigInt! \"\\n  totalSold: BigInt!\\n  \" The total burnt. This is the total number burnt i.e. number of primary sale tokens burnt. burnt = send to 0xDead or 0x0 (only applicable for V3). Type: BigInt! \"\\n  totalBurnt: BigInt!\\n  \" The original edition size. This is the original edition size of the edition at mint - this field should NEVER change once set. Type: BigInt! \"\\n  originalEditionSize: BigInt!\\n  \" The secondary royalty V4 edition override. This is the EIP2981 percentage requested by the creator(s) at the edition level. Type: BigInt! \"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \" The sales. This is an array of tokens that have been sold from this edition. Type: [Token!]! \"\\n  sales: [Token!]!\\n  \" The total eth spent on the edition. This is the total amount of ETH spent on the edition. Type: BigDecimal! \"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \" The active flag. This is a boolean that indicates if the edition is active. Type: Boolean! \"\\n  active: Boolean!\\n  \" The metadata. This references the MetaData entity. Type: MetaData! \"\\n  metadata: MetaData\\n  \" The isGenesisEdition flag. This is a boolean that indicates if the edition is the first edition. This is set true if edition is an artists first edition. Type: Boolean! \"\\n  isGenesisEdition: Boolean!\\n  \" The isEnhancedEdition flag. This is a boolean that indicates if the edition is an enhanced edition. This is set true if any of the tokens are enhanced i.e. composed. Type: Boolean! \"\\n  isEnhancedEdition: Boolean!\\n  \" The isOpenEdition flag. This is a boolean that indicates if the edition is an open edition. This is applicable to version 4 and editions where the artist does not mint all of the tokens up front. Type: Boolean! \"\\n  isOpenEdition: Boolean\\n  \" The hasCoverImage flag. This is a boolean that indicates if the edition has a cover image. Type: Boolean! \"\\n  hasCoverImage: Boolean!\\n  \" The artist. This references the Artist entity, and reference the primary minter. Type: Artist! \"\\n  artist: Artist\\n  \" The start date. This is a number, the timestamp of the start date of the edition. Type: BigInt! \"\\n  startDate: BigInt!\\n  \" The end date. The date when the edition is available until (only applicable for V2). Type: BigInt! \"\\n  endDate: BigInt!\\n  \" The reserve auction seller. This is the address of the edition seller. Type: Bytes! \"\\n  reserveAuctionSeller: Bytes!\\n  \" The reserve auction bidder. This is the address of the current bidder. Type: Bytes! \"\\n  reserveAuctionBidder: Bytes!\\n  \" The reserve price. This is the listed reserve price. Type: BigInt! \"\\n  reservePrice: BigInt!\\n  \" The reserve auction bid. This is the current bid. Type: BigInt! \"\\n  reserveAuctionBid: BigInt!\\n  \" The reserve auction start date. This is the timestamp of the auction start. Type: BigInt! \"\\n  reserveAuctionStartDate: BigInt!\\n  \" The previous reserve auction end timestamp. This is set to the same as reserve unless an extension is in flight. Type: BigInt! \"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction end timestamp. This is the timestamp of the auction end. Type: BigInt! \"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction number of times extended. This is the number of times the auction has been extended. Type: BigInt! \"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \" The reserve auction in sudden death flag. This is a boolean that indicates if the auction is in sudden death. Type: Boolean! \"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \" The reserve auction total extension length in seconds. This is the total length of the extension. Type: BigInt! \"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \" The reserve auction resulted flag. This is a boolean that indicates if the auction has resulted. Type: Boolean! \"\\n  isReserveAuctionResulted: Boolean!\\n  \" The reserve auction resulted timestamp. This is the timestamp of the auction result. Type: BigInt! \"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \" The reserve auction resulter. This is the address of the auction resulter. Type: Bytes! \"\\n  reserveAuctionResulter: Bytes!\\n  \" The reserve auction can emergency exit flag. This is a boolean that indicates if the auction can emergency exit. Type: Boolean! \"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \" The price in wei. This is the buy now price / current step price. Type: BigInt! \"\\n  priceInWei: BigInt!\\n  \" The step sale base price. This is the base price of the step sale. Type: BigInt! \"\\n  stepSaleBasePrice: BigInt!\\n  \" The step sale step price. This is the step price of the step sale. Type: BigInt! \"\\n  stepSaleStepPrice: BigInt!\\n  \" The current step. This is the current step of the step sale. Type: BigInt! \"\\n  currentStep: BigInt!\\n  \" The auction enabled flag. This is a boolean that indicates if the auction is enabled. Type: Boolean! \"\\n  auctionEnabled: Boolean!\\n  \" The active bid. This references the AuctionEvent entity. Type: AuctionEvent! \"\\n  activeBid: AuctionEvent\\n  \" The gated sale. This references the GatedSale entity. Represents if the edition is gated, which means the edition is only available to a certain set of users. Type: GatedSale! \"\\n  gatedSale: GatedSale\\n  \" The bidding history. This is an array of AuctionEvent entities. Type: [AuctionEvent!]! \"\\n  biddingHistory: [AuctionEvent!]!\\n  \" The transfers. The total number of token transfers made for all tokens from the edition. Type: [TransferEvent!]! \"\\n  transfers: [TransferEvent!]!\\n  \" The all owners. The list (set) of all unique owners for all tokens. Type: [Collector!]! \"\\n  allOwners: [Collector!]!\\n  \" The current owners. The current set of owners for this edition. Type: [Collector!]! \"\\n  currentOwners: [Collector!]!\\n  \" The primary owners. The owner is set when sold in primary sale. Type: [Collector!]! \"\\n  primaryOwners: [Collector!]!\\n  \" The metadata name. This is the name of the edition. Type: String! \"\\n  metadataName: String!\\n  \" The metadata artist. This is the artist of the edition. Type: String! \"\\n  metadataArtist: String!\\n  \" The metadata tag string. This is the tags of the edition. Type: String! \"\\n  metadataTagString: String!\\n  \" The metadata artist account. This is the artist account of the edition. Type: String! \"\\n  metadataArtistAccount: String!\\n  \" The metadata price. A consolidated price for all sale types, making it orderable in lists. Type: BigInt! \"\\n  metadataPrice: BigInt!\\n  \" The metadata format. This is the format of the edition (null-able as V3 only). Type: String! \"\\n  metadataFormat: String\\n  \" The metadata theme. This is the theme of the edition (null-able as V3 only). Type: String! \"\\n  metadataTheme: String\\n  \" The primary asset short type. This is the short type of the primary asset (null-able leading mime-type field i.e. image or video etc). Type: String! \"\\n  primaryAssetShortType: String\\n  \" The primary asset actual type. This is the actual type of the primary asset (null-able ending mime-type field e.g. mp4, gif, png etc). Type: String! \"\\n  primaryAssetActualType: String\\n}\\n\\n\" A table of metadata. A token/editions and its meta data. \"\\ntype MetaData @entity(immutable: true) {\\n  \" The unique identifier for the metadata. This is the ID of the metadata. Type: ID! \"\\n  id: ID!\\n  \" The name. This is the name of the metadata. Type: String! \"\\n  name: String\\n  \" The description. This is the description of the metadata. Type: String! \"\\n  description: String\\n  \" The image for the metadata. This is the image of the metadata. Type: String! \"\\n  image: String\\n  \" The image type. This is the type of the image (only added july-2020). Type: String! \"\\n  image_type: String\\n  \" The image size in bytes. Type: BigInt! \"\\n  image_size_in_bytes: BigInt\\n  \" The cover image that is used for the metadata (optional - only added july-2020). Type: String! \"\\n  cover_image: String\\n  \" The cover image type. This is the type of the cover image (only added july-2020). Type: String! \"\\n  cover_image_type: String\\n  \" The cover image size in bytes. This is the size of the cover image in bytes (only added july-2020). Type: BigInt! \"\\n  cover_image_size_in_bytes: BigInt\\n  \" The animation URL. This is the URL of the animation. Type: String! \"\\n  animation_url: String\\n  \" The image sphere flag (optional - only added Jan-21). Type: Boolean! \"\\n  image_sphere: Boolean\\n  \" The scarcity. This is the scarcity of the metadata. Type: String! \"\\n  scarcity: String\\n  \" The artist. This is the artist of the metadata. Type: String! \"\\n  artist: String\\n  \" The tags. This is an array of tags for the metadata. Type: [String!]! \"\\n  tags: [String!]\\n  \" The production year. This is the production year of the metadata. Type: String! \"\\n  production_year: String\\n  \" The format. This is the format of the metadata. Type: String! \"\\n  format: String\\n  \" The theme. This is the theme of the metadata. Type: String! \"\\n  theme: String\\n  \" The nsfw flag. This is a boolean that indicates if the metadata is nsfw. Type: Boolean! \"\\n  nsfw: Boolean\\n}\\n\\n\" A table of token offers. A single high level entity capturing the top offer on the secondary marketplace. \"\\ntype TokenOffer @entity(immutable: true) {\\n  \" The unique identifier for the token offer. This is the ID of the token offer. Type: ID! \"\\n  id: ID!\\n  \" The version. This is the version of the KODA schema used to record the token offer. Type: BigInt! \"\\n  version: BigInt!\\n  \" The token. This references the Token entity. Type: Token! \"\\n  token: Token!\\n  \" The edition of the token offer. This references the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The owner at time of bid. When the token is offered for sale, this is the owner of said token. This references the Collector entity. Type: Collector! \"\\n  ownerAtTimeOfBid: Collector!\\n  \" The bidder. This references the Collector entity. Type: Collector! \"\\n  bidder: Collector!\\n  \" The eth value. This is the eth value of the token offer. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The timestamp. This is the timestamp of the token offer. Type: BigInt! \"\\n  timestamp: BigInt!\\n}\\n\\n\" A table of offers. Encapsulates all offers either on editions or tokens. \"\\ntype Offer @entity {\\n  \" The unique identifier for the offer. This is edition ID or token ID. Type: ID! \"\\n  id: ID!\\n  \" The version. This is the version of the KODA schema used to record the offer. Type: BigInt! \"\\n  version: BigInt!\\n  \" The type. This is the type of the offer, either Token or Edition. Type: String! \"\\n  type: String!\\n  \" The sales type. This is the current sales mechnic being used on this offer. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The token in the offer. This is a nullable token, as editions dont have tokens attached. Type: Token! \"\\n  token: Token\\n  \" The edition in the offer. All offers must be from an edition. Type: Edition! \"\\n  edition: Edition!\\n  \" The current owner of the offer, refering to the collection the offer is from. This is either the token holder or the edition artist. Type: Collector! \"\\n  currentOwner: Collector!\\n  \" The bidder. This is the address of account making the bid. This references the Collector entity. Type: Collector! \"\\n  bidder: Collector!\\n  \" The eth value of the offer. This is human readable eth value of the offer. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The wei value of the offer. This is the wei value, meaning the non-converted value of ETh, of the offer. Type: BigInt! \"\\n  weiValue: BigInt!\\n  \" The timestamp of the offer. This is the timestamp of the offer. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the offer. This is the transaction hash of the offer. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The locked until timestamp of the offer. For V3 offers, they will be locked for a certain amount of time. Type: BigInt! \"\\n  lockedUntil: BigInt\\n  \" The active flag of the offer. This is a boolean that indicates if the offer is active, as only active offers can be seen in the UI. Type: Boolean! \"\\n  isActive: Boolean!\\n}\\n\\n\" A table of phase mint counts. Store the total mints per user, per sale & phase. \"\\ntype PhaseMintCount @entity {\\n  \" The unique identifier for the phase mint count. This is a composite key (sale, edition, phase, minter) - unique per user and sale/phase. Type: ID! \"\\n  id: ID!\\n  \" The sale. This is the sale this phase relates to. Type: String! \"\\n  saleId: String!\\n  \" The edition. This is the edition this phase relates to. Type: String! \"\\n  editionId: String!\\n  \" The phase. This is the actual phase number. Type: String! \"\\n  phaseId: String!\\n  \" The minter. This is the minter who is creating the tokens. Type: String! \"\\n  minter: String!\\n  \" The count. This is the total number of tokens minted by the minter in this phase. Type: BigInt! \"\\n  count: BigInt!\\n}\\n\\n\" A table of phase. A gate sale phase configuration. \"\\ntype Phase @entity {\\n  \" The unique identifier for the phase. Type: ID! \"\\n  id: ID!\\n  \" The sale. This is the sale this phase relates to. Type: String! \"\\n  saleId: String!\\n  \" The edition. This is the edition this phase relates to. Type: String! \"\\n  editionId: String!\\n  \" The phase. This is the actual phase number. Type: String! \"\\n  phaseId: String!\\n  \" The start time of the sale as a whole. Type: BigInt! \"\\n  startTime: BigInt!\\n  \" The end time of the sale phase, also the beginning of the next phase if applicable. Type: BigInt! \"\\n  endTime: BigInt!\\n  \" The mint limit per wallet for the phase. Type: BigInt! \"\\n  walletMintLimit: BigInt!\\n  \" The price in wei for one mint. Type: BigInt! \"\\n  priceInWei: BigInt!\\n  \" The maximum amount of mints for the phase. Type: BigInt! \"\\n  mintCap: BigInt!\\n  \" The current amount of items minted in this phase. Type: BigInt! \"\\n  mintCount: BigInt!\\n  \" The merkle tree root for the phase. Type: Bytes! \"\\n  merkleRoot: Bytes\\n  \" The IPFS hash referencing the merkle tree. Type: String! \"\\n  merkleIPFSHash: String\\n}\\n\\n\" A table of gated sale. A gate sale configuration - one per edition. \"\\ntype GatedSale @entity {\\n  \" The unique identifier for the gated sale. This is the ID of the gated sale. Type: ID! \"\\n  id: ID!\\n  \" The edition. This is the edition the sale will mint. Type: String! \"\\n  editionId: String!\\n  \" The paused flag. This is a boolean that indicates if the sale is currently paused. Type: Boolean! \"\\n  paused: Boolean!\\n  \" The primary sale commission. This is the overridden sales commission for KO. Type: BigInt! \"\\n  primarySaleCommission: BigInt!\\n  \" The artist account. This is the address of the artist associated with the given edition ID. Type: String! \"\\n  artistAccount: String\\n  \" The mint count. This is the total mint current for the sale. Type: BigInt! \"\\n  mintCount: BigInt!\\n  \" The phases. This is an array of phases associated with the sale. Type: [Phase!]! \"\\n  phases: [Phase!]!\\n}\\n\\n\" A table of creator contracts. Any KODA V4 Contract Deployed from the V4 factory. \"\\ntype CreatorContract @entity {\\n  \" The unique identifier for the creator contract. This is the ID of the creator contract. Type: ID! \"\\n  id: ID!\\n  \" The block number. This is the block number of the deployment. Type: BigInt! \"\\n  blockNumber: BigInt!\\n  \" The timestamp. This is the timestamp of the deployment. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash. This is the transaction hash of the deployment. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index. This is the transaction index of the deployment. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index. This is the log index of the deployment. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The event address. This is the address of the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The event tx from. This is the address of the transaction from. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The event tx to. This is the address of the transaction to. Type: Bytes! \"\\n  eventTxTo: Bytes\\n  \" The implementation. This is the address of the contract cloned during the deployment of the creator contract. Type: Bytes! \"\\n  implementation: Bytes!\\n  \" The deployer. The deployer may be different to creator in the case that platform deployed a contract. Type: Bytes! \"\\n  deployer: Bytes!\\n  \" The creator. This is the address of the creator of the contract. Type: Bytes! \"\\n  creator: Bytes!\\n  \" The paused flag. This is a boolean that indicates if the contract is currently paused. Type: Boolean! \"\\n  paused: Boolean!\\n  \" The owner. This is the address of the owner of the contract. Type: Bytes! \"\\n  owner: Bytes!\\n  \" The secondary royalty percentage. This is across all editions the currently specified secondary royalty EIP2981. Type: BigInt! \"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \" The minter. This is the address of the minter of the contract. Type: Bytes! \"\\n  minter: Bytes!\\n  \" The default funds handler. This is the address of the default funds handler. Type: Bytes! \"\\n  defaultFundsHandler: Bytes!\\n  \" The default funds recipients. This is an array of addresses of the default funds recipients. Type: [Bytes!]! \"\\n  defaultFundsRecipients: [Bytes!]!\\n  \" The default funds shares. This is an array of BigInts of the default funds shares. Type: [BigInt!]! \"\\n  defaultFundsShares: [BigInt!]!\\n  \" The ERC165 interface ID. This is the interface ID of the contract. Type: Bytes! \"\\n  ERC165InterfaceID: Bytes\\n  \" The batch buy it now flag. This is a boolean that indicates if the contract supports batch buy it now. Type: Boolean! \"\\n  isBatchBuyItNow: Boolean!\\n  \" The banned flag. This is a boolean that indicates if the contract is banned. Type: Boolean! \"\\n  isHidden: Boolean!\\n  \" The transfer state. This is the state of the transfer. Type: BigInt! \"\\n  transferState: BigInt!\\n  \" The total number of editions. This is the total number of editions from a given creator contract. Type: BigInt! \"\\n  totalNumOfEditions: BigInt!\\n  \" The total number of tokens sold. This is the total number of tokens sold from a given creator contract. Type: BigInt! \"\\n  totalNumOfTokensSold: BigInt!\\n  \" The total eth value of sales. This is the total eth value of sales from a given creator contract. Type: BigDecimal! \"\\n  totalEthValueOfSales: BigDecimal!\\n  \" The total number of transfers. This is the total number of transfers from a given creator contract. Type: BigInt! \"\\n  totalNumOfTransfers: BigInt!\\n  \" The editions. This is an array of editions created by the creator contract. Type: [Edition!]! \"\\n  editions: [Edition!]!\\n  \" The name. This is the name of the contract. Type: String! \"\\n  name: String\\n  \" The symbol. This is the symbol of the contract. Type: String! \"\\n  symbol: String\\n  \" The filter registry. This is the filter registry of the contract. Type: Bytes! \"\\n  filterRegistry: Bytes\\n}\\n\\n\" A table of creator contract settings. The creator contract settings have the configuration of the creator contract. \"\\ntype CreatorContractSetting @entity {\\n  \" The unique identifier for the creator contract setting. Type: ID! \"\\n  id: ID!\\n  \" The factory contract. This is the address of the factory contract. Type: Bytes! \"\\n  factoryContract: Bytes!\\n  \" The koda sales settings contract. This is the address of the koda sales settings contract which is used to configure the creator contract settings. Type: Bytes! \"\\n  kodaSalesSettingsContract: Bytes!\\n  \" The platform. This is the address of the platform which the creator contract is deployed from. Type: Bytes! \"\\n  platform: Bytes!\\n  \" The platform primary commission. This is the primary commission of the platform. Type: BigInt! \"\\n  platformPrimaryCommission: BigInt!\\n  \" The platform secondary commission. This is the secondary commission of the platform. Type: BigInt! \"\\n  platformSecondaryCommission: BigInt!\\n  \" The modulo. This is the modulo of the platform. Type: BigInt! \"\\n  MODULO: BigInt!\\n}\\n\\n\" A table of artist minting config. The artist minting config has the configuration of the artist minting. \"\\ntype ArtistMintingConfig @entity {\\n  \" The unique identifier for the artist minting config. Type: ID! \"\\n  id: ID!\\n  \" The mints. This is the total number of mints for the artist. Type: BigInt! \"\\n  mints: BigInt!\\n  \" The first mint in period. This is the first mint of a given period for the artist. Type: BigInt! \"\\n  firstMintInPeriod: BigInt!\\n  \" The frequency override. This is a boolean that indicates if the user can mint as much as possible. Type: Boolean! \"\\n  frequencyOverride: Boolean!\\n}\\n\\n\" A table of artists. An artists is someone who has created editions/tokens. \"\\ntype Artist @entity {\\n  \" The unique identifier for the artist. Type: ID! \"\\n  id: ID!\\n  \" The address. This is the address of the artist. Type: Bytes! \"\\n  address: Bytes!\\n  \" The name. This is the name of the artist. Type: String! \"\\n  name: String\\n  \" The editions count. This is the total number of editions created by the artist. Type: BigInt! \"\\n  editionsCount: BigInt!\\n  \" The editions count. This is the total number of editions created by the artist. Type: BigInt! \"\\n  ccEditionsCount: BigInt!\\n  \" The supply. This is the total supply of the artist. Type: BigInt! \"\\n  supply: BigInt!\\n  \" The issued count. This is the total number of issued tokens by the artist. Type: BigInt! \"\\n  issuedCount: BigInt!\\n  \" The total value in eth. This is the total value of assets in eth of the artist. Type: BigDecimal! \"\\n  totalValueInEth: BigDecimal!\\n  \" The sales count. This is the total number of sales of the artist. Type: BigInt! \"\\n  salesCount: BigInt!\\n  \" The total primary sales. This is the total number of primary sales of the artist. Type: BigInt! \"\\n  totalPrimarySales: BigInt!\\n  \" The total primary sales in eth. This is the total number of primary sales in eth of the artist. Type: BigDecimal! \"\\n  totalPrimarySalesInEth: BigDecimal!\\n  \" The total secondary sales. This is the total number of secondary sales of the artist. Type: BigInt! \"\\n  totalSecondarySales: BigInt!\\n  \" The total secondary sales in eth. This is the total number of secondary sales in eth of the artist. Type: BigDecimal! \"\\n  totalSecondarySalesInEth: BigDecimal!\\n  \" The highest sale value in eth. This is the highest sale value in eth of the artist. Type: BigDecimal! \"\\n  highestSaleValueInEth: BigDecimal!\\n  \" The highest sale token. This is the highest sale token of the artist. Type: Token! \"\\n  highestSaleToken: Token\\n  \" The first edition. This is the first edition that the artist created. Type: Edition! \"\\n  firstEdition: Edition\\n  \" The first edition timestamp. This is the timestamp of the first edition that the artist created. Type: BigInt! \"\\n  firstEditionTimestamp: BigInt!\\n  \" The last edition. This is the last edition that the artist created. Type: Edition! \"\\n  lastEdition: Edition\\n  \" The last edition timestamp. This is the timestamp of the last edition that the artist created. Type: BigInt! \"\\n  lastEditionTimestamp: BigInt!\\n  \" All of the editions that the artist has created. derivedFrom only work at query time, not runtime. Type: [Edition!]! \"\\n  editions: [Edition!]! @derivedFrom(field: \"artist\")\\n  \" All of the edition IDs that the artist has created. Type: [Edition!]! \"\\n  editionIds: [Edition!]!\\n  \" The minting config. This is the minting config of the artist. Type: ArtistMintingConfig! \"\\n  mintingConfig: ArtistMintingConfig!\\n  \" The creator contracts. This is an array of creator contracts created by the artist. Type: [CreatorContract!]! \"\\n  creatorContracts: [CreatorContract!]\\n}\\n\\n\" A table of collectors. A single collector who has at sometime held a KO asset. \"\\ntype Collector @entity {\\n  \" The unique identifier for the collector. Type: ID! \"\\n  id: ID!\\n  \" The address. This is the address of the collector. Type: Bytes! \"\\n  address: Bytes!\\n  \" The first seen. This is the first time the collector has been seen. Type: BigInt! \"\\n  firstSeen: BigInt!\\n  \" The first purchase timestamp. This is the timestamp of the first purchase of the collector. Type: BigInt! \"\\n  firstPurchaseTimeStamp: BigInt!\\n  \" The last purchase timestamp. This is the timestamp of the last purchase of the collector. Type: BigInt! \"\\n  lastPurchaseTimeStamp: BigInt!\\n  \" The primary purchase count. This is the total number of primary purchases of the collector. Type: BigInt! \"\\n  primaryPurchaseCount: BigInt!\\n  \" The primary purchase eth spent. This is the total eth spent on primary purchases of the collector. Type: BigDecimal! \"\\n  primaryPurchaseEthSpent: BigDecimal!\\n  \" The secondary sale count. This is the total number of secondary sales of the collector. Type: BigInt! \"\\n  secondarySaleCount: BigInt!\\n  \" The secondary sale eth total. This is the total eth spent on secondary sales of the collector. Type: BigDecimal! \"\\n  secondarySaleEthTotal: BigDecimal!\\n  \" The secondary purchase count. This is the total number of secondary purchases of the collector. Type: BigInt! \"\\n  secondaryPurchaseCount: BigInt!\\n  \" The secondary purchase eth spent. This is the total eth spent on secondary purchases of the collector. Type: BigDecimal! \"\\n  secondaryPurchaseEthSpent: BigDecimal!\\n  \" The total purchase count. This is the total number of purchases of the collector. Type: BigInt! \"\\n  totalPurchaseCount: BigInt!\\n  \" The total purchase eth spent. This is the total eth spent on purchases of the collector. Type: BigDecimal! \"\\n  totalPurchaseEthSpent: BigDecimal!\\n  \" All of the tokens currently owned by this account. derivedFrom only work at query time, not runtime. Type: [Token!]! \"\\n  tokens: [Token!]! @derivedFrom(field: \"currentOwner\")\\n  \" All of the token IDs currently owned by this account. Type: [Token!]! \"\\n  tokenIds: [Token!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines several entities, each representing a table in a database. Each entity has fields with specific data types, and each field is accompanied by a description. The task is to ensure that these descriptions are clear and concise, providing a factual explanation of what each field represents without altering the underlying schema structure. The descriptions should be directly related to the field names and types, avoiding any speculative or additional commentary.',\n    documented_schema='\"Description for table: TokenEvent\"\\ntype TokenEvent @entity(immutable: true) {\\n  \"Unique identifier for the token event\"\\n  id: ID!\\n  \"Version number of the token event\"\\n  version: BigInt!\\n  \"Name associated with the token event\"\\n  name: String!\\n  \"Token involved in the event\"\\n  token: Token!\\n  \"Edition related to the token event\"\\n  edition: Edition!\\n  \"Collector who bought the token\"\\n  buyer: Collector\\n  \"Collector who bid on the token\"\\n  bidder: Collector\\n  \"Current owner of the token\"\\n  currentOwner: Collector\\n  \"Value of the token in Ethereum\"\\n  ethValue: BigDecimal!\\n  \"Timestamp of the event\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry\"\\n  logIndex: BigInt!\\n  \"Address where the event occurred\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction was sent\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent\"\\n  eventTxTo: Bytes\\n  \"Block number in which the event was recorded\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: TransferEvent\"\\ntype TransferEvent @entity(immutable: true) {\\n  \"Unique identifier for the transfer event\"\\n  id: ID!\\n  \"Version number of the transfer event\"\\n  version: BigInt!\\n  \"Address from which the token was transferred\"\\n  from: Bytes!\\n  \"Address to which the token was transferred\"\\n  to: Bytes!\\n  \"Identifier of the token being transferred\"\\n  tokenId: BigInt!\\n  \"Edition related to the transfer\"\\n  edition: Edition!\\n  \"Timestamp of the transfer\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry\"\\n  logIndex: BigInt!\\n  \"Address where the event occurred\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction was sent\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent\"\\n  eventTxTo: Bytes\\n  \"Block number in which the transfer was recorded\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: AuctionEvent\"\\ntype AuctionEvent @entity(immutable: true) {\\n  \"Unique identifier for the auction event\"\\n  id: ID!\\n  \"Version number of the auction event\"\\n  version: BigInt!\\n  \"Edition related to the auction\"\\n  edition: Edition!\\n  \"Name associated with the auction event\"\\n  name: String!\\n  \"Address of the bidder in the auction\"\\n  bidder: Bytes!\\n  \"Address of the caller initiating the auction\"\\n  caller: Bytes!\\n  \"Value of the bid in Ethereum\"\\n  ethValue: BigDecimal!\\n  \"Timestamp until which the auction is locked\"\\n  lockupUntil: BigInt\\n  \"Timestamp of the auction event\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry\"\\n  logIndex: BigInt!\\n  \"Address where the event occurred\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction was sent\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent\"\\n  eventTxTo: Bytes\\n  \"Block number in which the auction was recorded\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: ActivityEvent\"\\ntype ActivityEvent @entity(immutable: true) {\\n  \"Unique identifier for the activity event\"\\n  id: ID!\\n  \"Type of the activity event\"\\n  type: String!\\n  \"Version number of the activity event\"\\n  version: BigInt!\\n  \"Specific type of event\"\\n  eventType: String!\\n  \"Edition related to the activity\"\\n  edition: Edition\\n  \"Token involved in the activity\"\\n  token: Token\\n  \"Address of the creator of the activity\"\\n  creator: Bytes!\\n  \"Commission for the creator\"\\n  creatorCommission: BigInt\\n  \"Address of the collaborator\"'\n)",
      1
    ],
    [
      "Example({'database_schema': '\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transactionHash\"\\n  transactionHash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: isBundle\"\\n  isBundle: Boolean!\\n  \"Description for column: collection\"\\n  collection: Collection!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: priceETH\"\\n  priceETH: BigDecimal!\\n  \"Description for column: strategy\"\\n  strategy: SaleStrategy!\\n  \"Description for column: buyer\"\\n  buyer: String!\\n  \"Description for column: seller\"\\n  seller: String!\\n}', 'documented_schema': '\" Trades exist such as a combination of taker/order and bid/ask. \"\\ntype Trade @entity @transaction {\\n  \" { Transaction hash }-{ Log index }-{ (optional) ID within bundle } \"\\n  id: ID!\\n  \" Event transaction hash. \"\\n  transactionHash: String!\\n  \" Event log index. \"\\n  logIndex: Int\\n  \" Block timestamp where the trade is executed. \"\\n  timestamp: BigInt!\\n  \" Block number where the trade is executed. \"\\n  blockNumber: BigInt!\\n  \" Whether the trade is in a bundle. \"\\n  isBundle: Boolean!\\n  \" Collection involved \"\\n  collection: Collection!\\n  \" Token ID of the traded NFT. \"\\n  tokenId: BigInt!\\n  \" The amount of token to transfer. It is set at 1 except for ERC1155 batch. \"\\n  amount: BigInt!\\n  \" Price (in ETH). If only 1 tokenId is involved, then the price is determined by the token only. If the trade is incurred by a batch purchasing (available in x2y2), then the price is the average price in the batch. \"\\n  priceETH: BigDecimal!\\n  \" Stretegy that the trade is executed. \"\\n  strategy: SaleStrategy!\\n  \" Buyer account address \"\\n  buyer: String!\\n  \" Seller account address \"\\n  seller: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Trade` entity with various fields, each representing a specific attribute of a trade transaction. The task is to document each field with a concise and factual description based on the information given in the schema. The descriptions should be clear and directly related to the field's purpose or data type, without altering the schema structure.\",\n    documented_schema='\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Unique identifier for the trade\"\\n  id: ID!\\n  \"Hash of the transaction\"\\n  transactionHash: String!\\n  \"Index of the log entry in the transaction\"\\n  logIndex: Int\\n  \"Timestamp of when the trade occurred\"\\n  timestamp: BigInt!\\n  \"Block number in which the trade was included\"\\n  blockNumber: BigInt!\\n  \"Indicates if the trade is part of a bundle\"\\n  isBundle: Boolean!\\n  \"Collection associated with the trade\"\\n  collection: Collection!\\n  \"Identifier for the token involved in the trade\"\\n  tokenId: BigInt!\\n  \"Amount of tokens traded\"\\n  amount: BigInt!\\n  \"Price of the trade in ETH\"\\n  priceETH: BigDecimal!\\n  \"Strategy used for the sale\"\\n  strategy: SaleStrategy!\\n  \"Address of the buyer\"\\n  buyer: String!\\n  \"Address of the seller\"\\n  seller: String!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: DexAmmProtocol\"\\ntype DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: type\"\\n  type: ProtocolType!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: totalLiquidityUSD\"\\n  totalLiquidityUSD: BigDecimal!\\n  \"Description for column: activeLiquidityUSD\"\\n  activeLiquidityUSD: BigDecimal!\\n  \"Description for column: uncollectedProtocolSideValueUSD\"\\n  uncollectedProtocolSideValueUSD: BigDecimal!\\n  \"Description for column: uncollectedSupplySideValueUSD\"\\n  uncollectedSupplySideValueUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: cumulativeUniqueLPs\"\\n  cumulativeUniqueLPs: Int!\\n  \"Description for column: cumulativeUniqueTraders\"\\n  cumulativeUniqueTraders: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: openPositionCount\"\\n  openPositionCount: Int!\\n  \"Description for column: cumulativePositionCount\"\\n  cumulativePositionCount: Int!\\n  \"Description for column: lastSnapshotDayID\"\\n  lastSnapshotDayID: Int!\\n  \"Description for column: lastUpdateTimestamp\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Description for column: lastUpdateBlockNumber\"\\n  lastUpdateBlockNumber: BigInt!\\n  \"Description for column: dailyUsageMetrics\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: hourlyUsageMetrics\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: financialMetrics\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: pools\"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: _regenesis\"\\n  _regenesis: Boolean!\\n}', 'documented_schema': 'type DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: Bytes!\\n  \" Name of the protocol, including version. e.g. Uniswap v3 \"\\n  name: String!\\n  \" Slug of protocol, including version. e.g. uniswap-v3 \"\\n  slug: String!\\n  \" Version of the subgraph schema, in SemVer format (e.g. 1.0.0) \"\\n  schemaVersion: String!\\n  \" Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) \"\\n  subgraphVersion: String!\\n  \" Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) \"\\n  methodologyVersion: String!\\n  \" The blockchain network this subgraph is indexing on \"\\n  network: Network!\\n  \" The type of protocol (e.g. DEX, Lending, Yield, etc) \"\\n  type: ProtocolType!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" The sum of all active and non-active liquidity in USD for this pool. \"\\n  totalLiquidityUSD: BigDecimal!\\n  \" All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick. \"\\n  activeLiquidityUSD: BigDecimal!\\n  \" All protocol-side value locking in USD that remains uncollected and unused in the protocol. \"\\n  uncollectedProtocolSideValueUSD: BigDecimal!\\n  \" All supply-side value locking in USD that remains uncollected and unused in the protocol. \"\\n  uncollectedSupplySideValueUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" All historical volume in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Number of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Number of cumulative liquidity providers \"\\n  cumulativeUniqueLPs: Int!\\n  \" Number of cumulative traders \"\\n  cumulativeUniqueTraders: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Total number of open positions \"\\n  openPositionCount: Int!\\n  \" Total number of positions (open and closed) \"\\n  cumulativePositionCount: Int!\\n  \" Day ID of the most recent daily snapshot \"\\n  lastSnapshotDayID: Int!\\n  \" Timestamp of the last time this entity was updated \"\\n  lastUpdateTimestamp: BigInt!\\n  \" Block number of the last time this entity was updated \"\\n  lastUpdateBlockNumber: BigInt!\\n  \" Daily usage metrics for this protocol \"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Hourly usage metrics for this protocol \"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Daily financial metrics for this protocol \"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" All pools that belong to this protocol \"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \" This is a boolean to indicate whether or not the pools have been instantiated the were initialized before Optimism regenesis \"\\n  _regenesis: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The task requires adding precise descriptions to the columns of the `DexAmmProtocol` table in the provided GraphQL schema. The descriptions should be factual and concise, focusing on the role and data type of each column. The schema should maintain its original structure, with the added documentation enhancing understanding without altering the schema's functionality.\",\n    documented_schema='\"Description for table: DexAmmProtocol\"\\ntype DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \"Unique identifier for the protocol, stored as bytes.\"\\n  id: Bytes!\\n  \"Name of the decentralized exchange automated market maker protocol.\"\\n  name: String!\\n  \"A short, human-readable identifier for the protocol.\"\\n  slug: String!\\n  \"Version of the schema used by the protocol.\"\\n  schemaVersion: String!\\n  \"Version of the subgraph deployed for the protocol.\"\\n  subgraphVersion: String!\\n  \"Version of the methodology applied in the protocol.\"\\n  methodologyVersion: String!\\n  \"Network on which the protocol is deployed.\"\\n  network: Network!\\n  \"Type of protocol, indicating its specific category.\"\\n  type: ProtocolType!\\n  \"Total value locked in USD within the protocol.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Total liquidity in USD available in the protocol.\"\\n  totalLiquidityUSD: BigDecimal!\\n  \"Active liquidity in USD currently being utilized in the protocol.\"\\n  activeLiquidityUSD: BigDecimal!\\n  \"Value in USD of protocol-side assets that are uncollected.\"\\n  uncollectedProtocolSideValueUSD: BigDecimal!\\n  \"Value in USD of supply-side assets that are uncollected.\"\\n  uncollectedSupplySideValueUSD: BigDecimal!\\n  \"Value in USD controlled by the protocol.\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Cumulative volume in USD traded through the protocol.\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Cumulative revenue in USD earned by supply-side participants.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue in USD earned by the protocol.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Total cumulative revenue in USD generated by the protocol.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Total number of unique users who have interacted with the protocol.\"\\n  cumulativeUniqueUsers: Int!\\n  \"Total number of unique liquidity providers in the protocol.\"\\n  cumulativeUniqueLPs: Int!\\n  \"Total number of unique traders who have used the protocol.\"\\n  cumulativeUniqueTraders: Int!\\n  \"Total number of pools created within the protocol.\"\\n  totalPoolCount: Int!\\n  \"Number of open positions currently active in the protocol.\"\\n  openPositionCount: Int!\\n  \"Total number of positions ever opened in the protocol.\"\\n  cumulativePositionCount: Int!\\n  \"Identifier for the last daily snapshot taken.\"\\n  lastSnapshotDayID: Int!\\n  \"Timestamp of the last update made to the protocol data.\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Block number of the last update made to the protocol data.\"\\n  lastUpdateBlockNumber: BigInt!\\n  \"Daily usage metrics snapshots derived from the protocol.\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Hourly usage metrics snapshots derived from the protocol.\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Daily financial metrics snapshots derived from the protocol.\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"List of liquidity pools associated with the protocol.\"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \"Indicates whether the protocol has undergone a regenesis event.\"\\n  _regenesis: Boolean!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Deposit\"\\ntype Deposit implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: inputTokenAmounts\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Description for column: outputTokenAmount\"\\n  outputTokenAmount: BigInt\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n}', 'documented_schema': 'type Deposit implements Event @entity @transaction {\\n  \" deposit-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool \"\\n  inputTokens: [Token!]!\\n  \" Output token of the pool. E.g. the UNI-LP token \"\\n  outputToken: Token\\n  \" Amount of input tokens in the token\\'s native unit \"\\n  inputTokenAmounts: [BigInt!]!\\n  \" Amount of output tokens in the token\\'s native unit \"\\n  outputTokenAmount: BigInt\\n  \" USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool) \"\\n  amountUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Deposit` type that implements the `Event` interface and includes several fields, each with a specific data type and a brief description. The task is to ensure that each field is documented with a concise and factual description, focusing on the role or nature of the field within the `Deposit` type. The descriptions should be clear and directly related to the field's purpose or data type.\",\n    documented_schema='\"Description for table: Deposit\"\\ntype Deposit implements Event @entity @transaction {\\n  \"Unique identifier for the deposit event\"\\n  id: ID!\\n  \"Transaction hash associated with the deposit\"\\n  hash: String!\\n  \"Index of the log entry in the block\"\\n  logIndex: Int!\\n  \"Protocol involved in the deposit\"\\n  protocol: DexAmmProtocol!\\n  \"Address receiving the deposit\"\\n  to: String!\\n  \"Address from which the deposit originates\"\\n  from: String!\\n  \"Block number in which the deposit was included\"\\n  blockNumber: BigInt!\\n  \"Timestamp of the deposit event\"\\n  timestamp: BigInt!\\n  \"Tokens deposited as input\"\\n  inputTokens: [Token!]!\\n  \"Token received as output from the deposit\"\\n  outputToken: Token\\n  \"Amounts of each input token deposited\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Amount of the output token received\"\\n  outputTokenAmount: BigInt\\n  \"Value of the deposit in USD\"\\n  amountUSD: BigDecimal!\\n  \"Liquidity pool associated with the deposit\"\\n  pool: LiquidityPool!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: _MarketList\"\\ntype _MarketList @entity {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: markets\"\\n  markets: [Bytes!]!\\n}', 'documented_schema': 'type _MarketList @entity {\\n  \" Same ID as LendingProtocol \"\\n  id: Bytes!\\n  \" IDs of all markets in the LendingProtocol \"\\n  markets: [Bytes!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity `_MarketList` with two fields: `id` and `markets`. The `id` field is of type `Bytes!`, indicating it is a non-nullable field that likely serves as a unique identifier for each entry in the `_MarketList`. The `markets` field is an array of `Bytes!`, also non-nullable, suggesting it holds a list of identifiers or references to other entities or data points, possibly representing different markets associated with the `_MarketList`.',\n    documented_schema='\"Description for table: _MarketList\"\\ntype _MarketList @entity {\\n  \"Unique identifier for the market list entry\"\\n  id: Bytes!\\n  \"List of market identifiers associated with the market list\"\\n  markets: [Bytes!]!\\n}'\n)",
      4
    ],
    [
      "Example({'database_schema': '\"Description for table: EarningsClaimedEvent\"\\ntype EarningsClaimedEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: delegator\"\\n  delegator: Delegator!\\n  \"Description for column: delegate\"\\n  delegate: Transcoder!\\n  \"Description for column: startRound\"\\n  startRound: BigInt!\\n  \"Description for column: endRound\"\\n  endRound: Round!\\n  \"Description for column: rewardTokens\"\\n  rewardTokens: BigDecimal!\\n  \"Description for column: fees\"\\n  fees: BigDecimal!\\n}', 'documented_schema': '\"\"\"\\nEarningsClaimedEvent entities are created for every emitted EarningsClaimed event.\\n\"\"\"\\ntype EarningsClaimedEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  \"Reference to the delegator that claimed its earnings\"\\n  delegator: Delegator!\\n  \"Reference to the delegator\\'s delegate\"\\n  delegate: Transcoder!\\n  \"First round that the delegator\\'s pending stake was computed from\"\\n  startRound: BigInt!\\n  \"Last round that the delegator\\'s pending stake was computed from\"\\n  endRound: Round!\\n  \"Reward tokens claimed by the delegator\"\\n  rewardTokens: BigDecimal!\\n  \"Fees claimed by the delegator\"\\n  fees: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `EarningsClaimedEvent` which implements the `Event` interface. Each field within this type is already accompanied by a description, which succinctly identifies the purpose of each field. The descriptions are clear and directly associated with the field names, ensuring that the schema is well-documented without altering the underlying structure.',\n    documented_schema='\"Description for table: EarningsClaimedEvent\"\\ntype EarningsClaimedEvent implements Event @entity {\\n  \"Unique identifier for the earnings claimed event\"\\n  id: ID!\\n  \"Associated transaction for the earnings claimed event\"\\n  transaction: Transaction!\\n  \"Timestamp when the earnings were claimed\"\\n  timestamp: Int!\\n  \"Round number during which the earnings were claimed\"\\n  round: Round!\\n  \"Address of the delegator claiming the earnings\"\\n  delegator: Delegator!\\n  \"Address of the delegate associated with the earnings claim\"\\n  delegate: Transcoder!\\n  \"Starting round number for the earnings claim period\"\\n  startRound: BigInt!\\n  \"Ending round number for the earnings claim period\"\\n  endRound: Round!\\n  \"Amount of reward tokens claimed\"\\n  rewardTokens: BigDecimal!\\n  \"Amount of fees claimed\"\\n  fees: BigDecimal!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Position\"\\ntype Position @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: account\"\\n  account: Account!\\n  \"Description for column: market\"\\n  market: Market!\\n  \"Description for column: asset\"\\n  asset: Token!\\n  \"Description for column: hashOpened\"\\n  hashOpened: Bytes!\\n  \"Description for column: hashClosed\"\\n  hashClosed: Bytes\\n  \"Description for column: blockNumberOpened\"\\n  blockNumberOpened: BigInt!\\n  \"Description for column: timestampOpened\"\\n  timestampOpened: BigInt!\\n  \"Description for column: blockNumberClosed\"\\n  blockNumberClosed: BigInt\\n  \"Description for column: timestampClosed\"\\n  timestampClosed: BigInt\\n  \"Description for column: side\"\\n  side: PositionSide!\\n  \"Description for column: type\"\\n  type: InterestRateType\\n  \"Description for column: isCollateral\"\\n  isCollateral: Boolean\\n  \"Description for column: isIsolated\"\\n  isIsolated: Boolean\\n  \"Description for column: balance\"\\n  balance: BigInt!\\n  \"Description for column: principal\"\\n  principal: BigInt\\n  \"Description for column: depositCount\"\\n  depositCount: Int!\\n  \"Description for column: deposits\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \"Description for column: withdrawCount\"\\n  withdrawCount: Int!\\n  \"Description for column: withdraws\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \"Description for column: borrowCount\"\\n  borrowCount: Int!\\n  \"Description for column: borrows\"\\n  borrows: [Borrow!]! @derivedFrom(field: \"position\")\\n  \"Description for column: repayCount\"\\n  repayCount: Int!\\n  \"Description for column: repays\"\\n  repays: [Repay!]! @derivedFrom(field: \"position\")\\n  \"Description for column: liquidationCount\"\\n  liquidationCount: Int!\\n  \"Description for column: liquidations\"\\n  liquidations: [Liquidate!]! @derivedFrom(field: \"positions\")\\n  \"Description for column: transferredCount\"\\n  transferredCount: Int!\\n  \"Description for column: receivedCount\"\\n  receivedCount: Int!\\n  \"Description for column: transfers\"\\n  transfers: [Transfer!]! @derivedFrom(field: \"positions\")\\n  \"Description for column: snapshots\"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n  \"Description for column: _eMode\"\\n  _eMode: Boolean\\n}', 'documented_schema': 'type Position @entity @regularPolling {\\n  \" { Account address }-{ Market address }-{ Position Side }-{ Optional: Interest Rate Type}-{ Counter } \"\\n  id: ID!\\n  \" Account that owns this position \"\\n  account: Account!\\n  \" The market in which this position was opened \"\\n  market: Market!\\n  \" The asset in which this position was opened with \"\\n  asset: Token!\\n  \" The hash of the transaction that opened this position \"\\n  hashOpened: Bytes!\\n  \" The hash of the transaction that closed this position \"\\n  hashClosed: Bytes\\n  \" Block number of when the position was opened \"\\n  blockNumberOpened: BigInt!\\n  \" Timestamp when the position was opened \"\\n  timestampOpened: BigInt!\\n  \" Block number of when the position was closed (0 if still open) \"\\n  blockNumberClosed: BigInt\\n  \" Timestamp when the position was closed (0 if still open) \"\\n  timestampClosed: BigInt\\n  \" Side of the position (either lender or borrower) \"\\n  side: PositionSide!\\n  \" Type of interest rate used for this position (stable or variable). Generally for borrow side positions.\"\\n  type: InterestRateType\\n  \" Whether this position has been enabled as a collateral (only applies to LENDER positions). For protocols (e.g. MakerDAO) that doesn\\'t require enabling explicitly, this will always be true. \"\\n  isCollateral: Boolean\\n  \" Whether this position is being isolated from risk from other positions (only applies to LENDER positions). For protocols (e.g. Aave V3) this reduces risk exposure from other user positions. \"\\n  isIsolated: Boolean\\n  \" Token balance in this position, in native amounts \"\\n  balance: BigInt!\\n  \" The token balance of this position without interest generated (Used to calculate interest generated on a position) \"\\n  principal: BigInt\\n  \" Number of deposits related to this position \"\\n  depositCount: Int!\\n  \" All deposit events of this position \"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \" Number of withdrawals related to this position \"\\n  withdrawCount: Int!\\n  \" All withdraw events of this position \"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \" Number of borrows related to this position \"\\n  borrowCount: Int!\\n  \" All borrow events of this position \"\\n  borrows: [Borrow!]! @derivedFrom(field: \"position\")\\n  \" Number of repays related to this position \"\\n  repayCount: Int!\\n  \" All repay events of this position \"\\n  repays: [Repay!]! @derivedFrom(field: \"position\")\\n  \" Number of liquidations related to this position (incremented when this position is liquidated) \"\\n  liquidationCount: Int!\\n  \" Liquidation event related to this position (if exists) \"\\n  liquidations: [Liquidate!]! @derivedFrom(field: \"positions\")\\n  \" Number of times this position has transferred \"\\n  transferredCount: Int!\\n  \" Number of times this position has received a transfer \"\\n  receivedCount: Int!\\n  \" All transfer events related to this position \"\\n  transfers: [Transfer!]! @derivedFrom(field: \"positions\")\\n  \" Position daily snapshots for open positions \"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n  \" efficient mode flag \"\\n  _eMode: Boolean\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Position` type with various fields, each representing a specific attribute of a position in a financial or trading context. The task is to document each field with a concise and factual description based on the information given in the schema. The descriptions should be clear and directly related to the field's purpose or data type, without adding any speculative or additional commentary.\",\n    documented_schema='\"Description for table: Position\"\\ntype Position @entity @regularPolling {\\n  \"Unique identifier for the position.\"\\n  id: ID!\\n  \"Reference to the account associated with the position.\"\\n  account: Account!\\n  \"Reference to the market in which the position is held.\"\\n  market: Market!\\n  \"Reference to the asset involved in the position.\"\\n  asset: Token!\\n  \"Hash of the transaction when the position was opened.\"\\n  hashOpened: Bytes!\\n  \"Hash of the transaction when the position was closed, if applicable.\"\\n  hashClosed: Bytes\\n  \"Block number when the position was opened.\"\\n  blockNumberOpened: BigInt!\\n  \"Timestamp when the position was opened.\"\\n  timestampOpened: BigInt!\\n  \"Block number when the position was closed, if applicable.\"\\n  blockNumberClosed: BigInt\\n  \"Timestamp when the position was closed, if applicable.\"\\n  timestampClosed: BigInt\\n  \"Indicates the side of the position (e.g., long or short).\"\\n  side: PositionSide!\\n  \"Type of interest rate applied to the position, if applicable.\"\\n  type: InterestRateType\\n  \"Indicates if the position is used as collateral.\"\\n  isCollateral: Boolean\\n  \"Indicates if the position is isolated.\"\\n  isIsolated: Boolean\\n  \"Current balance of the position.\"\\n  balance: BigInt!\\n  \"Principal amount of the position, if applicable.\"\\n  principal: BigInt\\n  \"Number of deposits made to the position.\"\\n  depositCount: Int!\\n  \"List of deposits associated with the position.\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \"Number of withdrawals made from the position.\"\\n  withdrawCount: Int!\\n  \"List of withdrawals associated with the position.\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \"Number of borrow actions associated with the position.\"\\n  borrowCount: Int!\\n  \"List of borrow actions associated with the position.\"\\n  borrows: [Borrow!]! @derivedFrom(field: \"position\")\\n  \"Number of repay actions associated with the position.\"\\n  repayCount: Int!\\n  \"List of repay actions associated with the position.\"\\n  repays: [Repay!]! @derivedFrom(field: \"position\")\\n  \"Number of liquidation events associated with the position.\"\\n  liquidationCount: Int!\\n  \"List of liquidation events associated with the position.\"\\n  liquidations: [Liquidate!]! @derivedFrom(field: \"positions\")\\n  \"Number of times the position was transferred.\"\\n  transferredCount: Int!\\n  \"Number of times the position was received.\"\\n  receivedCount: Int!\\n  \"List of transfer events associated with the position.\"\\n  transfers: [Transfer!]! @derivedFrom(field: \"positions\")\\n  \"List of snapshots capturing the state of the position over time.\"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n  \"Indicates if the position is in eMode.\"\\n  _eMode: Boolean\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: days\"\\n  days: Int!\\n  \"Description for column: protocol\"\\n  protocol: LendingProtocol!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: mintedTokenSupplies\"\\n  mintedTokenSupplies: [BigInt!]\\n  \"Description for column: dailySupplySideRevenueUSD\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyProtocolSideRevenueUSD\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyTotalRevenueUSD\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: revenueDetail\"\\n  revenueDetail: RevenueDetail\\n  \"Description for column: totalDepositBalanceUSD\"\\n  totalDepositBalanceUSD: BigDecimal!\\n  \"Description for column: dailyDepositUSD\"\\n  dailyDepositUSD: BigDecimal!\\n  \"Description for column: cumulativeDepositUSD\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Description for column: totalBorrowBalanceUSD\"\\n  totalBorrowBalanceUSD: BigDecimal!\\n  \"Description for column: dailyBorrowUSD\"\\n  dailyBorrowUSD: BigDecimal!\\n  \"Description for column: cumulativeBorrowUSD\"\\n  cumulativeBorrowUSD: BigDecimal!\\n  \"Description for column: dailyLiquidateUSD\"\\n  dailyLiquidateUSD: BigDecimal!\\n  \"Description for column: cumulativeLiquidateUSD\"\\n  cumulativeLiquidateUSD: BigDecimal!\\n  \"Description for column: dailyWithdrawUSD\"\\n  dailyWithdrawUSD: BigDecimal!\\n  \"Description for column: dailyRepayUSD\"\\n  dailyRepayUSD: BigDecimal!\\n  \"Description for column: dailyTransferUSD\"\\n  dailyTransferUSD: BigDecimal!\\n  \"Description for column: dailyFlashloanUSD\"\\n  dailyFlashloanUSD: BigDecimal!\\n}', 'documented_schema': 'type FinancialsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: Bytes!\\n  \" Number of days since Unix epoch time \"\\n  days: Int!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: LendingProtocol!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" Total supply of minted tokens in native amounts, with same ordering as mintedTokens. Only applies to CDP \"\\n  mintedTokenSupplies: [BigInt!]\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Details of revenue sources and amounts \"\\n  revenueDetail: RevenueDetail\\n  \" Current balance of all deposited assets, in USD. Note this metric should be the same as TVL. \"\\n  totalDepositBalanceUSD: BigDecimal!\\n  \" Total assets deposited on a given day, in USD \"\\n  dailyDepositUSD: BigDecimal!\\n  \" Sum of all historical deposits in USD (only considers deposits and not withdrawals) \"\\n  cumulativeDepositUSD: BigDecimal!\\n  \" Current balance of all borrowed/minted assets, in USD. \"\\n  totalBorrowBalanceUSD: BigDecimal!\\n  \" Total assets borrowed/minted on a given day, in USD. \"\\n  dailyBorrowUSD: BigDecimal!\\n  \" Sum of all historical borrows/mints in USD (i.e. total loan origination). \"\\n  cumulativeBorrowUSD: BigDecimal!\\n  \" Total assets liquidated on a given day, in USD. \"\\n  dailyLiquidateUSD: BigDecimal!\\n  \" Sum of all historical liquidations in USD \"\\n  cumulativeLiquidateUSD: BigDecimal!\\n  \" Total assets withdrawn on a given day, in USD. \"\\n  dailyWithdrawUSD: BigDecimal!\\n  \" Total assets repaid on a given day, in USD. \"\\n  dailyRepayUSD: BigDecimal!\\n  \" Total assets transferred on a given day, in USD. \"\\n  dailyTransferUSD: BigDecimal!\\n  \" Total flashloans executed on a given day, in USD. \"\\n  dailyFlashloanUSD: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The task requires documenting the GraphQL schema for the `FinancialsDailySnapshot` entity. Each field in the schema is already provided with a description, which needs to be formatted correctly to ensure clarity and consistency. The descriptions should be concise and directly related to the field they describe, without altering the underlying schema structure.',\n    documented_schema='\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Unique identifier for the snapshot.\"\\n  id: Bytes!\\n  \"Number of days since the protocol\\'s inception.\"\\n  days: Int!\\n  \"Reference to the associated lending protocol.\"\\n  protocol: LendingProtocol!\\n  \"Block number at the time of the snapshot.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of the snapshot in seconds since Unix epoch.\"\\n  timestamp: BigInt!\\n  \"Total value locked in USD at the time of the snapshot.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Value controlled by the protocol in USD.\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Supplies of minted tokens at the time of the snapshot.\"\\n  mintedTokenSupplies: [BigInt!]\\n  \"Revenue generated by the supply side in USD for the day.\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue generated by the supply side in USD.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Revenue generated by the protocol side in USD for the day.\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue generated by the protocol side in USD.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Total revenue generated in USD for the day.\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Cumulative total revenue generated in USD.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Detailed breakdown of revenue components.\"\\n  revenueDetail: RevenueDetail\\n  \"Total deposit balance in USD at the time of the snapshot.\"\\n  totalDepositBalanceUSD: BigDecimal!\\n  \"Total deposits in USD for the day.\"\\n  dailyDepositUSD: BigDecimal!\\n  \"Cumulative deposits in USD.\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Total borrow balance in USD at the time of the snapshot.\"\\n  totalBorrowBalanceUSD: BigDecimal!\\n  \"Total borrows in USD for the day.\"\\n  dailyBorrowUSD: BigDecimal!\\n  \"Cumulative borrows in USD.\"\\n  cumulativeBorrowUSD: BigDecimal!\\n  \"Total liquidations in USD for the day.\"\\n  dailyLiquidateUSD: BigDecimal!\\n  \"Cumulative liquidations in USD.\"\\n  cumulativeLiquidateUSD: BigDecimal!\\n  \"Total withdrawals in USD for the day.\"\\n  dailyWithdrawUSD: BigDecimal!\\n  \"Total repayments in USD for the day.\"\\n  dailyRepayUSD: BigDecimal!\\n  \"Total transfers in USD for the day.\"\\n  dailyTransferUSD: BigDecimal!\\n  \"Total flashloans in USD for the day.\"\\n  dailyFlashloanUSD: BigDecimal!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: token\"\\n  token: Token\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector!\\n  \"Description for column: bidder\"\\n  bidder: Collector!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: weiValue\"\\n  weiValue: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: lockedUntil\"\\n  lockedUntil: BigInt\\n  \"Description for column: isActive\"\\n  isActive: Boolean!\\n}', 'documented_schema': '\" A table of offers either on editions or tokens. \"\\ntype Offer @entity {\\n  \" The unique identifier for the offer. \"\\n  id: ID!\\n  \" The version of the offer (KODA 2 or 3). \"\\n  version: BigInt!\\n  \" The type of the offer (Token or Edition). \"\\n  type: String!\\n  \" The sales type of the offer (The current sales mechnic being used on this offer). \"\\n  salesType: BigInt!\\n  \" The token of the offer (nullable token, as editions dont have tokens attached). \"\\n  token: Token\\n  \" The edition of the offer (All offers must be from an edition). \"\\n  edition: Edition!\\n  \" The current owner of the offer (This is either the token holder or the edition artist). \"\\n  currentOwner: Collector!\\n  \" The bidder of the offer. \"\\n  bidder: Collector!\\n  \" The eth value of the offer. \"\\n  ethValue: BigDecimal!\\n  \" The wei value of the offer. \"\\n  weiValue: BigInt!\\n  \" The timestamp of the offer. \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the offer. \"\\n  transactionHash: Bytes!\\n  \" The locked until timestamp of the offer (for V3 offers, they will be locked for a certain amount of time). \"\\n  lockedUntil: BigInt\\n  \" If the offer is active. \"\\n  isActive: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines an \"Offer\" entity with various fields, each having a specific data type and a brief description. The task is to ensure that each field is documented with a concise and factual description, maintaining the original schema structure and format. The descriptions should be clear and directly related to the field\\'s purpose or data type.',\n    documented_schema='\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Unique identifier for the offer\"\\n  id: ID!\\n  \"Version number of the offer\"\\n  version: BigInt!\\n  \"Type of the offer\"\\n  type: String!\\n  \"Sales type identifier\"\\n  salesType: BigInt!\\n  \"Associated token for the offer\"\\n  token: Token\\n  \"Edition associated with the offer\"\\n  edition: Edition!\\n  \"Current owner of the offer\"\\n  currentOwner: Collector!\\n  \"Bidder involved in the offer\"\\n  bidder: Collector!\\n  \"Value of the offer in Ethereum\"\\n  ethValue: BigDecimal!\\n  \"Value of the offer in Wei\"\\n  weiValue: BigInt!\\n  \"Timestamp of the offer creation\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction\"\\n  transactionHash: Bytes!\\n  \"Time until the offer is locked\"\\n  lockedUntil: BigInt\\n  \"Indicates if the offer is active\"\\n  isActive: Boolean!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: TransferBondEvent\"\\ntype TransferBondEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: amount\"\\n  amount: BigDecimal!\\n  \"Description for column: newDelegator\"\\n  newDelegator: Delegator!\\n  \"Description for column: oldDelegator\"\\n  oldDelegator: Delegator!\\n  \"Description for column: newUnbondingLockId\"\\n  newUnbondingLockId: Int!\\n  \"Description for column: oldUnbondingLockId\"\\n  oldUnbondingLockId: Int!\\n}', 'documented_schema': '\"\"\"\\nTransferBond entities are created for every emitted TransferBond event.\\n\"\"\"\\ntype TransferBondEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  amount: BigDecimal!\\n  newDelegator: Delegator!\\n  oldDelegator: Delegator!\\n  newUnbondingLockId: Int!\\n  oldUnbondingLockId: Int!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `TransferBondEvent` which implements the `Event` interface. Each field within this type is already accompanied by a description, which is intended to document the purpose or nature of the field. The task is to ensure that these descriptions are clear and concise, focusing on the role of each field within the `TransferBondEvent` type. The descriptions should be factual and directly related to the field's function or data type.\",\n    documented_schema='\"Description for table: TransferBondEvent\"\\ntype TransferBondEvent implements Event @entity {\\n  \"Unique identifier for the transfer bond event\"\\n  id: ID!\\n  \"Associated transaction for the transfer bond event\"\\n  transaction: Transaction!\\n  \"Timestamp of when the transfer bond event occurred\"\\n  timestamp: Int!\\n  \"Round number during which the transfer bond event took place\"\\n  round: Round!\\n  \"Amount of the bond being transferred\"\\n  amount: BigDecimal!\\n  \"Delegator receiving the bond\"\\n  newDelegator: Delegator!\\n  \"Delegator transferring the bond\"\\n  oldDelegator: Delegator!\\n  \"Identifier for the new unbonding lock\"\\n  newUnbondingLockId: Int!\\n  \"Identifier for the old unbonding lock\"\\n  oldUnbondingLockId: Int!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: LiquidityPoolFee\"\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: feePercentage\"\\n  feePercentage: BigDecimal\\n  \"Description for column: feeType\"\\n  feeType: LiquidityPoolFeeType!\\n}', 'documented_schema': 'type LiquidityPoolFee @entity @regularPolling {\\n  \" { Fee type }-{ Pool address } \"\\n  id: ID!\\n  \" Fee as a percentage of the trade (swap) amount. Does not always apply \"\\n  feePercentage: BigDecimal\\n  \" Type of fee this pool uses \"\\n  feeType: LiquidityPoolFeeType!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `LiquidityPoolFee`, with three fields: `id`, `feePercentage`, and `feeType`. Each field has a specific type and purpose within the schema. The `id` field is a unique identifier of type `ID!`, indicating it is a non-nullable field. The `feePercentage` field is of type `BigDecimal`, which suggests it stores a decimal value representing the percentage of the fee. The `feeType` field is of type `LiquidityPoolFeeType!`, indicating it is a non-nullable field that likely categorizes the type of fee within the liquidity pool.',\n    documented_schema='\"Description for table: LiquidityPoolFee\"\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \"Unique identifier for the liquidity pool fee\"\\n  id: ID!\\n  \"Percentage value of the liquidity pool fee\"\\n  feePercentage: BigDecimal\\n  \"Type of the liquidity pool fee\"\\n  feeType: LiquidityPoolFeeType!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: DelegatedStake\"\\ntype DelegatedStake @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: indexer\"\\n  indexer: Indexer!\\n  \"Description for column: delegator\"\\n  delegator: Delegator!\\n  \"Description for column: stakedTokens\"\\n  stakedTokens: BigInt!\\n  \"Description for column: unstakedTokens\"\\n  unstakedTokens: BigInt!\\n  \"Description for column: lockedTokens\"\\n  lockedTokens: BigInt!\\n  \"Description for column: lockedUntil\"\\n  lockedUntil: Int!\\n  \"Description for column: shareAmount\"\\n  shareAmount: BigInt!\\n  \"Description for column: personalExchangeRate\"\\n  personalExchangeRate: BigDecimal!\\n  \"Description for column: realizedRewards\"\\n  realizedRewards: BigDecimal!\\n  \"Description for column: createdAt\"\\n  createdAt: Int!\\n  \"Description for column: lastDelegatedAt\"\\n  lastDelegatedAt: Int\\n  \"Description for column: lastUndelegatedAt\"\\n  lastUndelegatedAt: Int\\n  \"Description for column: transferredToL2\"\\n  transferredToL2: Boolean!\\n  \"Description for column: transferredToL2At\"\\n  transferredToL2At: BigInt\\n  \"Description for column: transferredToL2AtBlockNumber\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Description for column: transferredToL2AtTx\"\\n  transferredToL2AtTx: String\\n  \"Description for column: stakedTokensTransferredToL2\"\\n  stakedTokensTransferredToL2: BigInt!\\n  \"Description for column: idOnL2\"\\n  idOnL2: String\\n  \"Description for column: idOnL1\"\\n  idOnL1: String\\n}', 'documented_schema': '\"\"\"Delegator stake for a single Indexer\"\"\"\\ntype DelegatedStake @entity {\\n  \"Concatenation of Delegator address and Indexer address\"\\n  id: ID!\\n  \"Index the stake is delegated to\"\\n  indexer: Indexer!\\n  \"Delegator\"\\n  delegator: Delegator!\\n  \"CUMULATIVE tokens delegated\"\\n  stakedTokens: BigInt!\\n  \"CUMULATIVE tokens undelegated\"\\n  unstakedTokens: BigInt!\\n  \"CURRENT tokens locked\"\\n  lockedTokens: BigInt!\\n  \"Epoch the locked tokens get unlocked\"\\n  lockedUntil: Int!\\n  \"Shares owned in the delegator pool. Used to calculate total amount delegated\"\\n  shareAmount: BigInt!\\n  \"The rate this delegator paid for their shares (calculated using average cost basis). Used for rewards calculations\"\\n  personalExchangeRate: BigDecimal!\\n  \"Realized rewards from undelegating and realizing a reward\"\\n  realizedRewards: BigDecimal!\\n  \"Time this delegator first delegated to an indexer\"\\n  createdAt: Int!\\n  \"Last time this delegator delegated towards this indexer\"\\n  lastDelegatedAt: Int\\n  \"Last time this delegator undelegated from this indexer\"\\n  lastUndelegatedAt: Int\\n  \"Whether the delegation has been transferred from L1 to L2\"\\n  transferredToL2: Boolean!\\n  \"Timestamp for the L1 -> L2 Transfer\"\\n  transferredToL2At: BigInt\\n  \"Block number for the L1 -> L2 Transfer\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Transaction hash for the L1 -> L2 Transfer\"\\n  transferredToL2AtTx: String\\n  \"Amount of GRT transferred to L2. Only visible from L1, as there\\'s no events for it on L2\"\\n  stakedTokensTransferredToL2: BigInt!\\n  \"ID of the delegation on L2. Null if it\\'s not transferred\"\\n  idOnL2: String\\n  \"ID of the delegation on L1. Null if it\\'s not transferred\"\\n  idOnL1: String\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `DelegatedStake`, with various fields. Each field is already accompanied by a brief description, which is intended to document the purpose or nature of the field. The task is to ensure that these descriptions are clear and concise, providing enough context for someone reading the schema to understand what each field represents without altering the underlying schema structure.',\n    documented_schema='\"Description for table: DelegatedStake\"\\ntype DelegatedStake @entity {\\n  \"Unique identifier for the delegated stake.\"\\n  id: ID!\\n  \"Reference to the indexer associated with the stake.\"\\n  indexer: Indexer!\\n  \"Reference to the delegator who has staked tokens.\"\\n  delegator: Delegator!\\n  \"Total number of tokens currently staked.\"\\n  stakedTokens: BigInt!\\n  \"Total number of tokens that have been unstaked.\"\\n  unstakedTokens: BigInt!\\n  \"Total number of tokens that are locked.\"\\n  lockedTokens: BigInt!\\n  \"Timestamp until which the tokens are locked.\"\\n  lockedUntil: Int!\\n  \"Amount of shares corresponding to the staked tokens.\"\\n  shareAmount: BigInt!\\n  \"Exchange rate specific to the delegator\\'s stake.\"\\n  personalExchangeRate: BigDecimal!\\n  \"Rewards that have been realized from the stake.\"\\n  realizedRewards: BigDecimal!\\n  \"Timestamp when the stake was created.\"\\n  createdAt: Int!\\n  \"Timestamp of the last delegation action.\"\\n  lastDelegatedAt: Int\\n  \"Timestamp of the last undelegation action.\"\\n  lastUndelegatedAt: Int\\n  \"Indicates if the stake has been transferred to Layer 2.\"\\n  transferredToL2: Boolean!\\n  \"Timestamp when the stake was transferred to Layer 2.\"\\n  transferredToL2At: BigInt\\n  \"Block number at which the transfer to Layer 2 occurred.\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Transaction ID for the transfer to Layer 2.\"\\n  transferredToL2AtTx: String\\n  \"Amount of staked tokens transferred to Layer 2.\"\\n  stakedTokensTransferredToL2: BigInt!\\n  \"Identifier for the stake on Layer 2.\"\\n  idOnL2: String\\n  \"Identifier for the stake on Layer 1.\"\\n  idOnL1: String\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for enum type: Network\"\\nenum Network {\\n  \"Description for column: ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"Description for column: ARWEAVE_MAINNET\"\\n  ARWEAVE_MAINNET\\n  \"Description for column: AURORA\"\\n  AURORA\\n  \"Description for column: AVALANCHE\"\\n  AVALANCHE\\n  \"Description for column: BOBA\"\\n  BOBA\\n  \"Description for column: BSC\"\\n  BSC\\n  \"Description for column: CELO\"\\n  CELO\\n  \"Description for column: COSMOS\"\\n  COSMOS\\n  \"Description for column: CRONOS\"\\n  CRONOS\\n  \"Description for column: MAINNET\"\\n  MAINNET\\n  \"Description for column: FANTOM\"\\n  FANTOM\\n  \"Description for column: FUSE\"\\n  FUSE\\n  \"Description for column: HARMONY\"\\n  HARMONY\\n  \"Description for column: JUNO\"\\n  JUNO\\n  \"Description for column: MOONBEAM\"\\n  MOONBEAM\\n  \"Description for column: MOONRIVER\"\\n  MOONRIVER\\n  \"Description for column: NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"Description for column: OPTIMISM\"\\n  OPTIMISM\\n  \"Description for column: OSMOSIS\"\\n  OSMOSIS\\n  \"Description for column: MATIC\"\\n  MATIC\\n  \"Description for column: XDAI\"\\n  XDAI\\n}\\n\\n\"Description for enum type: NftStandard\"\\nenum NftStandard {\\n  \"Description for column: ERC721\"\\n  ERC721\\n  \"Description for column: ERC1155\"\\n  ERC1155\\n  \"Description for column: UNKNOWN\"\\n  UNKNOWN\\n}\\n\\n\"Description for enum type: SaleStrategy\"\\nenum SaleStrategy {\\n  \"Description for column: STANDARD_SALE\"\\n  STANDARD_SALE\\n  \"Description for column: ANY_ITEM_FROM_COLLECTION\"\\n  ANY_ITEM_FROM_COLLECTION\\n  \"Description for column: ANY_ITEM_FROM_SET\"\\n  ANY_ITEM_FROM_SET\\n  \"Description for column: DUTCH_AUCTION\"\\n  DUTCH_AUCTION\\n  \"Description for column: PRIVATE_SALE\"\\n  PRIVATE_SALE\\n}\\n\\n\"Description for table: Marketplace\"\\ntype Marketplace @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: collectionCount\"\\n  collectionCount: Int!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: cumulativeUniqueTraders\"\\n  cumulativeUniqueTraders: Int!\\n}\\n\\n\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt\\n  \"Description for column: nftStandard\"\\n  nftStandard: NftStandard!\\n  \"Description for column: royaltyFee\"\\n  royaltyFee: BigDecimal!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: buyerCount\"\\n  buyerCount: Int!\\n  \"Description for column: sellerCount\"\\n  sellerCount: Int!\\n  \"Description for column: trades\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}\\n\\n\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transactionHash\"\\n  transactionHash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: isBundle\"\\n  isBundle: Boolean!\\n  \"Description for column: collection\"\\n  collection: Collection!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: priceETH\"\\n  priceETH: BigDecimal!\\n  \"Description for column: strategy\"\\n  strategy: SaleStrategy!\\n  \"Description for column: buyer\"\\n  buyer: String!\\n  \"Description for column: seller\"\\n  seller: String!\\n}\\n\\n\"Description for table: MarketplaceDailySnapshot\"\\ntype MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: marketplace\"\\n  marketplace: Marketplace!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: collectionCount\"\\n  collectionCount: Int!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: cumulativeUniqueTraders\"\\n  cumulativeUniqueTraders: Int!\\n  \"Description for column: dailyActiveTraders\"\\n  dailyActiveTraders: Int!\\n  \"Description for column: dailyTradedCollectionCount\"\\n  dailyTradedCollectionCount: Int!\\n  \"Description for column: dailyTradedItemCount\"\\n  dailyTradedItemCount: Int!\\n}\\n\\n\"Description for table: CollectionDailySnapshot\"\\ntype CollectionDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: collection\"\\n  collection: Collection!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: royaltyFee\"\\n  royaltyFee: BigDecimal!\\n  \"Description for column: dailyMinSalePrice\"\\n  dailyMinSalePrice: BigDecimal!\\n  \"Description for column: dailyMaxSalePrice\"\\n  dailyMaxSalePrice: BigDecimal!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: dailyTradeVolumeETH\"\\n  dailyTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: dailyTradedItemCount\"\\n  dailyTradedItemCount: Int!\\n}\\n\\n\"Description for table: _Item\"\\ntype _Item @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n}', 'documented_schema': '\" Represents the blockchain network that the data is being collected from. \"\\nenum Network {\\n  \" The Arbitrum One network. \"\\n  ARBITRUM_ONE\\n  \" The Arweave Mainnet. \"\\n  ARWEAVE_MAINNET\\n  \" The Aurora network. \"\\n  AURORA\\n  \" The Avalanche network. \"\\n  AVALANCHE\\n  \" The Boba network. \"\\n  BOBA\\n  \" The Binance Smart Chain network (aka BNB Chain). \"\\n  BSC\\n  \" The Celo network. \"\\n  CELO\\n  \" The Cosmos network. \"\\n  COSMOS\\n  \" The Cronos network. \"\\n  CRONOS\\n  \" The Ethereum Mainnet. \"\\n  MAINNET\\n  \" The Fantom network. \"\\n  FANTOM\\n  \" The Fuse network. \"\\n  FUSE\\n  \" The Harmony network. \"\\n  HARMONY\\n  \" The Juno network. \"\\n  JUNO\\n  \" The Moonbeam network. \"\\n  MOONBEAM\\n  \" The Moonriver network. \"\\n  MOONRIVER\\n  \" The NEAR Mainnet. \"\\n  NEAR_MAINNET\\n  \" The Optimism network. \"\\n  OPTIMISM\\n  \" The Osmosis network. \"\\n  OSMOSIS\\n  \" The Matic network (aka Polygon). \"\\n  MATIC\\n  \" The xDai network (aka Gnosis Chain). \"\\n  XDAI\\n}\\n\\n\" The NFT standard that the collection uses. This is a defined standard that the Ethereum blockchain uses to create NFTs. \"\\nenum NftStandard {\\n  \" The ERC721 NFT standard. \"\\n  ERC721\\n  \" The ERC1155 NFT standard. \"\\n  ERC1155\\n  \" An unknown NFT standard. \"\\n  UNKNOWN\\n}\\n\\n\" Represents a sales strategy that executes an order. There are five types of sale strategies: Standard Sale, Any Item from Collection, Any Item from Set, Dutch Auction, and Private Sale. \"\\nenum SaleStrategy {\\n  \" Represents a sales strategy that executes an order at a fixed price that can be taken either by a bid or an ask. \"\\n  STANDARD_SALE\\n  \" Represents a sales strategy that executes an order at a fixed price that can be matched by any tokenId for the collection. \"\\n  ANY_ITEM_FROM_COLLECTION\\n  \" Represents a sales strategy that executes an order at a fixed price that can be matched by any tokenId in a set of tokenIds. \"\\n  ANY_ITEM_FROM_SET\\n  \" Represents a trategy to launch a Dutch Auction for a token where the price decreases linearly until a specified timestamp and end price defined by the seller. \"\\n  DUTCH_AUCTION\\n  \" Represents a strategy to set up an order that can only be executed by a specific address (aka a Private Sale). \"\\n  PRIVATE_SALE\\n}\\n\\n\" A marketplace is a platform where NFTs are traded. This is a unique entity that maps to marketplaces (smart contracts) on the blockchain. \"\\ntype Marketplace @entity @regularPolling {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: ID!\\n  \" Human readable name of the NFT marketplace, in this case OpenSea. \"\\n  name: String!\\n  \" The human readable trading slug of the NFT marketplace, in this case opensea. \"\\n  slug: String!\\n  \" The blockchain network this subgraph is indexing on. This corresponds to the network that data is being collected from. Options are presented in the Enum above. \"\\n  network: Network!\\n  \" This is the version of the schema, in SemVer format (e.g. 1.0.0), that the subgraph is implementing. This is because this schema is built from a common standard that is maintained by Messari. \"\\n  schemaVersion: String!\\n  \" This is the version of the subgraph implementation, in SemVer format (e.g. 1.0.0), that the subgraph is implementing. This is independent of schema, and pertains to how various actions update relevant fields. This is because this schema is built from a common standard that is maintained by Messari. \"\\n  subgraphVersion: String!\\n  \" This is the version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0). This is because the methodology used to compute metrics may change over time, and this field is used to track those changes. \"\\n  methodologyVersion: String!\\n  \" This is a field that is updated to reflect the number of collections listed on the marketplace. A collection is a group of NFTs that are created by the same creator. \"\\n  collectionCount: Int!\\n  \" This is a field that is updated to reflect the number of trades that have occurred on the marketplace, and is inclusive of all collections. \"\\n  tradeCount: Int!\\n  \" This is a field that is updated to reflect the cumulative trade volume in ETH that has occurred on the marketplace. Includes all trades from all collections. \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The revenue (in ETH) that goes to the marketplace protocol, aka protocol fee. This is the fee that is taken by the marketplace protocol for facilitating trades. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" This is the cumulative fees (in ETH) that have been taken by the creators of NFTs on the markeplace when they are traded. This is akin to a royalty fee. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" This is the total revenue that has been generated by the marketplace. This is calculated by adding the marketplace revenue and the creator revenue. \"\\n  totalRevenueETH: BigDecimal!\\n  \" This is a field that is updated to reflect the number of unique traders that have participated in trades on the marketplace. \"\\n  cumulativeUniqueTraders: Int!\\n}\\n\\n\" A collection is a group of NFTs that are created by the same creator. This is a unique entity that maps to collections on the marketplace. \"\\ntype Collection @entity @regularPolling {\\n  \" This is the unique identifier for the collection, and is the contract address of the collection. \"\\n  id: ID!\\n  \" This is the name of the collection, and is the name that is given to the collection by the creator. It is mirrored from the smart contract, and left null if not available. \"\\n  name: String\\n  \" This is the symbol of the collection, and is the symbol that is given to the collection by the creator. It is mirrored from the smart contract, and left null if not available. \"\\n  symbol: String\\n  \" This is the total supply of the collection (number of NFTs within a given collection), and is mirrored from the smart contract. \"\\n  totalSupply: BigInt\\n  \" This is the NFT standard that the collection uses. This can be either ERC721, ERC1155, or Unknown. It must be one of the values present within the NftStandard Enum. \"\\n  nftStandard: NftStandard!\\n  \" This is the fee that is taken by the creator of the NFT when it is traded. It is akin to a royalty fee. It is a fee rte in percentage. E.g. 2.5% should be 2.5. \"\\n  royaltyFee: BigDecimal!\\n  \" The cumulative trade volume in ETH that has occurred for the collection. This is the total value of all trades that have occurred for the collection (in ETH). \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The revenue that is collected by the marketplace protocol for facilitating trades of the collection (in ETH). This is akin to a protocol fee. It is represented in ETH. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" The revenue that is collected by the creator of the NFT when it is traded (in ETH). This is akin to a royalty fee. It is represented in ETH. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" The total revenue that has been generated by the collection (in ETH). This is calculated by adding the marketplace revenue and the creator revenue. It is represented in ETH. \"\\n  totalRevenueETH: BigDecimal!\\n  \" This is the number of trades that have occurred for the collection on the marketplace. Each trade is a unique transaction. \"\\n  tradeCount: Int!\\n  \" The total number of unique buyers that have participated in trades for the collection. \"\\n  buyerCount: Int!\\n  \" The total number of unique sellers that have participated in trades for the collection. \"\\n  sellerCount: Int!\\n  \" This maps to the Trade entity, and is a list of trades that have occurred for the collection. \"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}\\n\\n\" Trades exist such as a combination of taker/order and bid/ask. \"\\ntype Trade @entity @transaction {\\n  \" The id for a trade is combination of the following components: { Transaction hash }-{ Log index }-{ (optional) ID within bundle } \"\\n  id: ID!\\n  \" The transaction has that the trade is executed in. This is a unique identifier for the transaction. It is possible that multiple trades are executed in a single transaction. \"\\n  transactionHash: String!\\n  \" This represents the index of the log within the transaction. It is a unique identifier for the log within the transaction. The event corresponds to a trade event. \"\\n  logIndex: Int\\n  \" Block timestamp where the trade is executed. This is based on the timestamp of the block where the trade is executed. \"\\n  timestamp: BigInt!\\n  \" Block number where the trade is executed. A block is a collection of transactions that are executed on the blockchain. \"\\n  blockNumber: BigInt!\\n  \" Whether the trade is in a bundle. Trades can be in a bundle, which means that multiple NFTs are traded together. \"\\n  isBundle: Boolean!\\n  \" Collection involved. This is the collection that the trade, and corresponding NFT, is associated with. \"\\n  collection: Collection!\\n  \" The token ID is the unique identifier for the NFT that is traded. It is unique within the collection. \"\\n  tokenId: BigInt!\\n  \" The amount of token to transfer. It is set at 1 except for ERC1155 batch. \"\\n  amount: BigInt!\\n  \" Price (in ETH). If only 1 tokenId is involved, then the price is determined by the token only. If the trade is incurred by a batch purchasing (available in x2y2), then the price is the average price in the batch. \"\\n  priceETH: BigDecimal!\\n  \" The strategy that the trade is executed with. This is a sale strategy that is used to execute the trade. It is defined by the SaleStrategy Enum. \"\\n  strategy: SaleStrategy!\\n  \" The buyer account address is the address of the account that is purchasing the NFT(s). \"\\n  buyer: String!\\n  \" The seller account address is the address of the account that is selling the NFT(s). \"\\n  seller: String!\\n}\\n\\n\" A daily snapshot of the marketplace. This entity tracks the daily metrics of the marketplace. \"\\ntype MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \" The id for a daily snapshot of the marketplace is a combination of the contract address and the number of days since the Unix epoch time: { Contract address }-{# of days since Unix epoch time } \"\\n  id: ID!\\n  \" This maps to the Marketplace entity that the snapshot is of. \"\\n  marketplace: Marketplace!\\n  \" This is the block number when the snapshot was taken. It is a unique identifier for the block based on the network the marketplace is on. \"\\n  blockNumber: BigInt!\\n  \" This is the timestamp of the block when the snapshot was taken. The timestamp is a Unix timestamp. \"\\n  timestamp: BigInt!\\n  \" A cumulative count of all collections listed on the marketplace. This is a value determined at the time of the snapshot. \"\\n  collectionCount: Int!\\n  \" The total trading volume in ETH that has occurred on the marketplace during the day of the snapshot. This is the total value of all trades that have occurred on the marketplace in the given day. \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The total revenue generated by the marketplace protocol during the day of the snapshot. This is the fee that is taken by the marketplace protocol for facilitating trades. This is akin to a protocol fee. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" The total creator revenue collected on the marketplace during the day of the snapshot. This is the fee that is taken by the creators of NFTs on the markeplace when they are traded. This is akin to a royalty fee. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" The total revenue that has been generated by the marketplace during the day of the snapshot. This is calculated by adding the marketplace revenue and the creator revenue. \"\\n  totalRevenueETH: BigDecimal!\\n  \" The total number of trades that have occurred on the marketplace during the day of the snapshot. \"\\n  tradeCount: Int!\\n  \" The number of unique traders that have participated in trades on the marketplace for the given day. This is a cumulative count of all unique traders that have participated in trades on the marketplace on that day. \"\\n  cumulativeUniqueTraders: Int!\\n  \" The number of unique traders that have participated in trades on the marketplace for the given day. This is a count of all unique traders that have participated in trades on the marketplace on that day. \"\\n  dailyActiveTraders: Int!\\n  \" The number of collections that have been traded on the marketplace during the day of the snapshot. This is a cumulative value of the distinct collections that have been traded on the marketplace on that day. \"\\n  dailyTradedCollectionCount: Int!\\n  \" The number of traded items that have been traded on the marketplace during the day of the snapshot. This is a count of all NFTs that have been traded on the marketplace on that day. \"\\n  dailyTradedItemCount: Int!\\n}\\n\\n\" A daily snapshot of a collection. This entity tracks the daily metrics of a collection. \"\\ntype CollectionDailySnapshot @entity @dailySnapshot {\\n  \" The id for a daily snapshot of a collection is a combination of the contract address and the number of days since the Unix epoch time: { Contract address }-{# of days since epoch unix time } \"\\n  id: ID!\\n  \" This maps to the Collection entity that the snapshot is of. The collection is a group of NFTs that are created by the same creator. \"\\n  collection: Collection!\\n  \" Block number when the snapshot was taken. It is a unique identifier for the block based on the network the collection is on. \"\\n  blockNumber: BigInt!\\n  \" The block timestamp of the block when the snapshot was taken. The timestamp is a Unix timestamp. \"\\n  timestamp: BigInt!\\n  \" The royalty fee is the fee that is taken by the creator of the NFT when it is traded. It is akin to a royalty fee. It is a fee rate in percentage. E.g. 2.5% should be 2.5. \"\\n  royaltyFee: BigDecimal!\\n  \" The minimum sale price of the day (in ETH) is the lowest price that an NFT from the collection has been sold for on the marketplace during the day of the snapshot. \"\\n  dailyMinSalePrice: BigDecimal!\\n  \" The maximum sale price of the day (in ETH) is the highest price that an NFT from the collection has been sold for on the marketplace during the day of the snapshot. \"\\n  dailyMaxSalePrice: BigDecimal!\\n  \" The cumulative trade volume in ETH that has occurred for the collection in the given day. This is the total value of all trades that have occurred for the collection (in ETH) for that day. \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The total trading volume in ETH that has occurred for the collection during the day of the snapshot. This is the total value of all trades that have occurred for the collection in the given day. \"\\n  dailyTradeVolumeETH: BigDecimal!\\n  \" The revenue that is collected by the marketplace protocol for facilitating trades of the collection (in ETH) for the given day. This is akin to the total protocol fee collected for a day. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" The revenue that is collected by the creator of the NFT when it is traded (in ETH) for the given day. This is akin to the total royalty fee collected for a day. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" This is the total revenue that has been generated by the collection for the given day. This is calculated by adding the marketplace revenue and the creator revenue. \"\\n  totalRevenueETH: BigDecimal!\\n  \" The total number of trades that have occurred for the collection on the marketplace on a given day. Each trade is a unique transaction. \"\\n  tradeCount: Int!\\n  \" The total number of unique NFTs that have been traded from the collection on the marketplace on a given day. \"\\n  dailyTradedItemCount: Int!\\n}\\n\\n\" A helper utility entity that works as a set for deduplication purpose. \"\\ntype _Item @entity {\\n  \" The unique identifier for the item. This is a combination of the type of item and the account address. MARKETPLACE_ACCOUNT-{ Account } or COLLECTION_ACCOUNT-{ Buyer/Seller }-{ Collection ID }-{ Account } depending on the type of item. \"\\n  id: ID!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema includes several enum types and entity types, each with specific fields that require documentation. The enum types (Network, NftStandard, SaleStrategy) list various options for their respective categories, and each option is documented with a description. The entity types (Marketplace, Collection, Trade, MarketplaceDailySnapshot, CollectionDailySnapshot, _Item) represent tables with fields that are also documented. The task is to ensure that each field and enum value is properly documented without altering the underlying schema structure. The documentation should be concise and factual, reflecting the purpose or nature of each field or enum value.',\n    documented_schema='\"Description for enum type: Network\"\\nenum Network {\\n  \"Arbitrum One network\"\\n  ARBITRUM_ONE\\n  \"Arweave Mainnet network\"\\n  ARWEAVE_MAINNET\\n  \"Aurora network\"\\n  AURORA\\n  \"Avalanche network\"\\n  AVALANCHE\\n  \"Boba network\"\\n  BOBA\\n  \"Binance Smart Chain network\"\\n  BSC\\n  \"Celo network\"\\n  CELO\\n  \"Cosmos network\"\\n  COSMOS\\n  \"Cronos network\"\\n  CRONOS\\n  \"Ethereum Mainnet network\"\\n  MAINNET\\n  \"Fantom network\"\\n  FANTOM\\n  \"Fuse network\"\\n  FUSE\\n  \"Harmony network\"\\n  HARMONY\\n  \"Juno network\"\\n  JUNO\\n  \"Moonbeam network\"\\n  MOONBEAM\\n  \"Moonriver network\"\\n  MOONRIVER\\n  \"Near Mainnet network\"\\n  NEAR_MAINNET\\n  \"Optimism network\"\\n  OPTIMISM\\n  \"Osmosis network\"\\n  OSMOSIS\\n  \"Polygon (Matic) network\"\\n  MATIC\\n  \"xDai network\"\\n  XDAI\\n}\\n\\n\"Description for enum type: NftStandard\"\\nenum NftStandard {\\n  \"ERC721 standard for NFTs\"\\n  ERC721\\n  \"ERC1155 standard for NFTs\"\\n  ERC1155\\n  \"Unknown NFT standard\"\\n  UNKNOWN\\n}\\n\\n\"Description for enum type: SaleStrategy\"\\nenum SaleStrategy {\\n  \"Standard sale strategy\"\\n  STANDARD_SALE\\n  \"Sale of any item from a collection\"\\n  ANY_ITEM_FROM_COLLECTION\\n  \"Sale of any item from a set\"\\n  ANY_ITEM_FROM_SET\\n  \"Dutch auction sale strategy\"\\n  DUTCH_AUCTION\\n  \"Private sale strategy\"\\n  PRIVATE_SALE\\n}\\n\\n\"Description for table: Marketplace\"\\ntype Marketplace @entity @regularPolling {\\n  \"Unique identifier for the marketplace\"\\n  id: ID!\\n  \"Name of the marketplace\"\\n  name: String!\\n  \"Slug for the marketplace\"\\n  slug: String!\\n  \"Network on which the marketplace operates\"\\n  network: Network!\\n  \"Version of the schema\"\\n  schemaVersion: String!\\n  \"Version of the subgraph\"\\n  subgraphVersion: String!\\n  \"Version of the methodology\"\\n  methodologyVersion: String!\\n  \"Number of collections in the marketplace\"\\n  collectionCount: Int!\\n  \"Total number of trades in the marketplace\"\\n  tradeCount: Int!\\n  \"Cumulative trade volume in ETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Revenue of the marketplace in ETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Revenue for creators in ETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Total revenue in ETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Cumulative number of unique traders\"\\n  cumulativeUniqueTraders: Int!\\n}\\n\\n\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Unique identifier for the collection\"\\n  id: ID!\\n  \"Name of the collection\"\\n  name: String\\n  \"Symbol of the collection\"\\n  symbol: String\\n  \"Total supply of items in the collection\"\\n  totalSupply: BigInt\\n  \"NFT standard used by the collection\"\\n  nftStandard: NftStandard!\\n  \"Royalty fee for the collection\"\\n  royaltyFee: BigDecimal!\\n  \"Cumulative trade volume in ETH for the collection\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Marketplace revenue in ETH from the collection\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Creator revenue in ETH from the collection\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Total revenue in ETH from the collection\"\\n  totalRevenueETH: BigDecimal!\\n  \"Total number of trades for the collection\"\\n  tradeCount: Int!\\n  \"Number of unique buyers for the collection\"\\n  buyerCount: Int!\\n  \"Number of unique sellers for the collection\"\\n  sellerCount: Int!\\n  \"List of trades associated with the collection\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}\\n\\n\"Description for table:'\n)",
      1
    ],
    [
      "Example({'database_schema': '\"Description for enum type: TokenType\"\\nenum TokenType {\\n  \"Description for column: REBASING\"\\n  REBASING\\n  \"Description for column: NON_REBASING\"\\n  NON_REBASING\\n}', 'documented_schema': 'enum TokenType {\\n  \" Rebasing tokens continuously adjust balances / supply as interest is accrued (e.g. Aave debt balances adjust at each block with interest) \"\\n  REBASING\\n  \" Non-rebasing token balances / supply do not change as interest is accrued (e.g. Compound\\'s cToken\\'s do not adjust balance, the exchange rate changes with interest) \"\\n  NON_REBASING\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided schema is an enumeration type named `TokenType` with two possible values: `REBASING` and `NON_REBASING`. Each value has a placeholder for a description, but the actual descriptions are not provided. The task is to ensure that each value is documented with a concise and factual description based on the schema's context.\",\n    documented_schema='\"Description for enum type: TokenType\"\\nenum TokenType {\\n  \"Indicates a token that adjusts its supply periodically.\"\\n  REBASING\\n  \"Indicates a token with a fixed supply that does not adjust.\"\\n  NON_REBASING\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: TickHourlySnapshot\"\\ntype TickHourlySnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hour\"\\n  hour: Int!\\n  \"Description for column: tick\"\\n  tick: Tick!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: liquidityGross\"\\n  liquidityGross: BigInt!\\n  \"Description for column: liquidityGrossUSD\"\\n  liquidityGrossUSD: BigDecimal!\\n  \"Description for column: liquidityNet\"\\n  liquidityNet: BigInt!\\n  \"Description for column: liquidityNetUSD\"\\n  liquidityNetUSD: BigDecimal!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}', 'documented_schema': 'type TickHourlySnapshot @entity(immutable: true) @hourlySnapshot {\\n  \" { pool address }-{ tick index }-{ hour ID } \"\\n  id: Bytes!\\n  \" Number of hours since Unix epoch time \"\\n  hour: Int!\\n  \" tick index \"\\n  tick: Tick!\\n  \" liquidity pool this tick belongs to \"\\n  pool: LiquidityPool!\\n  \" total liquidity pool has as tick lower or upper \"\\n  liquidityGross: BigInt!\\n  \" total liquidity in USD pool has as tick lower or upper \"\\n  liquidityGrossUSD: BigDecimal!\\n  \" how much liquidity changes when tick crossed \"\\n  liquidityNet: BigInt!\\n  \" how much liquidity in USD changes when tick crossed \"\\n  liquidityNetUSD: BigDecimal!\\n  \" Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed) \"\\n  timestamp: BigInt!\\n  \" Block number of when this snapshot was taken/last modified (May be taken after interval has passed) \"\\n  blockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a table named `TickHourlySnapshot` with several fields, each having a specific data type and a brief description. The task is to ensure that each field is documented with a concise and factual description, maintaining the original schema structure and formatting. The descriptions should be clear and directly related to the field's purpose or data type.\",\n    documented_schema='\"Description for table: TickHourlySnapshot\"\\ntype TickHourlySnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Unique identifier for the snapshot\"\\n  id: Bytes!\\n  \"The hour for which the snapshot is taken\"\\n  hour: Int!\\n  \"Reference to the tick associated with the snapshot\"\\n  tick: Tick!\\n  \"Reference to the liquidity pool associated with the snapshot\"\\n  pool: LiquidityPool!\\n  \"Total gross liquidity at the time of the snapshot\"\\n  liquidityGross: BigInt!\\n  \"Total gross liquidity in USD at the time of the snapshot\"\\n  liquidityGrossUSD: BigDecimal!\\n  \"Net liquidity at the time of the snapshot\"\\n  liquidityNet: BigInt!\\n  \"Net liquidity in USD at the time of the snapshot\"\\n  liquidityNetUSD: BigDecimal!\\n  \"Timestamp of when the snapshot was taken\"\\n  timestamp: BigInt!\\n  \"Block number at the time of the snapshot\"\\n  blockNumber: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: CreatorContract\"\\ntype CreatorContract @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: implementation\"\\n  implementation: Bytes!\\n  \"Description for column: deployer\"\\n  deployer: Bytes!\\n  \"Description for column: creator\"\\n  creator: Bytes!\\n  \"Description for column: paused\"\\n  paused: Boolean!\\n  \"Description for column: owner\"\\n  owner: Bytes!\\n  \"Description for column: secondaryRoyaltyPercentage\"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \"Description for column: minter\"\\n  minter: Bytes!\\n  \"Description for column: defaultFundsHandler\"\\n  defaultFundsHandler: Bytes!\\n  \"Description for column: defaultFundsRecipients\"\\n  defaultFundsRecipients: [Bytes!]!\\n  \"Description for column: defaultFundsShares\"\\n  defaultFundsShares: [BigInt!]!\\n  \"Description for column: ERC165InterfaceID\"\\n  ERC165InterfaceID: Bytes\\n  \"Description for column: isBatchBuyItNow\"\\n  isBatchBuyItNow: Boolean!\\n  \"Description for column: isHidden\"\\n  isHidden: Boolean!\\n  \"Description for column: transferState\"\\n  transferState: BigInt!\\n  \"Description for column: totalNumOfEditions\"\\n  totalNumOfEditions: BigInt!\\n  \"Description for column: totalNumOfTokensSold\"\\n  totalNumOfTokensSold: BigInt!\\n  \"Description for column: totalEthValueOfSales\"\\n  totalEthValueOfSales: BigDecimal!\\n  \"Description for column: totalNumOfTransfers\"\\n  totalNumOfTransfers: BigInt!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: filterRegistry\"\\n  filterRegistry: Bytes\\n}', 'documented_schema': '\" A table of KODA V4 contracts deployed from the V4 factory. \"\\ntype CreatorContract @entity {\\n  \" The unique identifier for the creator contract. \"\\n  id: ID!\\n  \" The block number of the deployment. \"\\n  blockNumber: BigInt!\\n  \" The timestamp of the deployment. \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the deployment. \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the deployment. \"\\n  transactionIndex: BigInt!\\n  \" The log index of the deployment. \"\\n  logIndex: BigInt!\\n  \" The address of the event. \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. \"\\n  eventTxTo: Bytes\\n  \" The address of the implementation contract. \"\\n  implementation: Bytes!\\n  \" The deployer address of the creator contract. \"\\n  deployer: Bytes!\\n  \" The creator address of the creator contract. \"\\n  creator: Bytes!\\n  \" Whether the creator contract is paused. \"\\n  paused: Boolean!\\n  \" The owner of the creator contract. \"\\n  owner: Bytes!\\n  \" The secondary royalty percentage for the creator contract (Across all editions the currently specified secondary royalty EIP2981). \"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \" The minter of the creator contract. \"\\n  minter: Bytes!\\n  \" The default funds handler for the creator contract. \"\\n  defaultFundsHandler: Bytes!\\n  \" The default funds recipients for the creator contract. \"\\n  defaultFundsRecipients: [Bytes!]!\\n  \" The default funds shares for the creator contract. \"\\n  defaultFundsShares: [BigInt!]!\\n  \" The ERC165 interface ID for the creator contract. \"\\n  ERC165InterfaceID: Bytes\\n  \" If the creator contract is batch buy it now. \"\\n  isBatchBuyItNow: Boolean!\\n  \" If the creator contract is hidden. \"\\n  isHidden: Boolean!\\n  \" The transfer state of the creator contract. \"\\n  transferState: BigInt!\\n  \" The total number of editions created by the creator contract. \"\\n  totalNumOfEditions: BigInt!\\n  \" The total number of tokens sold by the creator contract. \"\\n  totalNumOfTokensSold: BigInt!\\n  \" The total ETH value of sales by the creator contract. \"\\n  totalEthValueOfSales: BigDecimal!\\n  \" The total number of transfers by the creator contract. \"\\n  totalNumOfTransfers: BigInt!\\n  \" The editions created by the creator contract. \"\\n  editions: [Edition!]!\\n  \" The name of the creator contract. \"\\n  name: String\\n  \" The symbol of the creator contract. \"\\n  symbol: String\\n  \" The filter registry of the creator contract. \"\\n  filterRegistry: Bytes\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `CreatorContract`, with various fields. Each field is already accompanied by a brief description, which is consistent with the task requirements. The descriptions are concise and factual, directly reflecting the data type and purpose of each field. The task is to ensure that these descriptions are properly formatted and documented without altering the underlying schema.',\n    documented_schema='\"Description for table: CreatorContract\"\\ntype CreatorContract @entity {\\n  \"Unique identifier for the creator contract.\"\\n  id: ID!\\n  \"Block number in which the contract was created.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of the block when the contract was created.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction that created the contract.\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block.\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry within the transaction.\"\\n  logIndex: BigInt!\\n  \"Address associated with the event.\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction was sent.\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent, if applicable.\"\\n  eventTxTo: Bytes\\n  \"Address of the contract implementation.\"\\n  implementation: Bytes!\\n  \"Address of the deployer of the contract.\"\\n  deployer: Bytes!\\n  \"Address of the creator of the contract.\"\\n  creator: Bytes!\\n  \"Indicates whether the contract is paused.\"\\n  paused: Boolean!\\n  \"Address of the owner of the contract.\"\\n  owner: Bytes!\\n  \"Percentage of secondary royalties.\"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \"Address of the minter.\"\\n  minter: Bytes!\\n  \"Default handler for funds.\"\\n  defaultFundsHandler: Bytes!\\n  \"List of default recipients for funds.\"\\n  defaultFundsRecipients: [Bytes!]!\\n  \"List of shares for each default fund recipient.\"\\n  defaultFundsShares: [BigInt!]!\\n  \"ERC165 interface ID, if applicable.\"\\n  ERC165InterfaceID: Bytes\\n  \"Indicates if batch buy-it-now is enabled.\"\\n  isBatchBuyItNow: Boolean!\\n  \"Indicates if the contract is hidden.\"\\n  isHidden: Boolean!\\n  \"State of the transfer process.\"\\n  transferState: BigInt!\\n  \"Total number of editions available.\"\\n  totalNumOfEditions: BigInt!\\n  \"Total number of tokens sold.\"\\n  totalNumOfTokensSold: BigInt!\\n  \"Total Ethereum value of sales.\"\\n  totalEthValueOfSales: BigDecimal!\\n  \"Total number of transfers made.\"\\n  totalNumOfTransfers: BigInt!\\n  \"List of editions associated with the contract.\"\\n  editions: [Edition!]!\\n  \"Name of the contract.\"\\n  name: String\\n  \"Symbol representing the contract.\"\\n  symbol: String\\n  \"Registry for filtering purposes.\"\\n  filterRegistry: Bytes\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: _FlashLoanPremium\"\\ntype _FlashLoanPremium @entity {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: premiumRateTotal\"\\n  premiumRateTotal: BigDecimal!\\n  \"Description for column: premiumRateToProtocol\"\\n  premiumRateToProtocol: BigDecimal!\\n}', 'documented_schema': 'type _FlashLoanPremium @entity {\\n  \" protocol id \"\\n  id: Bytes!\\n  \" total premium rate \"\\n  premiumRateTotal: BigDecimal!\\n  \" premium rate to protocol \"\\n  premiumRateToProtocol: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `_FlashLoanPremium`, with three fields. Each field is already accompanied by a description, which is concise and directly related to the field it describes. The task is to ensure that these descriptions are clear and factual, without altering the underlying schema or adding unnecessary information.',\n    documented_schema='\"Description for table: _FlashLoanPremium\"\\ntype _FlashLoanPremium @entity {\\n  \"Unique identifier for the flash loan premium entry\"\\n  id: Bytes!\\n  \"Total premium rate applied to the flash loan\"\\n  premiumRateTotal: BigDecimal!\\n  \"Portion of the premium rate allocated to the protocol\"\\n  premiumRateToProtocol: BigDecimal!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for enum type: DisputeStatus\"\\nenum DisputeStatus {\\n  \"Description for column: Undecided\"\\n  Undecided\\n  \"Description for column: Accepted\"\\n  Accepted\\n  \"Description for column: Rejected\"\\n  Rejected\\n  \"Description for column: Draw\"\\n  Draw\\n}', 'documented_schema': 'enum DisputeStatus {\\n  Undecided\\n  Accepted\\n  Rejected\\n  Draw\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema is an enumeration type named `DisputeStatus` with four possible values: `Undecided`, `Accepted`, `Rejected`, and `Draw`. Each value has a brief description indicating its role or meaning within the context of the enumeration. The task is to ensure that these descriptions are properly documented without altering the underlying schema structure.',\n    documented_schema='\"Description for enum type: DisputeStatus\"\\nenum DisputeStatus {\\n  \"Undecided status of the dispute\"\\n  Undecided\\n  \"Accepted status of the dispute\"\\n  Accepted\\n  \"Rejected status of the dispute\"\\n  Rejected\\n  \"Draw status of the dispute\"\\n  Draw\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for enum type: Network\"\\nenum Network {\\n  \"Description for column: ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"Description for column: ARWEAVE_MAINNET\"\\n  ARWEAVE_MAINNET\\n  \"Description for column: AURORA\"\\n  AURORA\\n  \"Description for column: AVALANCHE\"\\n  AVALANCHE\\n  \"Description for column: BOBA\"\\n  BOBA\\n  \"Description for column: BSC\"\\n  BSC\\n  \"Description for column: CELO\"\\n  CELO\\n  \"Description for column: COSMOS\"\\n  COSMOS\\n  \"Description for column: CRONOS\"\\n  CRONOS\\n  \"Description for column: MAINNET\"\\n  MAINNET\\n  \"Description for column: FANTOM\"\\n  FANTOM\\n  \"Description for column: FUSE\"\\n  FUSE\\n  \"Description for column: HARMONY\"\\n  HARMONY\\n  \"Description for column: JUNO\"\\n  JUNO\\n  \"Description for column: MOONBEAM\"\\n  MOONBEAM\\n  \"Description for column: MOONRIVER\"\\n  MOONRIVER\\n  \"Description for column: NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"Description for column: OPTIMISM\"\\n  OPTIMISM\\n  \"Description for column: OSMOSIS\"\\n  OSMOSIS\\n  \"Description for column: MATIC\"\\n  MATIC\\n  \"Description for column: XDAI\"\\n  XDAI\\n}', 'documented_schema': '\" Represents the blockchain network that the data is being collected from. \"\\nenum Network {\\n  \" The Arbitrum One network. \"\\n  ARBITRUM_ONE\\n  \" The Arweave Mainnet. \"\\n  ARWEAVE_MAINNET\\n  \" The Aurora network. \"\\n  AURORA\\n  \" The Avalanche network. \"\\n  AVALANCHE\\n  \" The Boba network. \"\\n  BOBA\\n  \" The Binance Smart Chain network (aka BNB Chain). \"\\n  BSC\\n  \" The Celo network. \"\\n  CELO\\n  \" The Cosmos network. \"\\n  COSMOS\\n  \" The Cronos network. \"\\n  CRONOS\\n  \" The Ethereum Mainnet. \"\\n  MAINNET\\n  \" The Fantom network. \"\\n  FANTOM\\n  \" The Fuse network. \"\\n  FUSE\\n  \" The Harmony network. \"\\n  HARMONY\\n  \" The Juno network. \"\\n  JUNO\\n  \" The Moonbeam network. \"\\n  MOONBEAM\\n  \" The Moonriver network. \"\\n  MOONRIVER\\n  \" The NEAR Mainnet. \"\\n  NEAR_MAINNET\\n  \" The Optimism network. \"\\n  OPTIMISM\\n  \" The Osmosis network. \"\\n  OSMOSIS\\n  \" The Matic network (aka Polygon). \"\\n  MATIC\\n  \" The xDai network (aka Gnosis Chain). \"\\n  XDAI\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines an enum type named `Network`, which includes various blockchain networks as its values. Each value in the enum is already accompanied by a description that follows the format \"Description for column: {VALUE}\". The task is to ensure that these descriptions are concise and factual, focusing on the specific network each enum value represents. The descriptions should be formatted correctly to maintain the schema\\'s documentation style.',\n    documented_schema='\"Description for enum type: Network\"\\nenum Network {\\n  \"Represents the Arbitrum One network\"\\n  ARBITRUM_ONE\\n  \"Represents the Arweave Mainnet network\"\\n  ARWEAVE_MAINNET\\n  \"Represents the Aurora network\"\\n  AURORA\\n  \"Represents the Avalanche network\"\\n  AVALANCHE\\n  \"Represents the Boba network\"\\n  BOBA\\n  \"Represents the Binance Smart Chain (BSC) network\"\\n  BSC\\n  \"Represents the Celo network\"\\n  CELO\\n  \"Represents the Cosmos network\"\\n  COSMOS\\n  \"Represents the Cronos network\"\\n  CRONOS\\n  \"Represents the Ethereum Mainnet\"\\n  MAINNET\\n  \"Represents the Fantom network\"\\n  FANTOM\\n  \"Represents the Fuse network\"\\n  FUSE\\n  \"Represents the Harmony network\"\\n  HARMONY\\n  \"Represents the Juno network\"\\n  JUNO\\n  \"Represents the Moonbeam network\"\\n  MOONBEAM\\n  \"Represents the Moonriver network\"\\n  MOONRIVER\\n  \"Represents the NEAR Mainnet network\"\\n  NEAR_MAINNET\\n  \"Represents the Optimism network\"\\n  OPTIMISM\\n  \"Represents the Osmosis network\"\\n  OSMOSIS\\n  \"Represents the Polygon (Matic) network\"\\n  MATIC\\n  \"Represents the xDai network\"\\n  XDAI\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: GraphAccount\"\\ntype GraphAccount @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: names\"\\n  names: [GraphAccountName!]! @derivedFrom(field: \"graphAccount\")\\n  \"Description for column: defaultName\"\\n  defaultName: GraphAccountName\\n  \"Description for column: createdAt\"\\n  createdAt: Int!\\n  \"Description for column: defaultDisplayName\"\\n  defaultDisplayName: String\\n  \"Description for column: metadata\"\\n  metadata: GraphAccountMeta\\n  \"Description for column: operatorOf\"\\n  operatorOf: [GraphAccount!]! @derivedFrom(field: \"operators\")\\n  \"Description for column: operators\"\\n  operators: [GraphAccount!]!\\n  \"Description for column: balance\"\\n  balance: BigInt!\\n  \"Description for column: balanceReceivedFromL1Signalling\"\\n  balanceReceivedFromL1Signalling: BigInt!\\n  \"Description for column: balanceReceivedFromL1Delegation\"\\n  balanceReceivedFromL1Delegation: BigInt!\\n  \"Description for column: curationApproval\"\\n  curationApproval: BigInt!\\n  \"Description for column: stakingApproval\"\\n  stakingApproval: BigInt!\\n  \"Description for column: gnsApproval\"\\n  gnsApproval: BigInt!\\n  \"Description for column: subgraphs\"\\n  subgraphs: [Subgraph!]! @derivedFrom(field: \"owner\")\\n  \"Description for column: developerCreatedAt\"\\n  developerCreatedAt: Int\\n  \"Description for column: subgraphQueryFees\"\\n  subgraphQueryFees: BigInt!\\n  \"Description for column: createdDisputes\"\\n  createdDisputes: [Dispute!]! @derivedFrom(field: \"fisherman\")\\n  \"Description for column: disputesAgainst\"\\n  disputesAgainst: [Dispute!]! @derivedFrom(field: \"indexer\")\\n  \"Description for column: curator\"\\n  curator: Curator\\n  \"Description for column: indexer\"\\n  indexer: Indexer\\n  \"Description for column: delegator\"\\n  delegator: Delegator\\n  \"Description for column: nameSignalTransactions\"\\n  nameSignalTransactions: [NameSignalTransaction!]! @derivedFrom(field: \"signer\")\\n  \"Description for column: bridgeWithdrawalTransactions\"\\n  bridgeWithdrawalTransactions: [BridgeWithdrawalTransaction!]! @derivedFrom(field: \"signer\")\\n  \"Description for column: bridgeDepositTransactions\"\\n  bridgeDepositTransactions: [BridgeDepositTransaction!]! @derivedFrom(field: \"signer\")\\n  \"Description for column: tokenLockWallets\"\\n  tokenLockWallets: [TokenLockWallet!]!\\n}', 'documented_schema': '\"\"\"\\nAn account within the graph network. Contains metadata and all relevant data for this accounts\\ndelegating, curating, and indexing.\\n\"\"\"\\ntype GraphAccount @entity {\\n  \"Graph account ID\"\\n  id: ID!\\n  \"All names this graph account has claimed from all name systems\"\\n  names: [GraphAccountName!]! @derivedFrom(field: \"graphAccount\")\\n  \"Default name the graph account has chosen\"\\n  defaultName: GraphAccountName\\n  \"Time the account was created\"\\n  createdAt: Int!\\n  \"Default display name is the current default name. Used for filtered queries in the explorer\"\\n  defaultDisplayName: String\\n  metadata: GraphAccountMeta\\n  \"Operator of other Graph Accounts\"\\n  operatorOf: [GraphAccount!]! @derivedFrom(field: \"operators\")\\n  \"Operators of this Graph Accounts\"\\n  operators: [GraphAccount!]!\\n  \"Graph token balance\"\\n  balance: BigInt!\\n  \"Balance received due to failed signal transfer from L1\"\\n  balanceReceivedFromL1Signalling: BigInt!\\n  \"Balance received due to failed delegation transfer from L1\"\\n  balanceReceivedFromL1Delegation: BigInt!\\n  \"Amount this account has approved staking to transfer their GRT\"\\n  curationApproval: BigInt!\\n  \"Amount this account has approved curation to transfer their GRT\"\\n  stakingApproval: BigInt!\\n  \"Amount this account has approved the GNS to transfer their GRT\"\\n  gnsApproval: BigInt!\\n  \"Subgraphs the graph account owns\"\\n  subgraphs: [Subgraph!]! @derivedFrom(field: \"owner\")\\n  \"Time that this graph account became a developer\"\\n  developerCreatedAt: Int\\n  \"NOT IMPLEMENTED - Total query fees the subgraphs created by this account have accumulated in GRT\"\\n  subgraphQueryFees: BigInt!\\n  \"Disputes this graph account has created\"\\n  createdDisputes: [Dispute!]! @derivedFrom(field: \"fisherman\")\\n  \"Disputes against this graph account\"\\n  disputesAgainst: [Dispute!]! @derivedFrom(field: \"indexer\")\\n  \"Curator fields for this GraphAccount. Null if never curated\"\\n  curator: Curator\\n  \"Indexer fields for this GraphAccount. Null if never indexed\"\\n  indexer: Indexer\\n  \"Delegator fields for this GraphAccount. Null if never delegated\"\\n  delegator: Delegator\\n  \"Name signal transactions created by this GraphAccount\"\\n  nameSignalTransactions: [NameSignalTransaction!]! @derivedFrom(field: \"signer\")\\n  bridgeWithdrawalTransactions: [BridgeWithdrawalTransaction!]! @derivedFrom(field: \"signer\")\\n  bridgeDepositTransactions: [BridgeDepositTransaction!]! @derivedFrom(field: \"signer\")\\n  tokenLockWallets: [TokenLockWallet!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `GraphAccount` with various fields, each having a specific type and some with directives like `@derivedFrom`. The task is to document each field with a concise description based on the information given in the schema. The descriptions should be factual and directly related to the field's purpose or data type, without adding speculative or extraneous information. The documentation should be formatted correctly to ensure clarity and maintain the schema's integrity.\",\n    documented_schema='\"Description for table: GraphAccount\"\\ntype GraphAccount @entity {\\n  \"Unique identifier for the account\"\\n  id: ID!\\n  \"List of names associated with the account, derived from the graphAccount field\"\\n  names: [GraphAccountName!]! @derivedFrom(field: \"graphAccount\")\\n  \"The default name for the account\"\\n  defaultName: GraphAccountName\\n  \"Timestamp of when the account was created\"\\n  createdAt: Int!\\n  \"The default display name for the account\"\\n  defaultDisplayName: String\\n  \"Metadata associated with the account\"\\n  metadata: GraphAccountMeta\\n  \"Accounts operated by this account, derived from the operators field\"\\n  operatorOf: [GraphAccount!]! @derivedFrom(field: \"operators\")\\n  \"List of accounts that operate this account\"\\n  operators: [GraphAccount!]!\\n  \"Current balance of the account\"\\n  balance: BigInt!\\n  \"Balance received from L1 signalling\"\\n  balanceReceivedFromL1Signalling: BigInt!\\n  \"Balance received from L1 delegation\"\\n  balanceReceivedFromL1Delegation: BigInt!\\n  \"Approval amount for curation\"\\n  curationApproval: BigInt!\\n  \"Approval amount for staking\"\\n  stakingApproval: BigInt!\\n  \"Approval amount for GNS\"\\n  gnsApproval: BigInt!\\n  \"Subgraphs owned by the account, derived from the owner field\"\\n  subgraphs: [Subgraph!]! @derivedFrom(field: \"owner\")\\n  \"Timestamp of when the developer was created\"\\n  developerCreatedAt: Int\\n  \"Fees from subgraph queries\"\\n  subgraphQueryFees: BigInt!\\n  \"Disputes created by the account, derived from the fisherman field\"\\n  createdDisputes: [Dispute!]! @derivedFrom(field: \"fisherman\")\\n  \"Disputes against the account, derived from the indexer field\"\\n  disputesAgainst: [Dispute!]! @derivedFrom(field: \"indexer\")\\n  \"Curator associated with the account\"\\n  curator: Curator\\n  \"Indexer associated with the account\"\\n  indexer: Indexer\\n  \"Delegator associated with the account\"\\n  delegator: Delegator\\n  \"Transactions related to name signalling, derived from the signer field\"\\n  nameSignalTransactions: [NameSignalTransaction!]! @derivedFrom(field: \"signer\")\\n  \"Transactions for bridge withdrawals, derived from the signer field\"\\n  bridgeWithdrawalTransactions: [BridgeWithdrawalTransaction!]! @derivedFrom(field: \"signer\")\\n  \"Transactions for bridge deposits, derived from the signer field\"\\n  bridgeDepositTransactions: [BridgeDepositTransaction!]! @derivedFrom(field: \"signer\")\\n  \"Wallets with token locks associated with the account\"\\n  tokenLockWallets: [TokenLockWallet!]!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: PositionSnapshot\"\\ntype PositionSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hash\"\\n  hash: Bytes!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: nonce\"\\n  nonce: BigInt!\\n  \"Description for column: position\"\\n  position: Position!\\n  \"Description for column: liquidityTokenType\"\\n  liquidityTokenType: TokenType\\n  \"Description for column: liquidity\"\\n  liquidity: BigInt\\n  \"Description for column: liquidityUSD\"\\n  liquidityUSD: BigDecimal\\n  \"Description for column: cumulativeDepositTokenAmounts\"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \"Description for column: cumulativeDepositUSD\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Description for column: cumulativeWithdrawTokenAmounts\"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \"Description for column: cumulativeWithdrawUSD\"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \"Description for column: cumulativeRewardTokenAmounts\"\\n  cumulativeRewardTokenAmounts: [BigInt!]\\n  \"Description for column: cumulativeRewardUSD\"\\n  cumulativeRewardUSD: [BigInt!]\\n  \"Description for column: depositCount\"\\n  depositCount: Int!\\n  \"Description for column: withdrawCount\"\\n  withdrawCount: Int!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}', 'documented_schema': 'type PositionSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \" { Position ID }-{ Transaction hash }-{ Log index } \"\\n  id: Bytes!\\n  \" Transaction hash of the transaction that triggered this snapshot \"\\n  hash: Bytes!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" Nonce of the transaction that triggered this snapshot \"\\n  nonce: BigInt!\\n  \" Position of this snapshot \"\\n  position: Position!\\n  \" Type of token used to track liquidity \"\\n  liquidityTokenType: TokenType\\n  \" total position liquidity \"\\n  liquidity: BigInt\\n  \" total position liquidity in USD \"\\n  liquidityUSD: BigDecimal\\n  \" amount of tokens ever deposited to position \"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \" amount of tokens in USD deposited to position \"\\n  cumulativeDepositUSD: BigDecimal!\\n  \" amount of tokens ever withdrawn from position (without fees) \"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \" amount of tokens in USD withdrawn from position (without fees) \"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \" Total reward token accumulated under this position, in native amounts \"\\n  cumulativeRewardTokenAmounts: [BigInt!]\\n  \" Total reward token accumulated under this position, in USD \"\\n  cumulativeRewardUSD: [BigInt!]\\n  \" Number of deposits related to this position \"\\n  depositCount: Int!\\n  \" Number of withdrawals related to this position \"\\n  withdrawCount: Int!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The task requires adding precise descriptions to each column in the `PositionSnapshot` table based on the provided GraphQL schema. The descriptions should be factual and concise, focusing on the role or type of data each column holds. The schema already includes placeholder descriptions, so the task involves refining these to be more informative while maintaining the structure and format of the schema.',\n    documented_schema='\"Description for table: PositionSnapshot\"\\ntype PositionSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Unique identifier for the position snapshot, stored as bytes.\"\\n  id: Bytes!\\n  \"Hash of the transaction associated with the position snapshot, stored as bytes.\"\\n  hash: Bytes!\\n  \"Index of the log entry within the block, stored as an integer.\"\\n  logIndex: Int!\\n  \"Nonce value for the transaction, stored as a big integer.\"\\n  nonce: BigInt!\\n  \"Reference to the position entity associated with this snapshot.\"\\n  position: Position!\\n  \"Type of liquidity token, represented by the TokenType enum.\"\\n  liquidityTokenType: TokenType\\n  \"Amount of liquidity in the position, stored as a big integer.\"\\n  liquidity: BigInt\\n  \"Value of the liquidity in USD, stored as a big decimal.\"\\n  liquidityUSD: BigDecimal\\n  \"Cumulative amounts of deposit tokens, stored as an array of big integers.\"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \"Cumulative value of deposits in USD, stored as a big decimal.\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Cumulative amounts of withdrawn tokens, stored as an array of big integers.\"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \"Cumulative value of withdrawals in USD, stored as a big decimal.\"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \"Cumulative amounts of reward tokens, stored as an array of big integers.\"\\n  cumulativeRewardTokenAmounts: [BigInt!]\\n  \"Cumulative value of rewards in USD, stored as an array of big integers.\"\\n  cumulativeRewardUSD: [BigInt!]\\n  \"Total number of deposit transactions, stored as an integer.\"\\n  depositCount: Int!\\n  \"Total number of withdrawal transactions, stored as an integer.\"\\n  withdrawCount: Int!\\n  \"Block number at which the snapshot was taken, stored as a big integer.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of the snapshot, stored as a big integer.\"\\n  timestamp: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: SupportedToken\"\\ntype SupportedToken @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: Bytes!\\n}', 'documented_schema': 'type SupportedToken @entity(immutable: true) {\\n  id: Bytes!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `SupportedToken`, with one field, `id`. The task is to generate a precise description for the `id` field based on the information given. The `id` field is of type `Bytes!`, indicating it is a non-nullable field that stores binary data. The description should reflect this information accurately.',\n    documented_schema='\"Description for table: SupportedToken\"\\ntype SupportedToken @entity(immutable: true) {\\n  \"Unique identifier for the supported token, stored as binary data.\"\\n  id: Bytes!\\n}'\n)",
      4
    ],
    [
      "Example({'database_schema': '\"Description for table: GatedSale\"\\ntype GatedSale @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: editionId\"\\n  editionId: String!\\n  \"Description for column: paused\"\\n  paused: Boolean!\\n  \"Description for column: primarySaleCommission\"\\n  primarySaleCommission: BigInt!\\n  \"Description for column: artistAccount\"\\n  artistAccount: String\\n  \"Description for column: mintCount\"\\n  mintCount: BigInt!\\n  \"Description for column: phases\"\\n  phases: [Phase!]!\\n}', 'documented_schema': '\" A table of gated sale. A gate sale configuration - one per edition. \"\\ntype GatedSale @entity {\\n  \" The unique identifier for the gated sale. This is the ID of the gated sale. Type: ID! \"\\n  id: ID!\\n  \" The edition. This is the edition the sale will mint. Type: String! \"\\n  editionId: String!\\n  \" The paused flag. This is a boolean that indicates if the sale is currently paused. Type: Boolean! \"\\n  paused: Boolean!\\n  \" The primary sale commission. This is the overridden sales commission for KO. Type: BigInt! \"\\n  primarySaleCommission: BigInt!\\n  \" The artist account. This is the address of the artist associated with the given edition ID. Type: String! \"\\n  artistAccount: String\\n  \" The mint count. This is the total mint current for the sale. Type: BigInt! \"\\n  mintCount: BigInt!\\n  \" The phases. This is an array of phases associated with the sale. Type: [Phase!]! \"\\n  phases: [Phase!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `GatedSale` with several fields, each having a specific data type and a brief description. The task is to ensure that each field is documented with a concise and factual description based on the information given in the schema. The descriptions should be clear and directly related to the field's purpose or data type.\",\n    documented_schema='\"Description for table: GatedSale\"\\ntype GatedSale @entity {\\n  \"Unique identifier for the GatedSale\"\\n  id: ID!\\n  \"Identifier for the edition associated with the GatedSale\"\\n  editionId: String!\\n  \"Indicates whether the GatedSale is paused\"\\n  paused: Boolean!\\n  \"Commission amount for the primary sale, represented as a BigInt\"\\n  primarySaleCommission: BigInt!\\n  \"Account of the artist associated with the GatedSale\"\\n  artistAccount: String\\n  \"Number of mints that have occurred\"\\n  mintCount: BigInt!\\n  \"List of phases associated with the GatedSale\"\\n  phases: [Phase!]!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Pool\"\\ntype Pool @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: protocol\"\\n  protocol: BridgeProtocol!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: relation\"\\n  relation: Bytes\\n  \"Description for column: type\"\\n  type: BridgePoolType!\\n  \"Description for column: inputToken\"\\n  inputToken: Token!\\n  \"Description for column: destinationTokens\"\\n  destinationTokens: [CrosschainToken!]!\\n  \"Description for column: routes\"\\n  routes: [PoolRoute!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: rewardTokens\"\\n  rewardTokens: [RewardToken!]\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: createdBlockNumber\"\\n  createdBlockNumber: BigInt!\\n  \"Description for column: mintSupply\"\\n  mintSupply: BigInt\\n  \"Description for column: inputTokenBalance\"\\n  inputTokenBalance: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: netValueExportedUSD\"\\n  netValueExportedUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeIn\"\\n  cumulativeVolumeIn: BigInt!\\n  \"Description for column: cumulativeVolumeOut\"\\n  cumulativeVolumeOut: BigInt!\\n  \"Description for column: netVolume\"\\n  netVolume: BigInt!\\n  \"Description for column: cumulativeVolumeInUSD\"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeOutUSD\"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n  \"Description for column: netVolumeUSD\"\\n  netVolumeUSD: BigDecimal!\\n  \"Description for column: outputTokenSupply\"\\n  outputTokenSupply: BigInt\\n  \"Description for column: outputTokenPriceUSD\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"Description for column: dailySnapshots\"\\n  dailySnapshots: [PoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: hourlySnapshots\"\\n  hourlySnapshots: [PoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: _lastDailySnapshotTimestamp\"\\n  _lastDailySnapshotTimestamp: BigInt\\n  \"Description for column: _lastHourlySnapshotTimestamp\"\\n  _lastHourlySnapshotTimestamp: BigInt\\n  \"Description for column: _inputTokenLiquidityBalance\"\\n  _inputTokenLiquidityBalance: BigInt\\n}', 'documented_schema': 'type Pool @entity @regularPolling {\\n  \" Smart contract address of the pool \"\\n  id: Bytes!\\n  \" The protocol this pool belongs to \"\\n  protocol: BridgeProtocol!\\n  \" Name of the pool (e.g. Curve.fi DAI/USDC/USDT) \"\\n  name: String\\n  \" Symbol of liquidity pool (e.g. 3CRV) \"\\n  symbol: String\\n  \" A unique identifier that can relate multiple pools together. e.g. a common address that they all share. This is useful for pools with multiple input tokens \"\\n  relation: Bytes\\n  \" The type of the pool, determined by the type of the input tokens. \"\\n  type: BridgePoolType!\\n  \" Tokens that can be bridged from and to this pool \"\\n  inputToken: Token!\\n  \" Equivalent to inputTokens but in the other networks \"\\n  destinationTokens: [CrosschainToken!]!\\n  \" Info about pool usage to and from each chain the pool is connected to \"\\n  routes: [PoolRoute!]!\\n  \" Token that is minted to track ownership of a liquidity position, if the pool is liquidity based. \"\\n  outputToken: Token\\n  \" Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon \"\\n  rewardTokens: [RewardToken!]\\n  \" Creation timestamp \"\\n  createdTimestamp: BigInt!\\n  \" Creation block number \"\\n  createdBlockNumber: BigInt!\\n  \" Only for MINT/BURN pools: the current supply of the minted token on this chain. \"\\n  mintSupply: BigInt\\n  \" Amount of input tokens in the pool \"\\n  inputTokenBalance: BigInt!\\n  \" Current TVL (Total Value Locked) of this pool in USD (only applies to LOCK_RELEASE and LIQUIDITY pools)\"\\n  totalValueLockedUSD: BigDecimal!\\n  \" USD value of all assets bridged into or away from this chain through this pool. For mint/burn pools, this is the USD value of the minted supplies. For lock/release pools, this is the USD value of the input token balance. \"\\n  netValueExportedUSD: BigDecimal!\\n  \" All revenue generated by the pool, from transactions originating in this network, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the pool, from transactions originating in this network, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Total volume bridged to this pool in token amounts \"\\n  cumulativeVolumeIn: BigInt!\\n  \" Total volume bridged from this pool in token amounts \"\\n  cumulativeVolumeOut: BigInt!\\n  \" cumulativeIn - cumulativeOut \"\\n  netVolume: BigInt!\\n  \" Total volume bridged to this pool in USD \"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \" Total volume bridged from this pool in USD \"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n  \" cumulativeInUSD - cumulativeOutUSD \"\\n  netVolumeUSD: BigDecimal!\\n  \" Total supply of output token. \"\\n  outputTokenSupply: BigInt\\n  \" Price per share of output token in USD \"\\n  outputTokenPriceUSD: BigDecimal\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day, in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \" Pool daily snapshots \"\\n  dailySnapshots: [PoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" Pool hourly snapshots \"\\n  hourlySnapshots: [PoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  _lastDailySnapshotTimestamp: BigInt\\n  _lastHourlySnapshotTimestamp: BigInt\\n  \" Internal field for the SDK to be able to calculate total value imported/exported for liquidity based pools \"\\n  _inputTokenLiquidityBalance: BigInt\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type named `Pool` with various fields, each having a specific data type and some with non-null constraints. The task is to generate concise and factual descriptions for each field based on the information given in the schema. The descriptions should be clear and directly related to the field's purpose or data type, without adding any speculative or additional commentary. The documentation should be formatted correctly to ensure clarity and maintain the structure of the schema.\",\n    documented_schema='\"Description for table: Pool\"\\ntype Pool @entity @regularPolling {\\n  \"Unique identifier for the pool\"\\n  id: Bytes!\\n  \"Protocol associated with the pool\"\\n  protocol: BridgeProtocol!\\n  \"Name of the pool\"\\n  name: String\\n  \"Symbol representing the pool\"\\n  symbol: String\\n  \"Relation identifier in bytes\"\\n  relation: Bytes\\n  \"Type of the bridge pool\"\\n  type: BridgePoolType!\\n  \"Token used as input in the pool\"\\n  inputToken: Token!\\n  \"Tokens available as destinations in cross-chain operations\"\\n  destinationTokens: [CrosschainToken!]!\\n  \"Routes associated with the pool\"\\n  routes: [PoolRoute!]!\\n  \"Token output from the pool\"\\n  outputToken: Token\\n  \"Tokens given as rewards\"\\n  rewardTokens: [RewardToken!]\\n  \"Timestamp when the pool was created\"\\n  createdTimestamp: BigInt!\\n  \"Block number at the time of pool creation\"\\n  createdBlockNumber: BigInt!\\n  \"Total supply of minted tokens\"\\n  mintSupply: BigInt\\n  \"Balance of the input token\"\\n  inputTokenBalance: BigInt!\\n  \"Total value locked in USD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Net value exported in USD\"\\n  netValueExportedUSD: BigDecimal!\\n  \"Cumulative revenue from the supply side in USD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue from the protocol side in USD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Cumulative total revenue in USD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Cumulative volume of tokens entering the pool\"\\n  cumulativeVolumeIn: BigInt!\\n  \"Cumulative volume of tokens exiting the pool\"\\n  cumulativeVolumeOut: BigInt!\\n  \"Net volume of tokens\"\\n  netVolume: BigInt!\\n  \"Cumulative volume of tokens entering the pool in USD\"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \"Cumulative volume of tokens exiting the pool in USD\"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n  \"Net volume in USD\"\\n  netVolumeUSD: BigDecimal!\\n  \"Supply of the output token\"\\n  outputTokenSupply: BigInt\\n  \"Price of the output token in USD\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"Amount of output tokens staked\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Amount of reward tokens emitted\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Value of reward token emissions in USD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"Daily snapshots of the pool\\'s state\"\\n  dailySnapshots: [PoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Hourly snapshots of the pool\\'s state\"\\n  hourlySnapshots: [PoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Timestamp of the last daily snapshot\"\\n  _lastDailySnapshotTimestamp: BigInt\\n  \"Timestamp of the last hourly snapshot\"\\n  _lastHourlySnapshotTimestamp: BigInt\\n  \"Liquidity balance of the input token\"\\n  _inputTokenLiquidityBalance: BigInt\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: AuctionEvent\"\\ntype AuctionEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: bidder\"\\n  bidder: Bytes!\\n  \"Description for column: caller\"\\n  caller: Bytes!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: lockupUntil\"\\n  lockupUntil: BigInt\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}', 'documented_schema': '\" A table of auction events. An auction event is an event that occurs when a token is auctioned. \"\\ntype AuctionEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. \"\\n  id: ID!\\n  \" The schema version of the event being used. \"\\n  version: BigInt!\\n  \" The edition of the event. \"\\n  edition: Edition!\\n  \" The name of the event. \"\\n  name: String!\\n  \" The bidder of the event. \"\\n  bidder: Bytes!\\n  \" The caller of the event. \"\\n  caller: Bytes!\\n  \" The value of the event in ETH. \"\\n  ethValue: BigDecimal!\\n  \" The lockup until of the event. \"\\n  lockupUntil: BigInt\\n  \" The timestamp of the event. \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. \"\\n  logIndex: BigInt!\\n  \" The address of the event. \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. \"\\n  blockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines an `AuctionEvent` entity with various fields, each having a specific data type. The task is to document each field with a concise and factual description based on the information given in the schema. The descriptions should be clear and directly related to the field's purpose or data type, without adding any speculative or additional commentary.\",\n    documented_schema='\"Description for table: AuctionEvent\"\\ntype AuctionEvent @entity(immutable: true) {\\n  \"Unique identifier for the auction event.\"\\n  id: ID!\\n  \"Version number of the auction event.\"\\n  version: BigInt!\\n  \"Reference to the edition associated with the auction event.\"\\n  edition: Edition!\\n  \"Name of the auction event.\"\\n  name: String!\\n  \"Address of the bidder in the auction event.\"\\n  bidder: Bytes!\\n  \"Address of the caller who initiated the auction event.\"\\n  caller: Bytes!\\n  \"Value in Ether associated with the auction event.\"\\n  ethValue: BigDecimal!\\n  \"Timestamp until which the auction event is locked up.\"\\n  lockupUntil: BigInt\\n  \"Timestamp when the auction event occurred.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction related to the auction event.\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block.\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry within the transaction.\"\\n  logIndex: BigInt!\\n  \"Address where the auction event took place.\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction originated.\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent.\"\\n  eventTxTo: Bytes\\n  \"Block number in which the auction event was recorded.\"\\n  blockNumber: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: symbol\"\\n  symbol: String!\\n  \"Description for column: decimals\"\\n  decimals: Int!\\n  \"Description for column: lastPriceUSD\"\\n  lastPriceUSD: BigDecimal\\n  \"Description for column: lastPriceBlockNumber\"\\n  lastPriceBlockNumber: BigInt\\n  \"Description for column: _lastPricePool\"\\n  _lastPricePool: Bytes\\n  \"Description for column: _totalSupply\"\\n  _totalSupply: BigInt!\\n  \"Description for column: _totalValueLockedUSD\"\\n  _totalValueLockedUSD: BigDecimal!\\n  \"Description for column: _largePriceChangeBuffer\"\\n  _largePriceChangeBuffer: Int!\\n  \"Description for column: _largeTVLImpactBuffer\"\\n  _largeTVLImpactBuffer: Int!\\n}', 'documented_schema': '\" Token entity for the schema \"\\ntype Token @entity @regularPolling {\\n  \" Smart contract address of the token \"\\n  id: Bytes!\\n  \" Name of the token, mirrored from the smart contract \"\\n  name: String!\\n  \" Symbol of the token, mirrored from the smart contract \"\\n  symbol: String!\\n  \" The number of decimal places this token uses, default to 18 \"\\n  decimals: Int!\\n  \" Optional field to track the price of a token, mostly for caching purposes \"\\n  lastPriceUSD: BigDecimal\\n  \" Optional field to track the block number of the last token price \"\\n  lastPriceBlockNumber: BigInt\\n  \" last pool that gave this token a price \"\\n  _lastPricePool: Bytes\\n  \" amount of tokens in the protocol \"\\n  _totalSupply: BigInt!\\n  \" Total value locked in the protocol \"\\n  _totalValueLockedUSD: BigDecimal!\\n  _largePriceChangeBuffer: Int!\\n  _largeTVLImpactBuffer: Int!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a `Token` entity with various fields, each having a specific data type and some marked as non-nullable with an exclamation mark. The task is to generate concise and factual descriptions for each field based on their names and types, without altering the schema structure. The descriptions should be clear and informative, reflecting the purpose or nature of each field.',\n    documented_schema='\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Unique identifier for the token, stored as bytes.\"\\n  id: Bytes!\\n  \"The name of the token.\"\\n  name: String!\\n  \"The symbol representing the token.\"\\n  symbol: String!\\n  \"The number of decimal places used by the token.\"\\n  decimals: Int!\\n  \"The last recorded price of the token in USD.\"\\n  lastPriceUSD: BigDecimal\\n  \"The block number at which the last price was recorded.\"\\n  lastPriceBlockNumber: BigInt\\n  \"Reference to the pool used for the last price calculation, stored as bytes.\"\\n  _lastPricePool: Bytes\\n  \"The total supply of the token.\"\\n  _totalSupply: BigInt!\\n  \"The total value locked in USD for the token.\"\\n  _totalValueLockedUSD: BigDecimal!\\n  \"Buffer value for handling large price changes.\"\\n  _largePriceChangeBuffer: Int!\\n  \"Buffer value for handling large impacts on total value locked.\"\\n  _largeTVLImpactBuffer: Int!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: NewRoundEvent\"\\ntype NewRoundEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: blockHash\"\\n  blockHash: String!\\n}', 'documented_schema': '\"\"\"NewRoundEvent entities are created for every emitted NewRound event.\"\"\"\\ntype NewRoundEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  \"Block hash for the round\"\\n  blockHash: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `NewRoundEvent` that implements an `Event` interface. Each field within this type is documented with a brief description. The fields include `id`, `transaction`, `timestamp`, `round`, and `blockHash`. The descriptions are straightforward, indicating the purpose or nature of each field. The `id` is a unique identifier, `transaction` is a reference to a `Transaction` type, `timestamp` is an integer likely representing a point in time, `round` is a reference to a `Round` type, and `blockHash` is a string representing a hash value. The task is to ensure these descriptions are clear and concise without altering the schema structure.',\n    documented_schema='\"Description for table: NewRoundEvent\"\\ntype NewRoundEvent implements Event @entity {\\n  \"Unique identifier for the event\"\\n  id: ID!\\n  \"Associated transaction for the event\"\\n  transaction: Transaction!\\n  \"Timestamp of when the event occurred\"\\n  timestamp: Int!\\n  \"Round information related to the event\"\\n  round: Round!\\n  \"Hash of the block containing the event\"\\n  blockHash: String!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Day\"\\ntype Day @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: date\"\\n  date: String!\\n  \"Description for column: transferCount\"\\n  transferCount: BigInt!\\n  \"Description for column: editionsCount\"\\n  editionsCount: BigInt!\\n  \"Description for column: bidsAcceptedCount\"\\n  bidsAcceptedCount: BigInt!\\n  \"Description for column: bidsPlacedCount\"\\n  bidsPlacedCount: BigInt!\\n  \"Description for column: bidsRejectedCount\"\\n  bidsRejectedCount: BigInt!\\n  \"Description for column: bidsWithdrawnCount\"\\n  bidsWithdrawnCount: BigInt!\\n  \"Description for column: bidsIncreasedCount\"\\n  bidsIncreasedCount: BigInt!\\n  \"Description for column: totalValuePlaceInBids\"\\n  totalValuePlaceInBids: BigDecimal!\\n  \"Description for column: totalValueCycledInBids\"\\n  totalValueCycledInBids: BigDecimal!\\n  \"Description for column: secondarySalesValue\"\\n  secondarySalesValue: BigDecimal!\\n  \"Description for column: issuedCount\"\\n  issuedCount: BigInt!\\n  \"Description for column: salesCount\"\\n  salesCount: BigInt!\\n  \"Description for column: totalValueInEth\"\\n  totalValueInEth: BigDecimal!\\n  \"Description for column: highestValueInEth\"\\n  highestValueInEth: BigDecimal!\\n  \"Description for column: highestValueToken\"\\n  highestValueToken: Token\\n  \"Description for column: issued\"\\n  issued: [Token!]!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n}', 'documented_schema': '\" A table of day events. A day event is an event that occurs when a day is rolled up. \"\\ntype Day @entity {\\n  \" The unique identifier for the event. \"\\n  id: ID!\\n  \" The date of the event. \"\\n  date: String!\\n  \" The transfer count during the day. \"\\n  transferCount: BigInt!\\n  \" The editions count during the day. \"\\n  editionsCount: BigInt!\\n  \" The bids accepted count during the day. \"\\n  bidsAcceptedCount: BigInt!\\n  \" The bids placed count during the day. \"\\n  bidsPlacedCount: BigInt!\\n  \" The bids rejected count during the day. \"\\n  bidsRejectedCount: BigInt!\\n  \" The bids withdrawn count during the day. \"\\n  bidsWithdrawnCount: BigInt!\\n  \" The bids increased count during the day. \"\\n  bidsIncreasedCount: BigInt!\\n  \" The total value placed in bids during the day. \"\\n  totalValuePlaceInBids: BigDecimal!\\n  \" The total value cycled in bids during the day. \"\\n  totalValueCycledInBids: BigDecimal!\\n  \" The secondary sales value in ETH during the day. \"\\n  secondarySalesValue: BigDecimal!\\n  \" The issued count during the day. \"\\n  issuedCount: BigInt!\\n  \" The sales count during the day. \"\\n  salesCount: BigInt!\\n  \" The total value in ETH during the day. \"\\n  totalValueInEth: BigDecimal!\\n  \" The highest value in ETH during the day. \"\\n  highestValueInEth: BigDecimal!\\n  \" The highest value token during the day. \"\\n  highestValueToken: Token\\n  \" The issued tokens during the day. \"\\n  issued: [Token!]!\\n  \" The editions during the day. \"\\n  editions: [Edition!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `Day` with various fields, each having a specific data type and a brief description. The task is to ensure that each field is documented with a concise and factual description, maintaining the original schema structure without altering any underlying details. The descriptions should be clear and directly related to the field's purpose or data type.\",\n    documented_schema='\"Description for table: Day\"\\ntype Day @entity {\\n  \"Unique identifier for the day\"\\n  id: ID!\\n  \"Date represented as a string\"\\n  date: String!\\n  \"Number of transfers that occurred\"\\n  transferCount: BigInt!\\n  \"Number of editions counted\"\\n  editionsCount: BigInt!\\n  \"Number of bids that were accepted\"\\n  bidsAcceptedCount: BigInt!\\n  \"Number of bids that were placed\"\\n  bidsPlacedCount: BigInt!\\n  \"Number of bids that were rejected\"\\n  bidsRejectedCount: BigInt!\\n  \"Number of bids that were withdrawn\"\\n  bidsWithdrawnCount: BigInt!\\n  \"Number of bids that were increased\"\\n  bidsIncreasedCount: BigInt!\\n  \"Total value of placed bids\"\\n  totalValuePlaceInBids: BigDecimal!\\n  \"Total value cycled in bids\"\\n  totalValueCycledInBids: BigDecimal!\\n  \"Value of secondary sales\"\\n  secondarySalesValue: BigDecimal!\\n  \"Count of issued items\"\\n  issuedCount: BigInt!\\n  \"Count of sales made\"\\n  salesCount: BigInt!\\n  \"Total value in Ethereum\"\\n  totalValueInEth: BigDecimal!\\n  \"Highest value in Ethereum\"\\n  highestValueInEth: BigDecimal!\\n  \"Token with the highest value\"\\n  highestValueToken: Token\\n  \"List of issued tokens\"\\n  issued: [Token!]!\\n  \"List of editions\"\\n  editions: [Edition!]!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: InterestRate\"\\ntype InterestRate @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: rate\"\\n  rate: BigDecimal!\\n  \"Description for column: duration\"\\n  duration: Int\\n  \"Description for column: maturityBlock\"\\n  maturityBlock: BigInt\\n  \"Description for column: side\"\\n  side: InterestRateSide!\\n  \"Description for column: type\"\\n  type: InterestRateType!\\n  \"Description for column: tranche\"\\n  tranche: Tranche\\n}', 'documented_schema': 'type InterestRate @entity @regularPolling {\\n  \" { Interest rate side }-{ Interest rate type }-{ Market ID }-{ Optional: Tranche }-{ Optional: # days/hours since epoch time } \"\\n  id: ID!\\n  \" Interest rate in percentage APY. E.g. 5.21% should be stored as 5.21 \"\\n  rate: BigDecimal!\\n  \" Duration of the loan in days. Only applies to fixed term lending (e.g. Notional) \"\\n  duration: Int\\n  \" Maturity of the loan in block height. Only applies to fixed term lending (e.g. Notional) \"\\n  maturityBlock: BigInt\\n  \" The party the interest is paid to / received from \"\\n  side: InterestRateSide!\\n  \" The type of interest rate (e.g. stable, fixed, variable, etc) \"\\n  type: InterestRateType!\\n  \" The level of debt priority at this interest rate \"\\n  tranche: Tranche\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The task requires adding precise descriptions to each column in the provided GraphQL schema for the `InterestRate` table. The descriptions should be factual and concise, focusing on the role or nature of each column within the context of an interest rate entity. The descriptions should not include any speculative information or unnecessary commentary.',\n    documented_schema='\"Description for table: InterestRate\"\\ntype InterestRate @entity @regularPolling {\\n  \"Unique identifier for the interest rate entry\"\\n  id: ID!\\n  \"The interest rate value as a decimal\"\\n  rate: BigDecimal!\\n  \"The duration for which the interest rate is applicable, in some unit of time\"\\n  duration: Int\\n  \"The block number at which the interest rate matures\"\\n  maturityBlock: BigInt\\n  \"The side of the interest rate, indicating whether it is a borrowing or lending rate\"\\n  side: InterestRateSide!\\n  \"The type of interest rate, such as fixed or variable\"\\n  type: InterestRateType!\\n  \"The tranche associated with the interest rate, if applicable\"\\n  tranche: Tranche\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: NameSignalSubgraphRelation\"\\ntype NameSignalSubgraphRelation @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: nameSignal\"\\n  nameSignal: NameSignal!\\n  \"Description for column: subgraph\"\\n  subgraph: Subgraph!\\n}', 'documented_schema': '\"\"\"Auxiliary entity to be able to batch update NameSignal entities\"\"\"\\ntype NameSignalSubgraphRelation @entity {\\n  \"Subgraph ID + index\"\\n  id: ID!\\n  nameSignal: NameSignal!\\n  subgraph: Subgraph!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity named `NameSignalSubgraphRelation`. This entity has three fields: `id`, `nameSignal`, and `subgraph`. Each field is annotated with a description placeholder, indicating where documentation should be added. The `id` field is of type `ID!`, which is a non-nullable unique identifier. The `nameSignal` field is of type `NameSignal!`, indicating a non-nullable relationship to another entity or type named `NameSignal`. Similarly, the `subgraph` field is of type `Subgraph!`, indicating a non-nullable relationship to another entity or type named `Subgraph`. The task is to provide concise and factual descriptions for each of these fields based on their names and types.',\n    documented_schema='\"Description for table: NameSignalSubgraphRelation\"\\ntype NameSignalSubgraphRelation @entity {\\n  \"Unique identifier for the NameSignalSubgraphRelation entity\"\\n  id: ID!\\n  \"Reference to the associated NameSignal entity\"\\n  nameSignal: NameSignal!\\n  \"Reference to the associated Subgraph entity\"\\n  subgraph: Subgraph!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: NameSignal\"\\ntype NameSignal @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: curator\"\\n  curator: Curator!\\n  \"Description for column: subgraph\"\\n  subgraph: Subgraph!\\n  \"Description for column: signalledTokens\"\\n  signalledTokens: BigInt!\\n  \"Description for column: unsignalledTokens\"\\n  unsignalledTokens: BigInt!\\n  \"Description for column: withdrawnTokens\"\\n  withdrawnTokens: BigInt!\\n  \"Description for column: nameSignal\"\\n  nameSignal: BigInt!\\n  \"Description for column: signal\"\\n  signal: BigDecimal!\\n  \"Description for column: signalledTokensSentToL2\"\\n  signalledTokensSentToL2: BigInt!\\n  \"Description for column: signalledTokensReceivedOnL2\"\\n  signalledTokensReceivedOnL2: BigInt!\\n  \"Description for column: transferredToL2\"\\n  transferredToL2: Boolean!\\n  \"Description for column: transferredToL2At\"\\n  transferredToL2At: BigInt\\n  \"Description for column: transferredToL2AtBlockNumber\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Description for column: transferredToL2AtTx\"\\n  transferredToL2AtTx: String\\n  \"Description for column: idOnL2\"\\n  idOnL2: String\\n  \"Description for column: idOnL1\"\\n  idOnL1: String\\n  \"Description for column: lastNameSignalChange\"\\n  lastNameSignalChange: Int!\\n  \"Description for column: realizedRewards\"\\n  realizedRewards: BigInt!\\n  \"Description for column: averageCostBasis\"\\n  averageCostBasis: BigDecimal!\\n  \"Description for column: averageCostBasisPerSignal\"\\n  averageCostBasisPerSignal: BigDecimal!\\n  \"Description for column: nameSignalAverageCostBasis\"\\n  nameSignalAverageCostBasis: BigDecimal!\\n  \"Description for column: nameSignalAverageCostBasisPerSignal\"\\n  nameSignalAverageCostBasisPerSignal: BigDecimal!\\n  \"Description for column: signalAverageCostBasis\"\\n  signalAverageCostBasis: BigDecimal!\\n  \"Description for column: signalAverageCostBasisPerSignal\"\\n  signalAverageCostBasisPerSignal: BigDecimal!\\n  \"Description for column: entityVersion\"\\n  entityVersion: Int!\\n  \"Description for column: linkedEntity\"\\n  linkedEntity: NameSignal\\n}', 'documented_schema': '\"\"\"Curator Name Signal for a single Subgraph\"\"\"\\ntype NameSignal @entity {\\n  \"Eth address + subgraph ID\"\\n  id: ID!\\n  \"Eth address of the curator\"\\n  curator: Curator!\\n  \"Subgraph being signalled\"\\n  subgraph: Subgraph!\\n  \"CUMULATIVE number of tokens the curator has signalled\"\\n  signalledTokens: BigInt!\\n  \"CUMULATIVE number of tokens the curator has unsignalled\"\\n  unsignalledTokens: BigInt!\\n  \"Tokens the curator has withdrawn from a deprecated name curve\"\\n  withdrawnTokens: BigInt!\\n  \"Shares of the name pool (GNS) that the curator has from signaling their GRT\"\\n  nameSignal: BigInt!\\n  \"Actual signal shares that the name pool minted with the GRT provided by the curator\"\\n  signal: BigDecimal!\\n  \"Amount of GRT transferred to L2\"\\n  signalledTokensSentToL2: BigInt!\\n  \"Amount of GRT received on L2\"\\n  signalledTokensReceivedOnL2: BigInt!\\n  \"Whether the name signal has been transferred from L1 to L2. Only applies to NameSignals that have been transferred, native L2 NameSignal entities will return false\"\\n  transferredToL2: Boolean!\\n  \"Timestamp for the L1 -> L2 Transfer.\"\\n  transferredToL2At: BigInt\\n  \"Block number for the L1 -> L2 Transfer.\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Transaction hash for the L1 -> L2 Transfer.\"\\n  transferredToL2AtTx: String\\n  \"ID of the NameSignal entity on L2. Null if it\\'s not transferred\"\\n  idOnL2: String\\n  \"ID of the NameSignal entity on L1. Null if it\\'s not transferred\"\\n  idOnL1: String\\n  \"Block for which the curator last entered or exited the curve\"\\n  lastNameSignalChange: Int!\\n  \"Summation of realized rewards from before the last time the curator entered the curation curve\"\\n  realizedRewards: BigInt!\\n  \"[DEPRECATED] Curator average cost basis for this name signal on this subgraph. New field for further versions will be nameSignalAverageCostBasis\"\\n  averageCostBasis: BigDecimal!\\n  \"[DEPRECATED] nameSignalAverageCostBasis / nameSignal. New field for further versions will be nameSignalAverageCostBasisPerSignal\"\\n  averageCostBasisPerSignal: BigDecimal!\\n  \"Curator average cost basis for this name signal on this subgraph\"\\n  nameSignalAverageCostBasis: BigDecimal!\\n  \"nameSignalAverageCostBasis / nameSignal\"\\n  nameSignalAverageCostBasisPerSignal: BigDecimal!\\n  \"Curator average cost basis for the version signal on this subgraph name pool\"\\n  signalAverageCostBasis: BigDecimal!\\n  \"signalAverageCostBasis / signal\"\\n  signalAverageCostBasisPerSignal: BigDecimal!\\n  entityVersion: Int!\\n  \"[DEPRECATED] Used for duplicate entities to enable old IDs from before the subgraph NFT update\"\\n  linkedEntity: NameSignal\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type called `NameSignal` with various fields, each having a specific data type and a brief description. The task is to ensure that each field is documented with a concise and factual description, maintaining the structure and format of the original schema. The descriptions should be clear and directly related to the field's purpose or data type, without altering the schema's structure.\",\n    documented_schema='\"Description for table: NameSignal\"\\ntype NameSignal @entity {\\n  \"Unique identifier for the NameSignal entity\"\\n  id: ID!\\n  \"Reference to the curator associated with this NameSignal\"\\n  curator: Curator!\\n  \"Reference to the subgraph associated with this NameSignal\"\\n  subgraph: Subgraph!\\n  \"Total tokens signalled\"\\n  signalledTokens: BigInt!\\n  \"Total tokens unsignalled\"\\n  unsignalledTokens: BigInt!\\n  \"Total tokens withdrawn\"\\n  withdrawnTokens: BigInt!\\n  \"Current name signal value\"\\n  nameSignal: BigInt!\\n  \"Current signal value as a decimal\"\\n  signal: BigDecimal!\\n  \"Tokens sent to Layer 2\"\\n  signalledTokensSentToL2: BigInt!\\n  \"Tokens received on Layer 2\"\\n  signalledTokensReceivedOnL2: BigInt!\\n  \"Indicates if the tokens were transferred to Layer 2\"\\n  transferredToL2: Boolean!\\n  \"Timestamp of transfer to Layer 2\"\\n  transferredToL2At: BigInt\\n  \"Block number at the time of transfer to Layer 2\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Transaction ID for the transfer to Layer 2\"\\n  transferredToL2AtTx: String\\n  \"Identifier on Layer 2\"\\n  idOnL2: String\\n  \"Identifier on Layer 1\"\\n  idOnL1: String\\n  \"Timestamp of the last name signal change\"\\n  lastNameSignalChange: Int!\\n  \"Total realized rewards\"\\n  realizedRewards: BigInt!\\n  \"Average cost basis of the tokens\"\\n  averageCostBasis: BigDecimal!\\n  \"Average cost basis per signal\"\\n  averageCostBasisPerSignal: BigDecimal!\\n  \"Average cost basis of the name signal\"\\n  nameSignalAverageCostBasis: BigDecimal!\\n  \"Average cost basis per name signal\"\\n  nameSignalAverageCostBasisPerSignal: BigDecimal!\\n  \"Average cost basis of the signal\"\\n  signalAverageCostBasis: BigDecimal!\\n  \"Average cost basis per signal\"\\n  signalAverageCostBasisPerSignal: BigDecimal!\\n  \"Version of the entity\"\\n  entityVersion: Int!\\n  \"Reference to a linked NameSignal entity\"\\n  linkedEntity: NameSignal\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Tick\"\\ntype Tick @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: index\"\\n  index: BigInt!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: createdBlockNumber\"\\n  createdBlockNumber: BigInt!\\n  \"Description for column: prices\"\\n  prices: [BigDecimal!]!\\n  \"Description for column: liquidityGross\"\\n  liquidityGross: BigInt!\\n  \"Description for column: liquidityGrossUSD\"\\n  liquidityGrossUSD: BigDecimal!\\n  \"Description for column: liquidityNet\"\\n  liquidityNet: BigInt!\\n  \"Description for column: liquidityNetUSD\"\\n  liquidityNetUSD: BigDecimal!\\n  \"Description for column: lastSnapshotDayID\"\\n  lastSnapshotDayID: Int!\\n  \"Description for column: lastSnapshotHourID\"\\n  lastSnapshotHourID: Int!\\n  \"Description for column: lastUpdateTimestamp\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Description for column: lastUpdateBlockNumber\"\\n  lastUpdateBlockNumber: BigInt!\\n}', 'documented_schema': 'type Tick @entity @regularPolling {\\n  \" { pool address }-{ tick index } \"\\n  id: Bytes!\\n  \" tick index \"\\n  index: BigInt!\\n  \" Liquidity pool this tick belongs to \"\\n  pool: LiquidityPool!\\n  \" Creation timestamp \"\\n  createdTimestamp: BigInt!\\n  \" Creation block number \"\\n  createdBlockNumber: BigInt!\\n  \" calculated price of token0 of tick within this pool - constant \"\\n  prices: [BigDecimal!]!\\n  \" total liquidity pool has as tick lower or upper \"\\n  liquidityGross: BigInt!\\n  \" total liquidity in USD pool has as tick lower or upper \"\\n  liquidityGrossUSD: BigDecimal!\\n  \" how much liquidity changes when tick crossed \"\\n  liquidityNet: BigInt!\\n  \" how much liquidity in USD changes when tick crossed \"\\n  liquidityNetUSD: BigDecimal!\\n  \" Day ID of the most recent daily snapshot \"\\n  lastSnapshotDayID: Int!\\n  \" Hour ID of the most recent hourly snapshot \"\\n  lastSnapshotHourID: Int!\\n  \" Timestamp of the last time this entity was updated \"\\n  lastUpdateTimestamp: BigInt!\\n  \" Block number of the last time this entity was updated \"\\n  lastUpdateBlockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type named `Tick` with various fields, each having a specific data type and a brief description. The task is to ensure that each field is documented with a concise and factual description, focusing on the details provided in the schema. The descriptions should be clear and directly related to the field's purpose or data type, without adding any speculative information.\",\n    documented_schema='\"Description for table: Tick\"\\ntype Tick @entity @regularPolling {\\n  \"Unique identifier for the tick, stored as bytes.\"\\n  id: Bytes!\\n  \"Index of the tick, represented as a big integer.\"\\n  index: BigInt!\\n  \"Reference to the associated liquidity pool.\"\\n  pool: LiquidityPool!\\n  \"Timestamp indicating when the tick was created, stored as a big integer.\"\\n  createdTimestamp: BigInt!\\n  \"Block number at which the tick was created, stored as a big integer.\"\\n  createdBlockNumber: BigInt!\\n  \"Array of prices associated with the tick, each represented as a big decimal.\"\\n  prices: [BigDecimal!]!\\n  \"Gross liquidity value of the tick, stored as a big integer.\"\\n  liquidityGross: BigInt!\\n  \"Gross liquidity value in USD, represented as a big decimal.\"\\n  liquidityGrossUSD: BigDecimal!\\n  \"Net liquidity value of the tick, stored as a big integer.\"\\n  liquidityNet: BigInt!\\n  \"Net liquidity value in USD, represented as a big decimal.\"\\n  liquidityNetUSD: BigDecimal!\\n  \"Identifier for the last snapshot day, stored as an integer.\"\\n  lastSnapshotDayID: Int!\\n  \"Identifier for the last snapshot hour, stored as an integer.\"\\n  lastSnapshotHourID: Int!\\n  \"Timestamp of the last update, stored as a big integer.\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Block number of the last update, stored as a big integer.\"\\n  lastUpdateBlockNumber: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: UsageMetricsDailySnapshot\"\\ntype UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: day\"\\n  day: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: dailyActiveUsers\"\\n  dailyActiveUsers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: dailyTransactionCount\"\\n  dailyTransactionCount: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: dailyDepositCount\"\\n  dailyDepositCount: Int!\\n  \"Description for column: dailyWithdrawCount\"\\n  dailyWithdrawCount: Int!\\n  \"Description for column: dailySwapCount\"\\n  dailySwapCount: Int!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}', 'documented_schema': 'type UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: Bytes!\\n  \" Number of days since Unix epoch time \"\\n  day: Int!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" Number of unique daily active users \"\\n  dailyActiveUsers: Int!\\n  \" Number of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface. \"\\n  dailyTransactionCount: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Total number of deposits (add liquidity) in an day \"\\n  dailyDepositCount: Int!\\n  \" Total number of withdrawals (remove liquidity) in an day \"\\n  dailyWithdrawCount: Int!\\n  \" Total number of trades (swaps) in an day \"\\n  dailySwapCount: Int!\\n  \" Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed) \"\\n  timestamp: BigInt!\\n  \" Block number of when this snapshot was taken/last modified (May be taken after interval has passed) \"\\n  blockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The schema provided is for a GraphQL entity named `UsageMetricsDailySnapshot`, which appears to be used for tracking daily usage metrics of a decentralized exchange automated market maker (DexAmmProtocol). Each field in the schema has a specific role in capturing various metrics related to user activity, transactions, and protocol operations on a daily basis. The descriptions for each field are intended to clarify the purpose and data type of each column, ensuring that users of the schema understand what data is being captured and how it is structured.',\n    documented_schema='\"Description for table: UsageMetricsDailySnapshot\"\\ntype UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \"Unique identifier for the snapshot.\"\\n  id: Bytes!\\n  \"The day for which the metrics are recorded, represented as an integer.\"\\n  day: Int!\\n  \"The protocol associated with the usage metrics.\"\\n  protocol: DexAmmProtocol!\\n  \"Number of unique users active on the protocol during the day.\"\\n  dailyActiveUsers: Int!\\n  \"Total number of unique users who have interacted with the protocol up to and including the current day.\"\\n  cumulativeUniqueUsers: Int!\\n  \"Total number of transactions that occurred during the day.\"\\n  dailyTransactionCount: Int!\\n  \"Total number of pools available in the protocol on the given day.\"\\n  totalPoolCount: Int!\\n  \"Number of deposit transactions made during the day.\"\\n  dailyDepositCount: Int!\\n  \"Number of withdrawal transactions made during the day.\"\\n  dailyWithdrawCount: Int!\\n  \"Number of swap transactions made during the day.\"\\n  dailySwapCount: Int!\\n  \"Timestamp marking the exact time the snapshot was taken.\"\\n  timestamp: BigInt!\\n  \"Block number at which the snapshot was recorded.\"\\n  blockNumber: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: symbol\"\\n  symbol: String!\\n  \"Description for column: decimals\"\\n  decimals: Int!\\n  \"Description for column: lastPriceUSD\"\\n  lastPriceUSD: BigDecimal\\n  \"Description for column: lastPriceBlockNumber\"\\n  lastPriceBlockNumber: BigInt\\n  \"Description for column: _poolToken\"\\n  _poolToken: Token\\n}', 'documented_schema': 'type Token @entity @regularPolling {\\n  \" Smart contract address of the token \"\\n  id: ID!\\n  \" Name of the token, mirrored from the smart contract \"\\n  name: String!\\n  \" Symbol of the token, mirrored from the smart contract \"\\n  symbol: String!\\n  \" The number of decimal places this token uses, default to 18 \"\\n  decimals: Int!\\n  \" Optional field to track the price of a token, mostly for caching purposes \"\\n  lastPriceUSD: BigDecimal\\n  \" Optional field to track the block number of the last token price \"\\n  lastPriceBlockNumber: BigInt\\n  _poolToken: Token\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Token` type with several fields, each requiring a description. The descriptions should be concise and directly related to the field's purpose or data type. The `Token` type includes fields such as `id`, `name`, `symbol`, `decimals`, `lastPriceUSD`, `lastPriceBlockNumber`, and `_poolToken`. Each field's description should reflect its role or the type of data it holds, without altering the schema structure.\",\n    documented_schema='\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Unique identifier for the token\"\\n  id: ID!\\n  \"Name of the token\"\\n  name: String!\\n  \"Symbol representing the token\"\\n  symbol: String!\\n  \"Number of decimal places for the token\"\\n  decimals: Int!\\n  \"Last recorded price of the token in USD\"\\n  lastPriceUSD: BigDecimal\\n  \"Block number at which the last price was recorded\"\\n  lastPriceBlockNumber: BigInt\\n  \"Reference to another token associated with a pool\"\\n  _poolToken: Token\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: PoolRouteSnapshot\"\\ntype PoolRouteSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: poolRoute\"\\n  poolRoute: PoolRoute!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: snapshotVolumeIn\"\\n  snapshotVolumeIn: BigInt!\\n  \"Description for column: cumulativeVolumeIn\"\\n  cumulativeVolumeIn: BigInt!\\n  \"Description for column: snapshotVolumeOut\"\\n  snapshotVolumeOut: BigInt!\\n  \"Description for column: cumulativeVolumeOut\"\\n  cumulativeVolumeOut: BigInt!\\n  \"Description for column: snapshotVolumeInUSD\"\\n  snapshotVolumeInUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeInUSD\"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \"Description for column: snapshotVolumeOutUSD\"\\n  snapshotVolumeOutUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeOutUSD\"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n}', 'documented_schema': 'type PoolRouteSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \" poolRouteID.concat(poolSnapshotID) \"\\n  id: Bytes!\\n  \" PoolRoute this snapshot belongs to \"\\n  poolRoute: PoolRoute!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" volume received through this route during the time of the snapshot period (hourly/daily) \"\\n  snapshotVolumeIn: BigInt!\\n  \" total volume received through this route in inputToken \"\\n  cumulativeVolumeIn: BigInt!\\n  \" volume sent through this route during the time of the snapshot period (hourly/daily) \"\\n  snapshotVolumeOut: BigInt!\\n  \" total volume sent through this route in inputToken \"\\n  cumulativeVolumeOut: BigInt!\\n  \" volume received through this route during the time of the snapshot period (hourly/daily) in USD \"\\n  snapshotVolumeInUSD: BigDecimal!\\n  \" total volume received through this route in USD \"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \" volume sent through this route during the time of the snapshot period (hourly/daily) in USD \"\\n  snapshotVolumeOutUSD: BigDecimal!\\n  \" total volume sent through this route in USD \"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `PoolRouteSnapshot` with various fields, each having a specific data type and a brief description. The task is to ensure that each field is documented with a concise and factual description, focusing on the role or nature of the data it holds. The descriptions should be clear and directly related to the field names and types, without altering the schema structure.',\n    documented_schema='\"Description for table: PoolRouteSnapshot\"\\ntype PoolRouteSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Unique identifier for the snapshot\"\\n  id: Bytes!\\n  \"Reference to the associated pool route\"\\n  poolRoute: PoolRoute!\\n  \"Timestamp of when the snapshot was taken\"\\n  timestamp: BigInt!\\n  \"Block number at the time of the snapshot\"\\n  blockNumber: BigInt!\\n  \"Volume of assets entering the pool during the snapshot period\"\\n  snapshotVolumeIn: BigInt!\\n  \"Total volume of assets that have entered the pool up to the snapshot\"\\n  cumulativeVolumeIn: BigInt!\\n  \"Volume of assets exiting the pool during the snapshot period\"\\n  snapshotVolumeOut: BigInt!\\n  \"Total volume of assets that have exited the pool up to the snapshot\"\\n  cumulativeVolumeOut: BigInt!\\n  \"Volume in USD of assets entering the pool during the snapshot period\"\\n  snapshotVolumeInUSD: BigDecimal!\\n  \"Total volume in USD of assets that have entered the pool up to the snapshot\"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \"Volume in USD of assets exiting the pool during the snapshot period\"\\n  snapshotVolumeOutUSD: BigDecimal!\\n  \"Total volume in USD of assets that have exited the pool up to the snapshot\"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Epoch\"\\ntype Epoch @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: startBlock\"\\n  startBlock: Int!\\n  \"Description for column: endBlock\"\\n  endBlock: Int!\\n  \"Description for column: signalledTokens\"\\n  signalledTokens: BigInt!\\n  \"Description for column: stakeDeposited\"\\n  stakeDeposited: BigInt!\\n  \"Description for column: totalQueryFees\"\\n  totalQueryFees: BigInt!\\n  \"Description for column: taxedQueryFees\"\\n  taxedQueryFees: BigInt!\\n  \"Description for column: queryFeesCollected\"\\n  queryFeesCollected: BigInt!\\n  \"Description for column: curatorQueryFees\"\\n  curatorQueryFees: BigInt!\\n  \"Description for column: queryFeeRebates\"\\n  queryFeeRebates: BigInt!\\n  \"Description for column: totalRewards\"\\n  totalRewards: BigInt!\\n  \"Description for column: totalIndexerRewards\"\\n  totalIndexerRewards: BigInt!\\n  \"Description for column: totalDelegatorRewards\"\\n  totalDelegatorRewards: BigInt!\\n}', 'documented_schema': '\"\"\"\\nEpoch aggregate data for network statistics on signaling, rewards, and query fees\\n\"\"\"\\ntype Epoch @entity {\\n  \"Epoch number\"\\n  id: ID!\\n  \"Start block of the epoch\"\\n  startBlock: Int!\\n  \"End block of the epoch\"\\n  endBlock: Int!\\n  \"Signaled tokens during this epoch\"\\n  signalledTokens: BigInt!\\n  \"Stake deposited during this epoch\"\\n  stakeDeposited: BigInt!\\n  \"Total amount of query fees generated during this epoch (Includes everything)\"\\n  totalQueryFees: BigInt!\\n  \"Amount of query fees generated that were burnt by the 1% protocol tax during this epoch\"\\n  taxedQueryFees: BigInt!\\n  \"Amount of query fees generated for indexers during this epoch\"\\n  queryFeesCollected: BigInt!\\n  \"Amount of query fees generated that are going to curators during this epoch\"\\n  curatorQueryFees: BigInt!\\n  \"Rebate amount claimed from the protocol through rebates mechanism during this epoch\"\\n  queryFeeRebates: BigInt!\\n  \"Total indexing rewards earned in this epoch. Includes both delegator and indexer rewards\"\\n  totalRewards: BigInt!\\n  \"Total indexing rewards earned in this epoch by indexers\"\\n  totalIndexerRewards: BigInt!\\n  \"Total indexing rewards earned in this epoch by delegators\"\\n  totalDelegatorRewards: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity named \"Epoch\" with various fields, each having a specific data type. The task is to generate concise and factual descriptions for each field based on the information given in the schema. The descriptions should be clear and directly related to the field names and their types, without adding any speculative information.',\n    documented_schema='\"Description for table: Epoch\"\\ntype Epoch @entity {\\n  \"Unique identifier for the epoch.\"\\n  id: ID!\\n  \"The starting block number of the epoch.\"\\n  startBlock: Int!\\n  \"The ending block number of the epoch.\"\\n  endBlock: Int!\\n  \"Total tokens signalled during the epoch.\"\\n  signalledTokens: BigInt!\\n  \"Total stake deposited during the epoch.\"\\n  stakeDeposited: BigInt!\\n  \"Total query fees collected during the epoch.\"\\n  totalQueryFees: BigInt!\\n  \"Total query fees taxed during the epoch.\"\\n  taxedQueryFees: BigInt!\\n  \"Total query fees collected during the epoch.\"\\n  queryFeesCollected: BigInt!\\n  \"Total query fees allocated to curators during the epoch.\"\\n  curatorQueryFees: BigInt!\\n  \"Total query fee rebates during the epoch.\"\\n  queryFeeRebates: BigInt!\\n  \"Total rewards distributed during the epoch.\"\\n  totalRewards: BigInt!\\n  \"Total rewards allocated to indexers during the epoch.\"\\n  totalIndexerRewards: BigInt!\\n  \"Total rewards allocated to delegators during the epoch.\"\\n  totalDelegatorRewards: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: _LiquidityGauge\"\\ntype _LiquidityGauge @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: vault\"\\n  vault: Vault!\\n}', 'documented_schema': 'type _LiquidityGauge @entity {\\n  \"Liquidity gauge address\"\\n  id: ID!\\n  \"Address of vault tokens the gauge accept deposits from\"\\n  vault: Vault!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `_LiquidityGauge`, with two fields: `id` and `vault`. The `id` field is of type `ID!`, indicating it is a non-nullable unique identifier for the entity. The `vault` field is of type `Vault!`, suggesting it is a non-nullable reference to another entity, `Vault`. The task is to ensure that each field has a clear and concise description, which is already provided in the schema.',\n    documented_schema='\"Description for table: _LiquidityGauge\"\\ntype _LiquidityGauge @entity {\\n  \"Unique identifier for the liquidity gauge.\"\\n  id: ID!\\n  \"Reference to the associated vault.\"\\n  vault: Vault!\\n}'\n)",
      4
    ],
    [
      "Example({'database_schema': '\"Description for table: Swap\"\\ntype Swap implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: tokenIn\"\\n  tokenIn: Token!\\n  \"Description for column: amountIn\"\\n  amountIn: BigInt!\\n  \"Description for column: amountInUSD\"\\n  amountInUSD: BigDecimal!\\n  \"Description for column: tokenOut\"\\n  tokenOut: Token!\\n  \"Description for column: amountOut\"\\n  amountOut: BigInt!\\n  \"Description for column: amountOutUSD\"\\n  amountOutUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: _tradingFeeAmount\"\\n  _tradingFeeAmount: BigInt!\\n  \"Description for column: _tradingFeeAmountUSD\"\\n  _tradingFeeAmountUSD: BigDecimal!\\n}', 'documented_schema': 'type Swap implements Event @entity @transaction {\\n  \" swap-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Token deposited into pool \"\\n  tokenIn: Token!\\n  \" Amount of token deposited into pool in native units \"\\n  amountIn: BigInt!\\n  \" Amount of token deposited into pool in USD \"\\n  amountInUSD: BigDecimal!\\n  \" Token withdrawn from pool \"\\n  tokenOut: Token!\\n  \" Amount of token withdrawn from pool in native units \"\\n  amountOut: BigInt!\\n  \" Amount of token withdrawn from pool in USD \"\\n  amountOutUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n  _tradingFeeAmount: BigInt!\\n  _tradingFeeAmountUSD: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a `Swap` type that implements the `Event` interface and is annotated with `@entity` and `@transaction`. Each field within the `Swap` type is accompanied by a description that succinctly explains the purpose or nature of the field. The descriptions are clear and directly associated with each field, ensuring that the schema is well-documented without altering the underlying structure.',\n    documented_schema='\"Description for table: Swap\"\\ntype Swap implements Event @entity @transaction {\\n  \"Unique identifier for the swap event\"\\n  id: ID!\\n  \"Transaction hash associated with the swap\"\\n  hash: String!\\n  \"Index of the log entry within the block\"\\n  logIndex: Int!\\n  \"Protocol used for the swap\"\\n  protocol: DexAmmProtocol!\\n  \"Address receiving the swapped tokens\"\\n  to: String!\\n  \"Address sending the tokens to be swapped\"\\n  from: String!\\n  \"Block number in which the swap occurred\"\\n  blockNumber: BigInt!\\n  \"Timestamp of when the swap occurred\"\\n  timestamp: BigInt!\\n  \"Token being swapped in\"\\n  tokenIn: Token!\\n  \"Amount of token being swapped in\"\\n  amountIn: BigInt!\\n  \"USD value of the amount being swapped in\"\\n  amountInUSD: BigDecimal!\\n  \"Token being swapped out\"\\n  tokenOut: Token!\\n  \"Amount of token being swapped out\"\\n  amountOut: BigInt!\\n  \"USD value of the amount being swapped out\"\\n  amountOutUSD: BigDecimal!\\n  \"Liquidity pool involved in the swap\"\\n  pool: LiquidityPool!\\n  \"Amount of trading fee in token\"\\n  _tradingFeeAmount: BigInt!\\n  \"USD value of the trading fee amount\"\\n  _tradingFeeAmountUSD: BigDecimal!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: _TokenWhitelistSymbol\"\\ntype _TokenWhitelistSymbol @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: address\"\\n  address: Bytes!\\n}', 'documented_schema': 'type _TokenWhitelistSymbol @entity(immutable: true) {\\n  \" Whitelist Token Symbol \"\\n  id: ID!\\n  \" Whitelist Token Address\"\\n  address: Bytes!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity `_TokenWhitelistSymbol` with two fields: `id` and `address`. The `id` field is of type `ID!`, indicating it is a non-nullable unique identifier for the entity. The `address` field is of type `Bytes!`, which suggests it stores a non-nullable byte sequence, likely representing a blockchain address. The entity is marked as immutable, meaning once created, its fields cannot be changed.',\n    documented_schema='\"Description for table: _TokenWhitelistSymbol\"\\ntype _TokenWhitelistSymbol @entity(immutable: true) {\\n  \"Unique identifier for the token whitelist symbol.\"\\n  id: ID!\\n  \"Blockchain address associated with the token whitelist symbol.\"\\n  address: Bytes!\\n}'\n)",
      4
    ],
    [
      "Example({'database_schema': '\"Description for table: TransferEvent\"\\ntype TransferEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: from\"\\n  from: Bytes!\\n  \"Description for column: to\"\\n  to: Bytes!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}', 'documented_schema': '\" TransferEvent is a table for recording events related to transfers of tokens \"\\ntype TransferEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the event. Type: BigInt! \"\\n  version: BigInt!\\n  \" The from address of the transfer. The address of the account that initiated the transfer. Type: Bytes! \"\\n  from: Bytes!\\n  \" The to address of the transfer. The address of the account that received the transfer. Type: Bytes! \"\\n  to: Bytes!\\n  \" The token ID of the transfer. The ID of the token being transferred. Type: BigInt! \"\\n  tokenId: BigInt!\\n  \" The edition associated with the transfer. References the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. \"\\n  blockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `TransferEvent`, with various fields. Each field is already accompanied by a brief description, which is consistent with the task requirements. The descriptions are concise and factual, directly reflecting the data type and purpose of each field. The task is to ensure that these descriptions are properly formatted and documented without altering the underlying schema.',\n    documented_schema='\"Description for table: TransferEvent\"\\ntype TransferEvent @entity(immutable: true) {\\n  \"Unique identifier for the transfer event\"\\n  id: ID!\\n  \"Version number of the transfer event\"\\n  version: BigInt!\\n  \"Address from which the token is transferred\"\\n  from: Bytes!\\n  \"Address to which the token is transferred\"\\n  to: Bytes!\\n  \"Identifier of the token being transferred\"\\n  tokenId: BigInt!\\n  \"Edition information of the token\"\\n  edition: Edition!\\n  \"Timestamp of when the transfer event occurred\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction containing the transfer event\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry within the transaction\"\\n  logIndex: BigInt!\\n  \"Address of the event source\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction was initiated\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was directed\"\\n  eventTxTo: Bytes\\n  \"Block number in which the transfer event was included\"\\n  blockNumber: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Deposit\"\\ntype Deposit @entity(immutable: true) @transaction {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hash\"\\n  hash: Bytes!\\n  \"Description for column: nonce\"\\n  nonce: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: gasLimit\"\\n  gasLimit: BigInt\\n  \"Description for column: gasUsed\"\\n  gasUsed: BigInt\\n  \"Description for column: gasPrice\"\\n  gasPrice: BigInt\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: account\"\\n  account: Account!\\n  \"Description for column: position\"\\n  position: Position\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: tickLower\"\\n  tickLower: BigInt\\n  \"Description for column: tickUpper\"\\n  tickUpper: BigInt\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: liquidity\"\\n  liquidity: BigInt!\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: inputTokenAmounts\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Description for column: reserveAmounts\"\\n  reserveAmounts: [BigInt!]\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n}', 'documented_schema': '\"\"\"\\nAn event is any user action that occurs in a protocol. Generally, they are Ethereum events\\nemitted by a function in the smart contracts, stored in transaction receipts as event logs.\\nHowever, some user actions of interest are function calls that don\\'t emit events. For example,\\nthe deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still\\nstore them as events, although they are not technically Ethereum events emitted by smart\\ncontracts.\\n\"\"\"\\ntype Deposit @entity(immutable: true) @transaction {\\n  \" { Transaction hash }-{ Log index } \"\\n  id: Bytes!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: Bytes!\\n  \" Nonce of the transaction that emitted this event \"\\n  nonce: BigInt!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" Gas limit of the transaction that emitted this event \"\\n  gasLimit: BigInt\\n  \" Gas used in this transaction. (Optional because not every chain will support this) \"\\n  gasUsed: BigInt\\n  \" Gas price of the transaction that emitted this event \"\\n  gasPrice: BigInt\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Account that emitted this event \"\\n  account: Account!\\n  \" The user position changed by this event \"\\n  position: Position\\n  \" The pool involving this event \"\\n  pool: LiquidityPool!\\n  \" lower tick of position \"\\n  tickLower: BigInt\\n  \" upper tick of position \"\\n  tickUpper: BigInt\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Amount of liquidity minted \"\\n  liquidity: BigInt!\\n  \" Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool \"\\n  inputTokens: [Token!]!\\n  \" Amount of input tokens in the token\\'s native unit \"\\n  inputTokenAmounts: [BigInt!]!\\n  \" Amount of input tokens in the liquidity pool \"\\n  reserveAmounts: [BigInt!]\\n  \" USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool) \"\\n  amountUSD: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a `Deposit` type with various fields, each having a specific data type and some marked as non-nullable. The task is to generate concise and factual descriptions for each field based on the schema. The descriptions should reflect the purpose or nature of each field without altering the schema structure.',\n    documented_schema='\"Description for table: Deposit\"\\ntype Deposit @entity(immutable: true) @transaction {\\n  \"Unique identifier for the deposit\"\\n  id: Bytes!\\n  \"Transaction hash associated with the deposit\"\\n  hash: Bytes!\\n  \"Transaction nonce value\"\\n  nonce: BigInt!\\n  \"Index of the log entry in the block\"\\n  logIndex: Int!\\n  \"Maximum amount of gas allowed for the transaction\"\\n  gasLimit: BigInt\\n  \"Amount of gas used by the transaction\"\\n  gasUsed: BigInt\\n  \"Price of gas at the time of the transaction\"\\n  gasPrice: BigInt\\n  \"Protocol associated with the deposit\"\\n  protocol: DexAmmProtocol!\\n  \"Account involved in the deposit\"\\n  account: Account!\\n  \"Position related to the deposit\"\\n  position: Position\\n  \"Liquidity pool involved in the deposit\"\\n  pool: LiquidityPool!\\n  \"Lower tick boundary for the deposit\"\\n  tickLower: BigInt\\n  \"Upper tick boundary for the deposit\"\\n  tickUpper: BigInt\\n  \"Block number when the deposit was made\"\\n  blockNumber: BigInt!\\n  \"Timestamp of the deposit\"\\n  timestamp: BigInt!\\n  \"Amount of liquidity added in the deposit\"\\n  liquidity: BigInt!\\n  \"Tokens inputted in the deposit\"\\n  inputTokens: [Token!]!\\n  \"Amounts of each input token\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Amounts reserved in the deposit\"\\n  reserveAmounts: [BigInt!]\\n  \"USD value of the deposit\"\\n  amountUSD: BigDecimal!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: _RewardData\"\\ntype _RewardData @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: rate\"\\n  rate: BigInt!\\n  \"Description for column: PeriodFinish\"\\n  PeriodFinish: BigInt!\\n}', 'documented_schema': 'type _RewardData @entity {\\n  \" {Liquidity gauge address}-{reward token address} \"\\n  id: ID!\\n  \" rate of emission \"\\n  rate: BigInt!\\n  \" timestamp of reward period finish \"\\n  PeriodFinish: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a single entity `_RewardData` with three fields: `id`, `rate`, and `PeriodFinish`. Each field is already accompanied by a brief description. The task is to ensure that these descriptions are clear and concise, focusing on the specific role or type of data each field represents within the entity. The descriptions should be factual and directly related to the field's purpose or data type.\",\n    documented_schema='\"Description for table: _RewardData\"\\ntype _RewardData @entity {\\n  \"Unique identifier for the reward data entry\"\\n  id: ID!\\n  \"The rate associated with the reward\"\\n  rate: BigInt!\\n  \"Timestamp indicating when the reward period ends\"\\n  PeriodFinish: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: LivepeerAccount\"\\ntype LivepeerAccount @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: lastUpdatedTimestamp\"\\n  lastUpdatedTimestamp: Int!\\n  \"Description for column: delegator\"\\n  delegator: Delegator\\n  \"Description for column: delegate\"\\n  delegate: Transcoder\\n}', 'documented_schema': '\"\"\"Abstraction for accounts/delegators bonded with the protocol\"\"\"\\ntype LivepeerAccount @entity {\\n  \"ETH address of the bonded delegator\"\\n  id: ID!\\n  \"The date the account was last associated with an event, beginning at 12:00am UTC\"\\n  lastUpdatedTimestamp: Int!\\n  \"Delegator details for this account\"\\n  delegator: Delegator\\n  \"Reference to the Delegate this address is bonded to\"\\n  delegate: Transcoder\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a single entity, `LivepeerAccount`, with four fields. Each field is already accompanied by a brief description. The task is to ensure that these descriptions are clear and concise, focusing on the role and type of each field within the entity. The descriptions should be factual and directly related to the schema's structure.\",\n    documented_schema='\"Description for table: LivepeerAccount\"\\ntype LivepeerAccount @entity {\\n  \"Unique identifier for the Livepeer account\"\\n  id: ID!\\n  \"Timestamp of the last update to the account, represented as an integer\"\\n  lastUpdatedTimestamp: Int!\\n  \"Reference to the associated delegator entity\"\\n  delegator: Delegator\\n  \"Reference to the associated delegate entity, typically a transcoder\"\\n  delegate: Transcoder\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: PauseEvent\"\\ntype PauseEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n}', 'documented_schema': '\"\"\"PauseEvent entities are created for every emitted Pause event.\"\"\"\\ntype PauseEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `PauseEvent` that implements an `Event` interface. Each field within the `PauseEvent` type is already accompanied by a description. The task is to ensure that these descriptions are clear and concise, focusing on the specific role of each field within the `PauseEvent` type. The descriptions should be factual and directly related to the schema without any additional commentary.',\n    documented_schema='\"Description for table: PauseEvent\"\\ntype PauseEvent implements Event @entity {\\n  \"Unique identifier for the pause event\"\\n  id: ID!\\n  \"Associated transaction for the pause event\"\\n  transaction: Transaction!\\n  \"Timestamp indicating when the pause event occurred\"\\n  timestamp: Int!\\n  \"Round during which the pause event took place\"\\n  round: Round!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: BridgeTransfer\"\\ntype BridgeTransfer implements Event @entity(immutable: true) @transaction {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hash\"\\n  hash: Bytes!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: BridgeProtocol!\\n  \"Description for column: account\"\\n  account: Account!\\n  \"Description for column: to\"\\n  to: Bytes!\\n  \"Description for column: from\"\\n  from: Bytes!\\n  \"Description for column: isOutgoing\"\\n  isOutgoing: Boolean!\\n  \"Description for column: fromChainID\"\\n  fromChainID: BigInt!\\n  \"Description for column: toChainID\"\\n  toChainID: BigInt!\\n  \"Description for column: transferTo\"\\n  transferTo: Bytes!\\n  \"Description for column: transferFrom\"\\n  transferFrom: Bytes\\n  \"Description for column: type\"\\n  type: TransferType!\\n  \"Description for column: pool\"\\n  pool: Pool!\\n  \"Description for column: route\"\\n  route: PoolRoute!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: crosschainToken\"\\n  crosschainToken: CrosschainToken!\\n  \"Description for column: isSwap\"\\n  isSwap: Boolean!\\n  \"Description for column: crossTransactionID\"\\n  crossTransactionID: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}', 'documented_schema': 'type BridgeTransfer implements Event @entity(immutable: true) @transaction {\\n  \" event.transaction.hash.concatI32(event.logIndex) \"\\n  id: Bytes!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: Bytes!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: BridgeProtocol!\\n  \" Account that sent or received the transfer. Should match with either transferFrom or transferTo \"\\n  account: Account!\\n  \" Address that received the tokens \"\\n  to: Bytes!\\n  \" Address that sent the tokens \"\\n  from: Bytes!\\n  \" Are we briding in or out? \"\\n  isOutgoing: Boolean!\\n  \" Chain ID from where the transfer is being sent \"\\n  fromChainID: BigInt!\\n  \" Chain ID where the transfer is being sent to \"\\n  toChainID: BigInt!\\n  \" This is the address that\\'s receiving the bridged funds (not a pool contract). When bridging out, it will be the address on the destination chain. \"\\n  transferTo: Bytes!\\n  \" This is the address initiating the transfer, where the initial funds came from. It might not match the address initiating the actual EVM transaction. \"\\n  transferFrom: Bytes\\n  \" Indicates how this transfer is ocurring on the current chain \"\\n  type: TransferType!\\n  \" The pool where the transfer originated or arrived \"\\n  pool: Pool!\\n  \" The route through which the funds where sent or received \"\\n  route: PoolRoute!\\n  \" The token sent/received in this transfer on the current chain \"\\n  token: Token!\\n  \" Amount of token transferred \"\\n  amount: BigInt!\\n  \" Amount of token transferred in USD \"\\n  amountUSD: BigDecimal!\\n  \" The equivalent of our token in the other chain \"\\n  crosschainToken: CrosschainToken!\\n  \" Indicates is the transfer involved a swap while bridging \"\\n  isSwap: Boolean!\\n  \" The transaction ID on the other chain, if available \"\\n  crossTransactionID: Bytes\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `BridgeTransfer` which implements an `Event` and is marked as immutable and transactional. Each field within the `BridgeTransfer` type is documented with a brief description. The fields include various data types such as `Bytes`, `Int`, `Boolean`, `BigInt`, `BigDecimal`, and custom types like `BridgeProtocol`, `Account`, `TransferType`, `Pool`, `PoolRoute`, `Token`, and `CrosschainToken`. The documentation for each field is concise, indicating the purpose or nature of the data it holds.',\n    documented_schema='\"Description for table: BridgeTransfer\"\\ntype BridgeTransfer implements Event @entity(immutable: true) @transaction {\\n  \"Unique identifier for the bridge transfer event\"\\n  id: Bytes!\\n  \"Hash of the transaction\"\\n  hash: Bytes!\\n  \"Index of the log entry in the block\"\\n  logIndex: Int!\\n  \"Protocol used for the bridge transfer\"\\n  protocol: BridgeProtocol!\\n  \"Account associated with the transfer\"\\n  account: Account!\\n  \"Destination address for the transfer\"\\n  to: Bytes!\\n  \"Source address for the transfer\"\\n  from: Bytes!\\n  \"Indicates if the transfer is outgoing\"\\n  isOutgoing: Boolean!\\n  \"Chain ID of the source blockchain\"\\n  fromChainID: BigInt!\\n  \"Chain ID of the destination blockchain\"\\n  toChainID: BigInt!\\n  \"Address to which the transfer is directed\"\\n  transferTo: Bytes!\\n  \"Address from which the transfer is initiated\"\\n  transferFrom: Bytes\\n  \"Type of the transfer\"\\n  type: TransferType!\\n  \"Pool associated with the transfer\"\\n  pool: Pool!\\n  \"Route taken by the pool for the transfer\"\\n  route: PoolRoute!\\n  \"Token involved in the transfer\"\\n  token: Token!\\n  \"Amount of tokens transferred\"\\n  amount: BigInt!\\n  \"USD equivalent of the transferred amount\"\\n  amountUSD: BigDecimal!\\n  \"Token used for cross-chain transfer\"\\n  crosschainToken: CrosschainToken!\\n  \"Indicates if the transfer involves a swap\"\\n  isSwap: Boolean!\\n  \"Transaction ID for cross-chain operations\"\\n  crossTransactionID: Bytes\\n  \"Block number in which the transfer was included\"\\n  blockNumber: BigInt!\\n  \"Timestamp of the transfer event\"\\n  timestamp: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: StakeClaimedEvent\"\\ntype StakeClaimedEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: delegator\"\\n  delegator: String!\\n  \"Description for column: delegate\"\\n  delegate: String!\\n  \"Description for column: stake\"\\n  stake: BigDecimal!\\n  \"Description for column: fees\"\\n  fees: BigDecimal!\\n}', 'documented_schema': '\"\"\"\\nStakeClaimedEvent entities are created for every emitted StakeClaimed event.\\n\"\"\"\\ntype StakeClaimedEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  delegator: String!\\n  delegate: String!\\n  stake: BigDecimal!\\n  fees: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `StakeClaimedEvent` which implements an `Event` and is marked with the `@entity` directive, indicating it is a persistent entity in the database. Each field within the type is accompanied by a description, which provides a brief explanation of the field's purpose or content. The descriptions are concise and directly related to the field they describe, ensuring clarity and understanding of the schema's structure and the data it represents.\",\n    documented_schema='\"Description for table: StakeClaimedEvent\"\\ntype StakeClaimedEvent implements Event @entity {\\n  \"Unique identifier for the stake claimed event\"\\n  id: ID!\\n  \"Reference to the transaction associated with the stake claimed event\"\\n  transaction: Transaction!\\n  \"Unix timestamp indicating when the stake was claimed\"\\n  timestamp: Int!\\n  \"Reference to the round during which the stake was claimed\"\\n  round: Round!\\n  \"Address of the delegator who claimed the stake\"\\n  delegator: String!\\n  \"Address of the delegate associated with the stake\"\\n  delegate: String!\\n  \"Amount of stake claimed, represented as a decimal\"\\n  stake: BigDecimal!\\n  \"Fees associated with the stake claimed, represented as a decimal\"\\n  fees: BigDecimal!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Edition\"\\ntype Edition @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: editionNmber\"\\n  editionNmber: String!\\n  \"Description for column: editionType\"\\n  editionType: BigInt!\\n  \"Description for column: editionData\"\\n  editionData: Bytes\\n  \"Description for column: creatorContract\"\\n  creatorContract: CreatorContract\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: revokedApproval\"\\n  revokedApproval: Boolean!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: tokenIds\"\\n  tokenIds: [String!]!\\n  \"Description for column: tokens\"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \"Description for column: tokenURI\"\\n  tokenURI: String!\\n  \"Description for column: artistAccount\"\\n  artistAccount: Bytes!\\n  \"Description for column: artistCommission\"\\n  artistCommission: BigInt!\\n  \"Description for column: optionalCommissionAccount\"\\n  optionalCommissionAccount: Bytes\\n  \"Description for column: optionalCommissionRate\"\\n  optionalCommissionRate: BigInt\\n  \"Description for column: collaborators\"\\n  collaborators: [Bytes!]!\\n  \"Description for column: collective\"\\n  collective: Collective\\n  \"Description for column: offersOnly\"\\n  offersOnly: Boolean!\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt!\\n  \"Description for column: totalAvailable\"\\n  totalAvailable: BigInt!\\n  \"Description for column: remainingSupply\"\\n  remainingSupply: BigInt!\\n  \"Description for column: totalSold\"\\n  totalSold: BigInt!\\n  \"Description for column: totalBurnt\"\\n  totalBurnt: BigInt!\\n  \"Description for column: originalEditionSize\"\\n  originalEditionSize: BigInt!\\n  \"Description for column: secondaryRoyaltyV4EditionOverride\"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \"Description for column: sales\"\\n  sales: [Token!]!\\n  \"Description for column: totalEthSpentOnEdition\"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \"Description for column: active\"\\n  active: Boolean!\\n  \"Description for column: metadata\"\\n  metadata: MetaData\\n  \"Description for column: isGenesisEdition\"\\n  isGenesisEdition: Boolean!\\n  \"Description for column: isEnhancedEdition\"\\n  isEnhancedEdition: Boolean!\\n  \"Description for column: isOpenEdition\"\\n  isOpenEdition: Boolean\\n  \"Description for column: hasCoverImage\"\\n  hasCoverImage: Boolean!\\n  \"Description for column: artist\"\\n  artist: Artist\\n  \"Description for column: startDate\"\\n  startDate: BigInt!\\n  \"Description for column: endDate\"\\n  endDate: BigInt!\\n  \"Description for column: reserveAuctionSeller\"\\n  reserveAuctionSeller: Bytes!\\n  \"Description for column: reserveAuctionBidder\"\\n  reserveAuctionBidder: Bytes!\\n  \"Description for column: reservePrice\"\\n  reservePrice: BigInt!\\n  \"Description for column: reserveAuctionBid\"\\n  reserveAuctionBid: BigInt!\\n  \"Description for column: reserveAuctionStartDate\"\\n  reserveAuctionStartDate: BigInt!\\n  \"Description for column: previousReserveAuctionEndTimestamp\"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionEndTimestamp\"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionNumTimesExtended\"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \"Description for column: isReserveAuctionInSuddenDeath\"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \"Description for column: reserveAuctionTotalExtensionLengthInSeconds\"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \"Description for column: isReserveAuctionResulted\"\\n  isReserveAuctionResulted: Boolean!\\n  \"Description for column: isReserveAuctionResultedDateTime\"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \"Description for column: reserveAuctionResulter\"\\n  reserveAuctionResulter: Bytes!\\n  \"Description for column: reserveAuctionCanEmergencyExit\"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \"Description for column: priceInWei\"\\n  priceInWei: BigInt!\\n  \"Description for column: stepSaleBasePrice\"\\n  stepSaleBasePrice: BigInt!\\n  \"Description for column: stepSaleStepPrice\"\\n  stepSaleStepPrice: BigInt!\\n  \"Description for column: currentStep\"\\n  currentStep: BigInt!\\n  \"Description for column: auctionEnabled\"\\n  auctionEnabled: Boolean!\\n  \"Description for column: activeBid\"\\n  activeBid: AuctionEvent\\n  \"Description for column: gatedSale\"\\n  gatedSale: GatedSale\\n  \"Description for column: biddingHistory\"\\n  biddingHistory: [AuctionEvent!]!\\n  \"Description for column: transfers\"\\n  transfers: [TransferEvent!]!\\n  \"Description for column: allOwners\"\\n  allOwners: [Collector!]!\\n  \"Description for column: currentOwners\"\\n  currentOwners: [Collector!]!\\n  \"Description for column: primaryOwners\"\\n  primaryOwners: [Collector!]!\\n  \"Description for column: metadataName\"\\n  metadataName: String!\\n  \"Description for column: metadataArtist\"\\n  metadataArtist: String!\\n  \"Description for column: metadataTagString\"\\n  metadataTagString: String!\\n  \"Description for column: metadataArtistAccount\"\\n  metadataArtistAccount: String!\\n  \"Description for column: metadataPrice\"\\n  metadataPrice: BigInt!\\n  \"Description for column: metadataFormat\"\\n  metadataFormat: String\\n  \"Description for column: metadataTheme\"\\n  metadataTheme: String\\n  \"Description for column: primaryAssetShortType\"\\n  primaryAssetShortType: String\\n  \"Description for column: primaryAssetActualType\"\\n  primaryAssetActualType: String\\n}', 'documented_schema': '\" A table of editions. An edition is a collection of tokens. \"\\ntype Edition @entity {\\n  \" The unique identifier for the edition. This is the composite ID made up of the edition ID and the optional contract address for the creator contract. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the edition. KODA 2, 3 or 4. Type: BigInt! \"\\n  version: BigInt!\\n  \" The edition number. This is the edition number. This is not a composite key. Type: String! \"\\n  editionNmber: String!\\n  \" The edition type. This is a legacy field from KODA V2. Type: BigInt! \"\\n  editionType: BigInt!\\n  \" The edition data. This is a legacy field from KODA V2 which contains some additional data about the edition. Type: Bytes! \"\\n  editionData: Bytes\\n  \" The creator contract. This references the CreatorContract entity. Type: CreatorContract! \"\\n  creatorContract: CreatorContract\\n  \" The sales type. This is the current sales mechanic being used on this edition. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The revoked approval flag. This is a boolean that indicates if the seller has revoked approved the marketplace, which is set to true once if the seller has revoked approved the marketplace. Type: Boolean! \"\\n  revokedApproval: Boolean!\\n  \" The created timestamp. This is a number, the timestamp of the creation of the edition. Type: BigInt! \"\\n  createdTimestamp: BigInt!\\n  \" The token IDs. This is an array of token IDs. Type: [String!]! \"\\n  tokenIds: [String!]!\\n  \" The tokens. This is an array of tokens. Type: [Token!]! \"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \" The token URI. This is a string, the URI of the token. Type: String! \"\\n  tokenURI: String!\\n  \" The artist account. This is the address of the artist for the edition. Type: Bytes! \"\\n  artistAccount: Bytes!\\n  \" The artist commission. This is the base artists commission. Type: BigInt! \"\\n  artistCommission: BigInt!\\n  \" The optional commission account. This is the address of the optional commission account. NOTE: deprecated - V2 only - use collaborators for this. Type: Bytes! \"\\n  optionalCommissionAccount: Bytes\\n  \" The optional commission rate. This is the rate of the optional commission. Type: BigInt! \"\\n  optionalCommissionRate: BigInt\\n  \" The collaborators. This is an array of addresses who have collaborated on this edition. Type: [Bytes!]! \"\\n  collaborators: [Bytes!]!\\n  \" The collective. This references the Collective entity. NOTE: nullable V3 collective i.e. its split funds. Type: Collective! \"\\n  collective: Collective\\n  \" The offers only flag. This is a boolean that indicates if the edition is only for offers. Type: Boolean! \"\\n  offersOnly: Boolean!\\n  \" The total supply. This is the total purchases or mints i.e. total number of primary transfers. Type: BigInt! \"\\n  totalSupply: BigInt!\\n  \" The total available. This is the total number available to be purchased i.e. edition size. Type: BigInt! \"\\n  totalAvailable: BigInt!\\n  \" The remaining supply. This is the total remaining i.e. number of primary sale tokens left to buy from this edition. Type: BigInt! \"\\n  remainingSupply: BigInt!\\n  \" The total sold. This is the total number sold i.e. number of primary sale tokens sold. sold = purchase/bid accepted with price > 0. Type: BigInt! \"\\n  totalSold: BigInt!\\n  \" The total burnt. This is the total number burnt i.e. number of primary sale tokens burnt. burnt = send to 0xDead or 0x0 (only applicable for V3). Type: BigInt! \"\\n  totalBurnt: BigInt!\\n  \" The original edition size. This is the original edition size of the edition at mint - this field should NEVER change once set. Type: BigInt! \"\\n  originalEditionSize: BigInt!\\n  \" The secondary royalty V4 edition override. This is the EIP2981 percentage requested by the creator(s) at the edition level. Type: BigInt! \"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \" The sales. This is an array of tokens that have been sold from this edition. Type: [Token!]! \"\\n  sales: [Token!]!\\n  \" The total eth spent on the edition. This is the total amount of ETH spent on the edition. Type: BigDecimal! \"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \" The active flag. This is a boolean that indicates if the edition is active. Type: Boolean! \"\\n  active: Boolean!\\n  \" The metadata. This references the MetaData entity. Type: MetaData! \"\\n  metadata: MetaData\\n  \" The isGenesisEdition flag. This is a boolean that indicates if the edition is the first edition. This is set true if edition is an artists first edition. Type: Boolean! \"\\n  isGenesisEdition: Boolean!\\n  \" The isEnhancedEdition flag. This is a boolean that indicates if the edition is an enhanced edition. This is set true if any of the tokens are enhanced i.e. composed. Type: Boolean! \"\\n  isEnhancedEdition: Boolean!\\n  \" The isOpenEdition flag. This is a boolean that indicates if the edition is an open edition. This is applicable to version 4 and editions where the artist does not mint all of the tokens up front. Type: Boolean! \"\\n  isOpenEdition: Boolean\\n  \" The hasCoverImage flag. This is a boolean that indicates if the edition has a cover image. Type: Boolean! \"\\n  hasCoverImage: Boolean!\\n  \" The artist. This references the Artist entity, and reference the primary minter. Type: Artist! \"\\n  artist: Artist\\n  \" The start date. This is a number, the timestamp of the start date of the edition. Type: BigInt! \"\\n  startDate: BigInt!\\n  \" The end date. The date when the edition is available until (only applicable for V2). Type: BigInt! \"\\n  endDate: BigInt!\\n  \" The reserve auction seller. This is the address of the edition seller. Type: Bytes! \"\\n  reserveAuctionSeller: Bytes!\\n  \" The reserve auction bidder. This is the address of the current bidder. Type: Bytes! \"\\n  reserveAuctionBidder: Bytes!\\n  \" The reserve price. This is the listed reserve price. Type: BigInt! \"\\n  reservePrice: BigInt!\\n  \" The reserve auction bid. This is the current bid. Type: BigInt! \"\\n  reserveAuctionBid: BigInt!\\n  \" The reserve auction start date. This is the timestamp of the auction start. Type: BigInt! \"\\n  reserveAuctionStartDate: BigInt!\\n  \" The previous reserve auction end timestamp. This is set to the same as reserve unless an extension is in flight. Type: BigInt! \"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction end timestamp. This is the timestamp of the auction end. Type: BigInt! \"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction number of times extended. This is the number of times the auction has been extended. Type: BigInt! \"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \" The reserve auction in sudden death flag. This is a boolean that indicates if the auction is in sudden death. Type: Boolean! \"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \" The reserve auction total extension length in seconds. This is the total length of the extension. Type: BigInt! \"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \" The reserve auction resulted flag. This is a boolean that indicates if the auction has resulted. Type: Boolean! \"\\n  isReserveAuctionResulted: Boolean!\\n  \" The reserve auction resulted timestamp. This is the timestamp of the auction result. Type: BigInt! \"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \" The reserve auction resulter. This is the address of the auction resulter. Type: Bytes! \"\\n  reserveAuctionResulter: Bytes!\\n  \" The reserve auction can emergency exit flag. This is a boolean that indicates if the auction can emergency exit. Type: Boolean! \"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \" The price in wei. This is the buy now price / current step price. Type: BigInt! \"\\n  priceInWei: BigInt!\\n  \" The step sale base price. This is the base price of the step sale. Type: BigInt! \"\\n  stepSaleBasePrice: BigInt!\\n  \" The step sale step price. This is the step price of the step sale. Type: BigInt! \"\\n  stepSaleStepPrice: BigInt!\\n  \" The current step. This is the current step of the step sale. Type: BigInt! \"\\n  currentStep: BigInt!\\n  \" The auction enabled flag. This is a boolean that indicates if the auction is enabled. Type: Boolean! \"\\n  auctionEnabled: Boolean!\\n  \" The active bid. This references the AuctionEvent entity. Type: AuctionEvent! \"\\n  activeBid: AuctionEvent\\n  \" The gated sale. This references the GatedSale entity. Represents if the edition is gated, which means the edition is only available to a certain set of users. Type: GatedSale! \"\\n  gatedSale: GatedSale\\n  \" The bidding history. This is an array of AuctionEvent entities. Type: [AuctionEvent!]! \"\\n  biddingHistory: [AuctionEvent!]!\\n  \" The transfers. The total number of token transfers made for all tokens from the edition. Type: [TransferEvent!]! \"\\n  transfers: [TransferEvent!]!\\n  \" The all owners. The list (set) of all unique owners for all tokens. Type: [Collector!]! \"\\n  allOwners: [Collector!]!\\n  \" The current owners. The current set of owners for this edition. Type: [Collector!]! \"\\n  currentOwners: [Collector!]!\\n  \" The primary owners. The owner is set when sold in primary sale. Type: [Collector!]! \"\\n  primaryOwners: [Collector!]!\\n  \" The metadata name. This is the name of the edition. Type: String! \"\\n  metadataName: String!\\n  \" The metadata artist. This is the artist of the edition. Type: String! \"\\n  metadataArtist: String!\\n  \" The metadata tag string. This is the tags of the edition. Type: String! \"\\n  metadataTagString: String!\\n  \" The metadata artist account. This is the artist account of the edition. Type: String! \"\\n  metadataArtistAccount: String!\\n  \" The metadata price. A consolidated price for all sale types, making it orderable in lists. Type: BigInt! \"\\n  metadataPrice: BigInt!\\n  \" The metadata format. This is the format of the edition (null-able as V3 only). Type: String! \"\\n  metadataFormat: String\\n  \" The metadata theme. This is the theme of the edition (null-able as V3 only). Type: String! \"\\n  metadataTheme: String\\n  \" The primary asset short type. This is the short type of the primary asset (null-able leading mime-type field i.e. image or video etc). Type: String! \"\\n  primaryAssetShortType: String\\n  \" The primary asset actual type. This is the actual type of the primary asset (null-able ending mime-type field e.g. mp4, gif, png etc). Type: String! \"\\n  primaryAssetActualType: String\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `Edition` with various fields, each having a specific data type and some with additional directives. The task is to generate precise descriptions for each field based on the information given in the schema. The descriptions should be concise and factual, reflecting the purpose or nature of each field as implied by its name and type. The documentation should be formatted correctly, ensuring that it is clear and informative without altering the underlying schema structure.',\n    documented_schema='\"Description for table: Edition\"\\ntype Edition @entity {\\n  \"Unique identifier for the edition.\"\\n  id: ID!\\n  \"Version number of the edition.\"\\n  version: BigInt!\\n  \"Name or number of the edition.\"\\n  editionNmber: String!\\n  \"Type identifier for the edition.\"\\n  editionType: BigInt!\\n  \"Data associated with the edition, stored as bytes.\"\\n  editionData: Bytes\\n  \"Contract associated with the creator of the edition.\"\\n  creatorContract: CreatorContract\\n  \"Type of sales applicable to the edition.\"\\n  salesType: BigInt!\\n  \"Indicates if approval has been revoked.\"\\n  revokedApproval: Boolean!\\n  \"Timestamp when the edition was created.\"\\n  createdTimestamp: BigInt!\\n  \"List of token IDs associated with the edition.\"\\n  tokenIds: [String!]!\\n  \"Tokens derived from the edition.\"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \"URI for the token metadata.\"\\n  tokenURI: String!\\n  \"Account of the artist associated with the edition.\"\\n  artistAccount: Bytes!\\n  \"Commission rate for the artist.\"\\n  artistCommission: BigInt!\\n  \"Optional account for additional commission.\"\\n  optionalCommissionAccount: Bytes\\n  \"Rate for the optional commission.\"\\n  optionalCommissionRate: BigInt\\n  \"List of collaborators involved in the edition.\"\\n  collaborators: [Bytes!]!\\n  \"Collective associated with the edition.\"\\n  collective: Collective\\n  \"Indicates if offers are the only sales method.\"\\n  offersOnly: Boolean!\\n  \"Total supply of the edition.\"\\n  totalSupply: BigInt!\\n  \"Total number of editions available.\"\\n  totalAvailable: BigInt!\\n  \"Remaining supply of the edition.\"\\n  remainingSupply: BigInt!\\n  \"Total number of editions sold.\"\\n  totalSold: BigInt!\\n  \"Total number of editions burnt.\"\\n  totalBurnt: BigInt!\\n  \"Original size of the edition.\"\\n  originalEditionSize: BigInt!\\n  \"Override for secondary royalty in version 4.\"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \"Sales associated with the edition.\"\\n  sales: [Token!]!\\n  \"Total Ethereum spent on the edition.\"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \"Indicates if the edition is active.\"\\n  active: Boolean!\\n  \"Metadata associated with the edition.\"\\n  metadata: MetaData\\n  \"Indicates if the edition is a genesis edition.\"\\n  isGenesisEdition: Boolean!\\n  \"Indicates if the edition is enhanced.\"\\n  isEnhancedEdition: Boolean!\\n  \"Indicates if the edition is open.\"\\n  isOpenEdition: Boolean\\n  \"Indicates if the edition has a cover image.\"\\n  hasCoverImage: Boolean!\\n  \"Artist associated with the edition.\"\\n  artist: Artist\\n  \"Start date of the edition.\"\\n  startDate: BigInt!\\n  \"End date of the edition.\"\\n  endDate: BigInt!\\n  \"Seller in a reserve auction.\"\\n  reserveAuctionSeller: Bytes!\\n  \"Bidder in a reserve auction.\"\\n  reserveAuctionBidder: Bytes!\\n  \"Reserve price for the auction.\"\\n  reservePrice: BigInt!\\n  \"Current bid in the reserve auction.\"\\n  reserveAuctionBid: BigInt!\\n  \"Start date of the reserve auction.\"\\n  reserveAuctionStartDate: BigInt!\\n  \"Timestamp of the previous reserve auction end.\"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \"End timestamp of the reserve auction.\"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \"Number of times the reserve auction was extended.\"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \"Indicates if the reserve auction is in sudden death.\"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \"Total extension length in seconds for the reserve auction.\"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \"Indicates if the reserve auction has been resulted.\"\\n  isReserveAuctionResulted: Boolean!\\n  \"Date and time when the reserve auction was resulted.\"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \"Entity that resulted the reserve auction.\"\\n  reserveAuctionResulter: Bytes!\\n  \"Indicates if emergency exit is possible in the reserve auction.\"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \"Price of the edition in Wei'\n)",
      1
    ],
    [
      "Example({'database_schema': '\"Description for table: RewardToken\"\\ntype RewardToken @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: type\"\\n  type: RewardTokenType!\\n}', 'documented_schema': 'type RewardToken @entity @regularPolling {\\n  \" { Reward token type }-{ Smart contract address of the reward token } \"\\n  id: Bytes!\\n  \" Reference to the actual token \"\\n  token: Token!\\n  \" The type of the reward token \"\\n  type: RewardTokenType!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `RewardToken`, with three fields: `id`, `token`, and `type`. Each field is associated with a specific data type, and the schema includes placeholder comments for descriptions. The task is to provide concise and factual descriptions for each field based on their names and types.',\n    documented_schema='\"Description for table: RewardToken\"\\ntype RewardToken @entity @regularPolling {\\n  \"Unique identifier for the reward token\"\\n  id: Bytes!\\n  \"Reference to the associated token\"\\n  token: Token!\\n  \"Specifies the type of reward token\"\\n  type: RewardTokenType!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: LiquidityPool\"\\ntype LiquidityPool @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: liquidityToken\"\\n  liquidityToken: Token\\n  \"Description for column: liquidityTokenType\"\\n  liquidityTokenType: TokenType\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: rewardTokens\"\\n  rewardTokens: [RewardToken!]\\n  \"Description for column: fees\"\\n  fees: [LiquidityPoolFee!]!\\n  \"Description for column: isSingleSided\"\\n  isSingleSided: Boolean!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: createdBlockNumber\"\\n  createdBlockNumber: BigInt!\\n  \"Description for column: tick\"\\n  tick: BigInt\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: totalLiquidity\"\\n  totalLiquidity: BigInt!\\n  \"Description for column: totalLiquidityUSD\"\\n  totalLiquidityUSD: BigDecimal!\\n  \"Description for column: activeLiquidity\"\\n  activeLiquidity: BigInt!\\n  \"Description for column: activeLiquidityUSD\"\\n  activeLiquidityUSD: BigDecimal!\\n  \"Description for column: uncollectedProtocolSideTokenAmounts\"\\n  uncollectedProtocolSideTokenAmounts: [BigInt!]!\\n  \"Description for column: uncollectedProtocolSideValuesUSD\"\\n  uncollectedProtocolSideValuesUSD: [BigDecimal!]!\\n  \"Description for column: uncollectedSupplySideTokenAmounts\"\\n  uncollectedSupplySideTokenAmounts: [BigInt!]!\\n  \"Description for column: uncollectedSupplySideValuesUSD\"\\n  uncollectedSupplySideValuesUSD: [BigDecimal!]!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeByTokenAmount\"\\n  cumulativeVolumeByTokenAmount: [BigInt!]!\\n  \"Description for column: cumulativeVolumeByTokenUSD\"\\n  cumulativeVolumeByTokenUSD: [BigDecimal!]!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: inputTokenBalances\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Description for column: inputTokenBalancesUSD\"\\n  inputTokenBalancesUSD: [BigDecimal!]!\\n  \"Description for column: inputTokenWeights\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"Description for column: cumulativeDepositCount\"\\n  cumulativeDepositCount: Int!\\n  \"Description for column: cumulativeWithdrawCount\"\\n  cumulativeWithdrawCount: Int!\\n  \"Description for column: cumulativeSwapCount\"\\n  cumulativeSwapCount: Int!\\n  \"Description for column: positions\"\\n  positions: [Position!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: positionCount\"\\n  positionCount: Int!\\n  \"Description for column: openPositionCount\"\\n  openPositionCount: Int!\\n  \"Description for column: closedPositionCount\"\\n  closedPositionCount: Int!\\n  \"Description for column: lastSnapshotDayID\"\\n  lastSnapshotDayID: Int!\\n  \"Description for column: lastSnapshotHourID\"\\n  lastSnapshotHourID: Int!\\n  \"Description for column: lastUpdateTimestamp\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Description for column: lastUpdateBlockNumber\"\\n  lastUpdateBlockNumber: BigInt!\\n  \"Description for column: dailySnapshots\"\\n  dailySnapshots: [LiquidityPoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: hourlySnapshots\"\\n  hourlySnapshots: [LiquidityPoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: deposits\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: withdraws\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: swaps\"\\n  swaps: [Swap!]! @derivedFrom(field: \"pool\")\\n}', 'documented_schema': 'type LiquidityPool @entity @regularPolling {\\n  \" Smart contract address of the pool \"\\n  id: Bytes!\\n  \" The protocol this pool belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT) \"\\n  name: String\\n  \" Symbol of liquidity pool (e.g. 3CRV) \"\\n  symbol: String\\n  \" Token that is to represent ownership of liquidity \"\\n  liquidityToken: Token\\n  \" Type of token used to track liquidity \"\\n  liquidityTokenType: TokenType\\n  \" Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer \"\\n  inputTokens: [Token!]!\\n  \" Additional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon \"\\n  rewardTokens: [RewardToken!]\\n  \" Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee. ) \"\\n  fees: [LiquidityPoolFee!]!\\n  \" Whether this pool is single-sided (e.g. Bancor, Platypus\\'s Alternative Pool). The specifics of the implementation depends on the protocol. \"\\n  isSingleSided: Boolean!\\n  \" Creation timestamp \"\\n  createdTimestamp: BigInt!\\n  \" Creation block number \"\\n  createdBlockNumber: BigInt!\\n  \" Current tick representing the price of token0/token1 \"\\n  tick: BigInt\\n  \" Current TVL (Total Value Locked) of this pool in USD \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" The sum of all active and non-active liquidity for this pool. \"\\n  totalLiquidity: BigInt!\\n  \" The sum of all active and non-active liquidity in USD for this pool. \"\\n  totalLiquidityUSD: BigDecimal!\\n  \" All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick. \"\\n  activeLiquidity: BigInt!\\n  \" All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick. \"\\n  activeLiquidityUSD: BigDecimal!\\n  \" All protocol-side value locked in token amounts that remains uncollected and unused in the pool. \"\\n  uncollectedProtocolSideTokenAmounts: [BigInt!]!\\n  \" All protocol-side value locking in USD that remains uncollected and unused in the pool. \"\\n  uncollectedProtocolSideValuesUSD: [BigDecimal!]!\\n  \" All supply-side value locked in token amounts that remains uncollected and unused in the pool. \"\\n  uncollectedSupplySideTokenAmounts: [BigInt!]!\\n  \" All supply-side value locked in USD that remains uncollected and unused in the pool. \"\\n  uncollectedSupplySideValuesUSD: [BigDecimal!]!\\n  \" All revenue generated by the liquidity pool, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" All trade volume occurred for a specific input token, in native amount. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  cumulativeVolumeByTokenAmount: [BigInt!]!\\n  \" All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  cumulativeVolumeByTokenUSD: [BigDecimal!]!\\n  \" All historical trade volume occurred in this pool, in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Amount of input tokens in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalances: [BigInt!]!\\n  \" Amount of input tokens in USD in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalancesUSD: [BigDecimal!]!\\n  \" Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool \"\\n  inputTokenWeights: [BigDecimal!]!\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day, in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \" Total number of deposits (add liquidity) \"\\n  cumulativeDepositCount: Int!\\n  \" Total number of withdrawals (remove liquidity) \"\\n  cumulativeWithdrawCount: Int!\\n  \" Total number of trades (swaps) \"\\n  cumulativeSwapCount: Int!\\n  \" All positions in this market \"\\n  positions: [Position!]! @derivedFrom(field: \"pool\")\\n  \" Number of positions in this market \"\\n  positionCount: Int!\\n  \" Number of open positions in this market \"\\n  openPositionCount: Int!\\n  \" Number of closed positions in this market \"\\n  closedPositionCount: Int!\\n  \" Day ID of the most recent daily snapshot \"\\n  lastSnapshotDayID: Int!\\n  \" Hour ID of the most recent hourly snapshot \"\\n  lastSnapshotHourID: Int!\\n  \" Timestamp of the last time this entity was updated \"\\n  lastUpdateTimestamp: BigInt!\\n  \" Block number of the last time this entity was updated \"\\n  lastUpdateBlockNumber: BigInt!\\n  \" Liquidity pool daily snapshots \"\\n  dailySnapshots: [LiquidityPoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" Liquidity pool hourly snapshots \"\\n  hourlySnapshots: [LiquidityPoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" All deposit (add liquidity) events occurred in this pool \"\\n  deposits: [Deposit!]! @derivedFrom(field: \"pool\")\\n  \" All withdraw (remove liquidity) events occurred in this pool \"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"pool\")\\n  \" All trade (swap) events occurred in this pool \"\\n  swaps: [Swap!]! @derivedFrom(field: \"pool\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `LiquidityPool` entity with various fields, each having a specific data type and some with additional directives like `@derivedFrom`. The task is to document each field with a concise description based on the information given in the schema. The descriptions should be factual and directly related to the field's purpose or data type, without altering the schema structure.\",\n    documented_schema='\"Description for table: LiquidityPool\"\\ntype LiquidityPool @entity @regularPolling {\\n  \"Unique identifier for the liquidity pool.\"\\n  id: Bytes!\\n  \"Reference to the decentralized exchange protocol associated with the pool.\"\\n  protocol: DexAmmProtocol!\\n  \"Human-readable name of the liquidity pool.\"\\n  name: String\\n  \"Symbol representing the liquidity pool.\"\\n  symbol: String\\n  \"Token representing the liquidity provided in the pool.\"\\n  liquidityToken: Token\\n  \"Type of the liquidity token.\"\\n  liquidityTokenType: TokenType\\n  \"List of tokens that can be input into the pool.\"\\n  inputTokens: [Token!]!\\n  \"List of reward tokens distributed by the pool.\"\\n  rewardTokens: [RewardToken!]\\n  \"List of fees associated with the liquidity pool.\"\\n  fees: [LiquidityPoolFee!]!\\n  \"Indicates if the pool supports single-sided liquidity provision.\"\\n  isSingleSided: Boolean!\\n  \"Timestamp when the liquidity pool was created.\"\\n  createdTimestamp: BigInt!\\n  \"Block number when the liquidity pool was created.\"\\n  createdBlockNumber: BigInt!\\n  \"Current tick value of the pool, if applicable.\"\\n  tick: BigInt\\n  \"Total value locked in the pool, denominated in USD.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Total liquidity available in the pool.\"\\n  totalLiquidity: BigInt!\\n  \"Total liquidity available in the pool, denominated in USD.\"\\n  totalLiquidityUSD: BigDecimal!\\n  \"Active liquidity currently in use in the pool.\"\\n  activeLiquidity: BigInt!\\n  \"Active liquidity currently in use in the pool, denominated in USD.\"\\n  activeLiquidityUSD: BigDecimal!\\n  \"Amounts of tokens on the protocol side that are uncollected.\"\\n  uncollectedProtocolSideTokenAmounts: [BigInt!]!\\n  \"Values in USD of uncollected protocol side tokens.\"\\n  uncollectedProtocolSideValuesUSD: [BigDecimal!]!\\n  \"Amounts of tokens on the supply side that are uncollected.\"\\n  uncollectedSupplySideTokenAmounts: [BigInt!]!\\n  \"Values in USD of uncollected supply side tokens.\"\\n  uncollectedSupplySideValuesUSD: [BigDecimal!]!\\n  \"Cumulative revenue from the supply side, denominated in USD.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue from the protocol side, denominated in USD.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Total cumulative revenue, denominated in USD.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Cumulative volume of transactions by token amount.\"\\n  cumulativeVolumeByTokenAmount: [BigInt!]!\\n  \"Cumulative volume of transactions by token amount, denominated in USD.\"\\n  cumulativeVolumeByTokenUSD: [BigDecimal!]!\\n  \"Total cumulative volume of transactions, denominated in USD.\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Balances of input tokens in the pool.\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Balances of input tokens in the pool, denominated in USD.\"\\n  inputTokenBalancesUSD: [BigDecimal!]!\\n  \"Weights of input tokens in the pool.\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Amount of output tokens staked in the pool.\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Amounts of reward tokens emitted by the pool.\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Values in USD of reward tokens emitted by the pool.\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"Total number of deposit transactions.\"\\n  cumulativeDepositCount: Int!\\n  \"Total number of withdrawal transactions.\"\\n  cumulativeWithdrawCount: Int!\\n  \"Total number of swap transactions.\"\\n  cumulativeSwapCount: Int!\\n  \"List of positions associated with the pool.\"\\n  positions: [Position!]! @derivedFrom(field: \"pool\")\\n  \"Total number of positions in the pool.\"\\n  positionCount: Int!\\n  \"Number of open positions in the pool.\"\\n  openPositionCount: Int!\\n  \"Number of closed positions in the pool.\"\\n  closedPositionCount: Int!\\n  \"ID of the last daily snapshot.\"\\n  lastSnapshotDayID: Int!\\n  \"ID of the last hourly snapshot.\"\\n  lastSnapshotHourID: Int!\\n  \"Timestamp of the last update to the pool.\"\\n  lastUpdateTimestamp'\n)",
      1
    ]
  ]
}