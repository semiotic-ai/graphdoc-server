```graphql
enum Network {
  ARBITRUM_ONE
  ARWEAVE_MAINNET
  AURORA
  AVALANCHE
  BOBA
  BSC
  CELO
  COSMOS
  CRONOS
  MAINNET
  FANTOM
  FUSE
  HARMONY
  JUNO
  MOONBEAM
  MOONRIVER
  NEAR_MAINNET
  OPTIMISM
  OSMOSIS
  MATIC
  XDAI
}

enum NftStandard {
  ERC721
  ERC1155
  UNKNOWN
}

enum SaleStrategy {
  STANDARD_SALE
  ANY_ITEM_FROM_COLLECTION
  ANY_ITEM_FROM_SET
  DUTCH_AUCTION
  PRIVATE_SALE
}

type Marketplace @entity @regularPolling {
  id: ID!
  name: String! // ERC20 marketplace name
  slug: String! // NFT marketplace slug
  network: Network! // Network on which the marketplace operates
  schemaVersion: String! // Version of the schema
  subgraphVersion: String! // Version of the subgraph
  methodologyVersion: String! // Version of the methodology
  collectionCount: Int! // Number of collections listed
  tradeCount: Int! // Trade count of a single collection
  cumulativeTradeVolumeETH: BigDecimal! // Total trade volume in ETH
  marketplaceRevenueETH: BigDecimal! // Revenue of the marketplace in ETH
  creatorRevenueETH: BigDecimal! // Revenue of the creator in ETH
  totalRevenueETH: BigDecimal! // Total revenue in ETH
  cumulativeUniqueTraders: Int! // Number of unique traders
}

type Collection @entity @regularPolling {
  id: ID!
  name: String // Collection name
  symbol: String // Collection symbol
  totalSupply: BigInt // Total supply of the collection
  nftStandard: NftStandard! // Standard of the NFTs in the collection
  royaltyFee: BigDecimal! // Royalty fee for the collection
  cumulativeTradeVolumeETH: BigDecimal! // Total trade volume of the collection in ETH
  marketplaceRevenueETH: BigDecimal! // Revenue of the marketplace from the collection in ETH
  creatorRevenueETH: BigDecimal! // Revenue of the creator from the collection in ETH
  totalRevenueETH: BigDecimal! // Total revenue from the collection in ETH
  tradeCount: Int! // Number of trades of the collection
  buyerCount: Int! // Number of buyers of the collection
  sellerCount: Int! // Number of sellers of the collection
  trades: [Trade!]! @derivedFrom(field: "collection") // Trades of the collection
}

type Trade @entity @transaction {
  id: ID!
  transactionHash: String! // Hash of the transaction
  logIndex: Int // Index of the log
  timestamp: BigInt! // Timestamp of the trade
  blockNumber: BigInt! // Block number of the trade
  isBundle: Boolean! // Whether the trade is a bundle
  collection: Collection! // Collection to which the trade belongs
  tokenId: BigInt! // ID of