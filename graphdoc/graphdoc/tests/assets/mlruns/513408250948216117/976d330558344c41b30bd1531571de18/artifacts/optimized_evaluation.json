{
  "overall_score": 1088.73,
  "scores": [
    16,
    9,
    1,
    16,
    9,
    16,
    9,
    16,
    9,
    16,
    16,
    16,
    9,
    9,
    9,
    16,
    9,
    9,
    9,
    16,
    16,
    9,
    1,
    9,
    16,
    9,
    9,
    16,
    9,
    9,
    9,
    16,
    9,
    9,
    1,
    16,
    16,
    16,
    9,
    16,
    9,
    9,
    9,
    4,
    9,
    9,
    9,
    9,
    16,
    9,
    9,
    9,
    16,
    16,
    9,
    9,
    16,
    16,
    4,
    16,
    4,
    16,
    9,
    9,
    9,
    9,
    16,
    16,
    1,
    16,
    1
  ],
  "results": [
    [
      "Example({'database_schema': '\"Description for table: UsageMetricsHourlySnapshot\"\\ntype UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hours\"\\n  hours: Int!\\n  \"Description for column: protocol\"\\n  protocol: LendingProtocol!\\n  \"Description for column: hourlyActiveUsers\"\\n  hourlyActiveUsers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: cumulativeUniqueTxSigners\"\\n  cumulativeUniqueTxSigners: Int!\\n  \"Description for column: hourlyTransactionCount\"\\n  hourlyTransactionCount: Int!\\n  \"Description for column: hourlyDepositCount\"\\n  hourlyDepositCount: Int!\\n  \"Description for column: hourlyWithdrawCount\"\\n  hourlyWithdrawCount: Int!\\n  \"Description for column: hourlyBorrowCount\"\\n  hourlyBorrowCount: Int!\\n  \"Description for column: hourlyRepayCount\"\\n  hourlyRepayCount: Int!\\n  \"Description for column: hourlyLiquidateCount\"\\n  hourlyLiquidateCount: Int!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}', 'documented_schema': 'type UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \" { # of hours since Unix epoch time } \"\\n  id: Bytes!\\n  \" Number of hours since Unix epoch time \"\\n  hours: Int!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: LendingProtocol!\\n  \" Number of unique hourly active users \"\\n  hourlyActiveUsers: Int!\\n  \" Number of cumulative unique users. e.g. accounts that spent gas to interact with this protocol \"\\n  cumulativeUniqueUsers: Int!\\n  \" Number of cumulative unique users. e.g. accounts that signed transactions to interact with this market \"\\n  cumulativeUniqueTxSigners: Int!\\n  \" Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface. \"\\n  hourlyTransactionCount: Int!\\n  \" Total number of deposits in an hour \"\\n  hourlyDepositCount: Int!\\n  \" Total number of withdrawals in an hour \"\\n  hourlyWithdrawCount: Int!\\n  \" Total number of borrows/mints in an hour \"\\n  hourlyBorrowCount: Int!\\n  \" Total number of repayments/burns in an hour \"\\n  hourlyRepayCount: Int!\\n  \" Total number of liquidations in an hour \"\\n  hourlyLiquidateCount: Int!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema represents a GraphQL type named `UsageMetricsHourlySnapshot`, which is annotated with `@entity` and `@hourlySnapshot`, indicating it is used to capture hourly snapshots of usage metrics for a lending protocol. Each field within this type has a specific role in capturing different aspects of usage data. The task is to provide clear and concise descriptions for each field based on their names and types, ensuring that the documentation is informative and aids in understanding the purpose of each field without altering the schema structure.',\n    documented_schema='\"Description for table: UsageMetricsHourlySnapshot\"\\ntype UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \"Unique identifier for the snapshot, represented as a byte array.\"\\n  id: Bytes!\\n  \"The number of hours since a reference point, used to index the snapshot.\"\\n  hours: Int!\\n  \"Reference to the lending protocol associated with this snapshot.\"\\n  protocol: LendingProtocol!\\n  \"Number of unique users active during the hour.\"\\n  hourlyActiveUsers: Int!\\n  \"Total number of unique users that have interacted with the protocol up to this hour.\"\\n  cumulativeUniqueUsers: Int!\\n  \"Total number of unique transaction signers up to this hour.\"\\n  cumulativeUniqueTxSigners: Int!\\n  \"Total number of transactions that occurred during the hour.\"\\n  hourlyTransactionCount: Int!\\n  \"Number of deposit transactions that occurred during the hour.\"\\n  hourlyDepositCount: Int!\\n  \"Number of withdrawal transactions that occurred during the hour.\"\\n  hourlyWithdrawCount: Int!\\n  \"Number of borrow transactions that occurred during the hour.\"\\n  hourlyBorrowCount: Int!\\n  \"Number of repay transactions that occurred during the hour.\"\\n  hourlyRepayCount: Int!\\n  \"Number of liquidation transactions that occurred during the hour.\"\\n  hourlyLiquidateCount: Int!\\n  \"The block number at which the snapshot was taken.\"\\n  blockNumber: BigInt!\\n  \"The timestamp indicating when the snapshot was recorded.\"\\n  timestamp: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: VaultFee\"\\ntype VaultFee @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: feePercentage\"\\n  feePercentage: BigDecimal\\n  \"Description for column: feeType\"\\n  feeType: VaultFeeType!\\n}', 'documented_schema': 'type VaultFee @entity @regularPolling {\\n  \" { Vault fee type }-{ Vault address } \"\\n  id: ID!\\n  \" Fee as a percentage of the trade (swap) amount. Does not always apply \"\\n  feePercentage: BigDecimal\\n  \" Type of fee this vault uses \"\\n  feeType: VaultFeeType!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema defines a GraphQL entity named `VaultFee`, which includes three fields: `id`, `feePercentage`, and `feeType`. Each field has a specific data type and purpose within the schema. The `id` field is a unique identifier for each `VaultFee` entry. The `feePercentage` field represents the percentage of the fee associated with the vault, and it is of type `BigDecimal`, which is suitable for precise decimal calculations. The `feeType` field is an enumeration of type `VaultFeeType`, indicating the category or nature of the fee.',\n    documented_schema='\"Description for table: VaultFee\"\\ntype VaultFee @entity @regularPolling {\\n  \"Unique identifier for the VaultFee entry.\"\\n  id: ID!\\n  \"The percentage value of the fee applied to the vault.\"\\n  feePercentage: BigDecimal\\n  \"The type or category of the fee, represented as an enumeration.\"\\n  feeType: VaultFeeType!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for enum type: Network\"\\nenum Network {\\n  \"Description for column: ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"Description for column: AURORA\"\\n  AURORA\\n  \"Description for column: AVALANCHE\"\\n  AVALANCHE\\n  \"Description for column: BSC\"\\n  BSC\\n  \"Description for column: CELO\"\\n  CELO\\n  \"Description for column: CRONOS\"\\n  CRONOS\\n  \"Description for column: MAINNET\"\\n  MAINNET\\n  \"Description for column: FANTOM\"\\n  FANTOM\\n  \"Description for column: FUSE\"\\n  FUSE\\n  \"Description for column: HARMONY\"\\n  HARMONY\\n  \"Description for column: JUNO\"\\n  JUNO\\n  \"Description for column: MOONBEAM\"\\n  MOONBEAM\\n  \"Description for column: MOONRIVER\"\\n  MOONRIVER\\n  \"Description for column: NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"Description for column: OPTIMISM\"\\n  OPTIMISM\\n  \"Description for column: MATIC\"\\n  MATIC\\n  \"Description for column: XDAI\"\\n  XDAI\\n}\\n\\n\"Description for enum type: ProtocolType\"\\nenum ProtocolType {\\n  \"Description for column: EXCHANGE\"\\n  EXCHANGE\\n  \"Description for column: LENDING\"\\n  LENDING\\n  \"Description for column: YIELD\"\\n  YIELD\\n  \"Description for column: BRIDGE\"\\n  BRIDGE\\n}\\n\\n\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: symbol\"\\n  symbol: String!\\n  \"Description for column: decimals\"\\n  decimals: Int!\\n  \"Description for column: lastPriceUSD\"\\n  lastPriceUSD: BigDecimal\\n  \"Description for column: lastPriceBlockNumber\"\\n  lastPriceBlockNumber: BigInt\\n  \"Description for column: _poolToken\"\\n  _poolToken: Token\\n}\\n\\n\"Description for enum type: RewardTokenType\"\\nenum RewardTokenType {\\n  \"Description for column: DEPOSIT\"\\n  DEPOSIT\\n  \"Description for column: BORROW\"\\n  BORROW\\n}\\n\\n\"Description for table: RewardToken\"\\ntype RewardToken @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: type\"\\n  type: RewardTokenType!\\n}\\n\\n\"Description for enum type: LiquidityPoolFeeType\"\\nenum LiquidityPoolFeeType {\\n  \"Description for column: FIXED_TRADING_FEE\"\\n  FIXED_TRADING_FEE\\n  \"Description for column: TIERED_TRADING_FEE\"\\n  TIERED_TRADING_FEE\\n  \"Description for column: DYNAMIC_TRADING_FEE\"\\n  DYNAMIC_TRADING_FEE\\n  \"Description for column: FIXED_LP_FEE\"\\n  FIXED_LP_FEE\\n  \"Description for column: DYNAMIC_LP_FEE\"\\n  DYNAMIC_LP_FEE\\n  \"Description for column: FIXED_PROTOCOL_FEE\"\\n  FIXED_PROTOCOL_FEE\\n  \"Description for column: DYNAMIC_PROTOCOL_FEE\"\\n  DYNAMIC_PROTOCOL_FEE\\n  \"Description for column: DEPOSIT_FEE\"\\n  DEPOSIT_FEE\\n  \"Description for column: WITHDRAWAL_FEE\"\\n  WITHDRAWAL_FEE\\n}\\n\\n\"Description for table: LiquidityPoolFee\"\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: feePercentage\"\\n  feePercentage: BigDecimal\\n  \"Description for column: feeType\"\\n  feeType: LiquidityPoolFeeType!\\n}\\n\\n\"Description for column: LiquidityPoolFee\"\\ninterface Protocol {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: type\"\\n  type: ProtocolType!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: dailyUsageMetrics\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: hourlyUsageMetrics\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: financialMetrics\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}\\n\\n\"Description for table: DexAmmProtocol\"\\ntype DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: type\"\\n  type: ProtocolType!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: dailyUsageMetrics\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: hourlyUsageMetrics\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: financialMetrics\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: pools\"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: _poolIDs\"\\n  _poolIDs: [ID!]!\\n  \"Description for column: _defaultTradingFeeRate\"\\n  _defaultTradingFeeRate: BigDecimal!\\n  \"Description for column: _networkFeeRate\"\\n  _networkFeeRate: BigDecimal!\\n  \"Description for column: _withdrawalFeeRate\"\\n  _withdrawalFeeRate: BigDecimal!\\n}\\n\\n\"Description for table: UsageMetricsDailySnapshot\"\\ntype UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: dailyActiveUsers\"\\n  dailyActiveUsers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: dailyTransactionCount\"\\n  dailyTransactionCount: Int!\\n  \"Description for column: dailyDepositCount\"\\n  dailyDepositCount: Int!\\n  \"Description for column: dailyWithdrawCount\"\\n  dailyWithdrawCount: Int!\\n  \"Description for column: dailySwapCount\"\\n  dailySwapCount: Int!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: UsageMetricsHourlySnapshot\"\\ntype UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: hourlyActiveUsers\"\\n  hourlyActiveUsers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: hourlyTransactionCount\"\\n  hourlyTransactionCount: Int!\\n  \"Description for column: hourlyDepositCount\"\\n  hourlyDepositCount: Int!\\n  \"Description for column: hourlyWithdrawCount\"\\n  hourlyWithdrawCount: Int!\\n  \"Description for column: hourlySwapCount\"\\n  hourlySwapCount: Int!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: dailyVolumeUSD\"\\n  dailyVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: dailySupplySideRevenueUSD\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyProtocolSideRevenueUSD\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyTotalRevenueUSD\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: LiquidityPool\"\\ntype LiquidityPool @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: rewardTokens\"\\n  rewardTokens: [RewardToken!]\\n  \"Description for column: fees\"\\n  fees: [LiquidityPoolFee!]!\\n  \"Description for column: isSingleSided\"\\n  isSingleSided: Boolean!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: createdBlockNumber\"\\n  createdBlockNumber: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: inputTokenBalances\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Description for column: inputTokenWeights\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Description for column: outputTokenSupply\"\\n  outputTokenSupply: BigInt\\n  \"Description for column: outputTokenPriceUSD\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"Description for column: dailySnapshots\"\\n  dailySnapshots: [LiquidityPoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: hourlySnapshots\"\\n  hourlySnapshots: [LiquidityPoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: deposits\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: withdraws\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: swaps\"\\n  swaps: [Swap!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: _tradingFeeRate\"\\n  _tradingFeeRate: BigDecimal!\\n  \"Description for column: _cumulativeTradingFeeAmountUSD\"\\n  _cumulativeTradingFeeAmountUSD: BigDecimal!\\n  \"Description for column: _cumulativeWithdrawalFeeAmountUSD\"\\n  _cumulativeWithdrawalFeeAmountUSD: BigDecimal!\\n  \"Description for column: _latestRewardProgramID\"\\n  _latestRewardProgramID: BigInt!\\n}\\n\\n\"Description for table: LiquidityPoolDailySnapshot\"\\ntype LiquidityPoolDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: dailySupplySideRevenueUSD\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyProtocolSideRevenueUSD\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: dailyTotalRevenueUSD\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: dailyVolumeUSD\"\\n  dailyVolumeUSD: BigDecimal!\\n  \"Description for column: dailyVolumeByTokenAmount\"\\n  dailyVolumeByTokenAmount: [BigInt!]!\\n  \"Description for column: dailyVolumeByTokenUSD\"\\n  dailyVolumeByTokenUSD: [BigDecimal!]!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: inputTokenBalances\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Description for column: inputTokenWeights\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Description for column: outputTokenSupply\"\\n  outputTokenSupply: BigInt\\n  \"Description for column: outputTokenPriceUSD\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n}\\n\\n\"Description for table: LiquidityPoolHourlySnapshot\"\\ntype LiquidityPoolHourlySnapshot @entity @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: hourlySupplySideRevenueUSD\"\\n  hourlySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: hourlyProtocolSideRevenueUSD\"\\n  hourlyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: hourlyTotalRevenueUSD\"\\n  hourlyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: hourlyVolumeUSD\"\\n  hourlyVolumeUSD: BigDecimal!\\n  \"Description for column: hourlyVolumeByTokenAmount\"\\n  hourlyVolumeByTokenAmount: [BigInt!]!\\n  \"Description for column: hourlyVolumeByTokenUSD\"\\n  hourlyVolumeByTokenUSD: [BigDecimal!]!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: inputTokenBalances\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Description for column: inputTokenWeights\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Description for column: outputTokenSupply\"\\n  outputTokenSupply: BigInt\\n  \"Description for column: outputTokenPriceUSD\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n}\\n\\n\"Description for column: LiquidityPoolHourlySnapshot\"\\ninterface Event {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: Deposit\"\\ntype Deposit implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: inputTokenAmounts\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Description for column: outputTokenAmount\"\\n  outputTokenAmount: BigInt\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n}\\n\\n\"Description for table: Withdraw\"\\ntype Withdraw implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: inputTokenAmounts\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Description for column: outputTokenAmount\"\\n  outputTokenAmount: BigInt\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: _withdrawalFeeAmount\"\\n  _withdrawalFeeAmount: BigInt!\\n  \"Description for column: _withdrawalFeeAmountUSD\"\\n  _withdrawalFeeAmountUSD: BigDecimal!\\n}\\n\\n\"Description for table: Swap\"\\ntype Swap implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: tokenIn\"\\n  tokenIn: Token!\\n  \"Description for column: amountIn\"\\n  amountIn: BigInt!\\n  \"Description for column: amountInUSD\"\\n  amountInUSD: BigDecimal!\\n  \"Description for column: tokenOut\"\\n  tokenOut: Token!\\n  \"Description for column: amountOut\"\\n  amountOut: BigInt!\\n  \"Description for column: amountOutUSD\"\\n  amountOutUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: _tradingFeeAmount\"\\n  _tradingFeeAmount: BigInt!\\n  \"Description for column: _tradingFeeAmountUSD\"\\n  _tradingFeeAmountUSD: BigDecimal!\\n}\\n\\n\"Description for table: Account\"\\ntype Account @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n}\\n\\n\"Description for table: ActiveAccount\"\\ntype ActiveAccount @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n}\\n\\n\"Description for table: RewardProgram\"\\ntype RewardProgram @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: enabled\"\\n  enabled: Boolean!\\n  \"Description for column: totalRewards\"\\n  totalRewards: BigInt!\\n  \"Description for column: startTime\"\\n  startTime: BigInt!\\n  \"Description for column: endTime\"\\n  endTime: BigInt!\\n  \"Description for column: rewardsRate\"\\n  rewardsRate: BigInt!\\n}', 'documented_schema': '\" Network enum for the schema \"\\nenum Network {\\n  \" The ARBITRUM_ONE network \"\\n  ARBITRUM_ONE\\n  \" The AURORA network \"\\n  AURORA\\n  \" The AVALANCHE network \"\\n  AVALANCHE\\n  \" The BSC network \"\\n  BSC\\n  \" The CELO network \"\\n  CELO\\n  \" The CRONOS network \"\\n  CRONOS\\n  \" The ETHEREUM_MAINNET network \"\\n  MAINNET\\n  \" The FANTOM network \"\\n  FANTOM\\n  \" The FUSE network \"\\n  FUSE\\n  \" The HARMONY network \"\\n  HARMONY\\n  \" The JUNO network \"\\n  JUNO\\n  \" The MOONBEAM network \"\\n  MOONBEAM\\n  \" The MOONRIVER network \"\\n  MOONRIVER\\n  \" The NEAR_MAINNET network \"\\n  NEAR_MAINNET\\n  \" The OPTIMISM network \"\\n  OPTIMISM\\n  \" The MATIC network \"\\n  MATIC\\n  \" The XDAI network \"\\n  XDAI\\n}\\n\\n\" Protocol type enum for the schema \"\\nenum ProtocolType {\\n  \" The EXCHANGE protocol type \"\\n  EXCHANGE\\n  \" The LENDING protocol type \"\\n  LENDING\\n  \" The YIELD protocol type \"\\n  YIELD\\n  \" The BRIDGE protocol type \"\\n  BRIDGE\\n}\\n\\ntype Token @entity @regularPolling {\\n  \" Smart contract address of the token \"\\n  id: ID!\\n  \" Name of the token, mirrored from the smart contract \"\\n  name: String!\\n  \" Symbol of the token, mirrored from the smart contract \"\\n  symbol: String!\\n  \" The number of decimal places this token uses, default to 18 \"\\n  decimals: Int!\\n  \" Optional field to track the price of a token, mostly for caching purposes \"\\n  lastPriceUSD: BigDecimal\\n  \" Optional field to track the block number of the last token price \"\\n  lastPriceBlockNumber: BigInt\\n  _poolToken: Token\\n}\\n\\nenum RewardTokenType {\\n  \" For reward tokens awarded to LPs/lenders \"\\n  DEPOSIT\\n  \" For reward tokens awarded to borrowers \"\\n  BORROW\\n}\\n\\ntype RewardToken @entity @regularPolling {\\n  \" { Reward token type }-{ Smart contract address of the reward token } \"\\n  id: ID!\\n  \" Reference to the actual token \"\\n  token: Token!\\n  \" The type of the reward token \"\\n  type: RewardTokenType!\\n}\\n\\nenum LiquidityPoolFeeType {\\n  \" Total fixed fee paid by the user per trade, as a percentage of the traded amount. e.g. 0.3% for Uniswap v2, 0.3% for Sushiswap, 0.04% for Curve v1. \"\\n  FIXED_TRADING_FEE\\n  \" Some protocols use tiered fees instead of fixed fee (e.g. DYDX, DODO). Set `feePercentage` as 0 but handle the tiered fees in the mapping code. \"\\n  TIERED_TRADING_FEE\\n  \" Some protocols use dynamic fees instead of fixed fee (e.g. Balancer v2). Set `feePercentage` as 0 but handle the dynamic fees in the mapping code. \"\\n  DYNAMIC_TRADING_FEE\\n  \" Fixed fee that\\'s paid to the LP, as a percentage of the traded amount. e.g. 0.25% for Sushiswap, 0.02% for Curve v1. \"\\n  FIXED_LP_FEE\\n  \" Some protocols use dynamic LP fees (e.g., Bancor v2). Set `feePercentage` as 0 but handle the dynamic fees in the mapping code. \"\\n  DYNAMIC_LP_FEE\\n  \" Fixed fee that\\'s paid to the protocol, as a percentage of the traded amount. e.g. 0.05% for Sushiswap, 0.02% for Curve v1. \"\\n  FIXED_PROTOCOL_FEE\\n  \" Some protocols use dynamic protocol fees (e.g., Bancor v2). Set `feePercentage` as 0 but handle the dynamic fees in the mapping code. \"\\n  DYNAMIC_PROTOCOL_FEE\\n  \" One-time fee charged by the protocol during deposit, in percentages of the deposit token \"\\n  DEPOSIT_FEE\\n  \" One-time fee charged by the protocol (e.g. Bancor v3) during withdrawal, in percentages of the withdrawal token \"\\n  WITHDRAWAL_FEE\\n}\\n\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \" { Fee type }-{ Pool address } \"\\n  id: ID!\\n  \" Fee as a percentage of the trade (swap) amount. Does not always apply \"\\n  feePercentage: BigDecimal\\n  \" Type of fee this pool uses \"\\n  feeType: LiquidityPoolFeeType!\\n}\\n\\ninterface Protocol {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: ID!\\n  \" Name of the protocol, including version. e.g. Uniswap v3 \"\\n  name: String!\\n  \" Slug of protocol, including version. e.g. uniswap-v3 \"\\n  slug: String!\\n  \" Version of the subgraph schema, in SemVer format (e.g. 1.0.0) \"\\n  schemaVersion: String!\\n  \" Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) \"\\n  subgraphVersion: String!\\n  \" Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) \"\\n  methodologyVersion: String!\\n  \" The blockchain network this subgraph is indexing on \"\\n  network: Network!\\n  \" The type of protocol (e.g. DEX, Lending, Yield, etc) \"\\n  type: ProtocolType!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" # of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Daily usage metrics for this protocol \"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Hourly usage metrics for this protocol \"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Daily financial metrics for this protocol \"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}\\n\\ntype DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: ID!\\n  \" Name of the protocol, including version. e.g. Uniswap v3 \"\\n  name: String!\\n  \" Slug of protocol, including version. e.g. uniswap-v3 \"\\n  slug: String!\\n  \" Version of the subgraph schema, in SemVer format (e.g. 1.0.0) \"\\n  schemaVersion: String!\\n  \" Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) \"\\n  subgraphVersion: String!\\n  \" Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) \"\\n  methodologyVersion: String!\\n  \" The blockchain network this subgraph is indexing on \"\\n  network: Network!\\n  \" The type of protocol (e.g. DEX, Lending, Yield, etc) \"\\n  type: ProtocolType!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" All historical volume in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" # of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Daily usage metrics for this protocol \"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Hourly usage metrics for this protocol \"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Daily financial metrics for this protocol \"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" All pools that belong to this protocol \"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \" Liquidity pool IDs \"\\n  _poolIDs: [ID!]!\\n  \" Default trading fee rate (0-1) that applies at the protocol level \"\\n  _defaultTradingFeeRate: BigDecimal!\\n  \" Netfork fee rate (0-1) that applies at the protocol level. It goes to protocol fee \"\\n  _networkFeeRate: BigDecimal!\\n  \" Withdrawal fee rate (0-1) that applies at the protocol level. Occurs whenver user withdraws. It goes to protocol fee \"\\n  _withdrawalFeeRate: BigDecimal!\\n}\\n\\ntype UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: ID!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" # of unique daily active users \"\\n  dailyActiveUsers: Int!\\n  \" # of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface. \"\\n  dailyTransactionCount: Int!\\n  \" Total number of deposits (add liquidity) in a day \"\\n  dailyDepositCount: Int!\\n  \" Total number of withdrawals (remove liquidity) in a day \"\\n  dailyWithdrawCount: Int!\\n  \" Total number of trades (swaps) in a day \"\\n  dailySwapCount: Int!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}\\n\\ntype UsageMetricsHourlySnapshot @entity @hourlySnapshot {\\n  \" { # of hours since Unix epoch time } \"\\n  id: ID!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" # of unique hourly active users \"\\n  hourlyActiveUsers: Int!\\n  \" # of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface. \"\\n  hourlyTransactionCount: Int!\\n  \" Total number of deposits (add liquidity) in an hour \"\\n  hourlyDepositCount: Int!\\n  \" Total number of withdrawals (remove liquidity) in an hour \"\\n  hourlyWithdrawCount: Int!\\n  \" Total number of trades (swaps) in an hour \"\\n  hourlySwapCount: Int!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}\\n\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: ID!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" All trade volume occurred in a given day, in USD \"\\n  dailyVolumeUSD: BigDecimal!\\n  \" All historical trade volume in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}\\n\\ntype LiquidityPool @entity @regularPolling {\\n  \" Smart contract address of the pool \"\\n  id: ID!\\n  \" The protocol this pool belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT) \"\\n  name: String\\n  \" Symbol of liquidity pool (e.g. 3CRV) \"\\n  symbol: String\\n  \" Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer \"\\n  inputTokens: [Token!]!\\n  \" Token that is minted to track ownership of position in protocol \"\\n  outputToken: Token\\n  \" Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon \"\\n  rewardTokens: [RewardToken!]\\n  \" Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee. ) \"\\n  fees: [LiquidityPoolFee!]!\\n  \" Whether this pool is single-sided (e.g. Bancor, Platypus\\'s Alternative Pool). The specifics of the implementation depends on the protocol. \"\\n  isSingleSided: Boolean!\\n  \" Creation timestamp \"\\n  createdTimestamp: BigInt!\\n  \" Creation block number \"\\n  createdBlockNumber: BigInt!\\n  \" Current TVL (Total Value Locked) of this pool in USD \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" All historical trade volume occurred in this pool, in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Amount of input tokens in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalances: [BigInt!]!\\n  \" Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool \"\\n  inputTokenWeights: [BigDecimal!]!\\n  \" Total supply of output token. Note that certain DEXes don\\'t have an output token (e.g. Bancor) \"\\n  outputTokenSupply: BigInt\\n  \" Price per share of output token in USD \"\\n  outputTokenPriceUSD: BigDecimal\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day, in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \" Liquidity pool daily snapshots \"\\n  dailySnapshots: [LiquidityPoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" Liquidity pool hourly snapshots \"\\n  hourlySnapshots: [LiquidityPoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" All deposit (add liquidity) events occurred in this pool \"\\n  deposits: [Deposit!]! @derivedFrom(field: \"pool\")\\n  \" All withdraw (remove liquidity) events occurred in this pool \"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"pool\")\\n  \" All trade (swap) events occurred in this pool \"\\n  swaps: [Swap!]! @derivedFrom(field: \"pool\")\\n  \" Trading fee rate (0-1) that applies at pool level \"\\n  _tradingFeeRate: BigDecimal!\\n  \" Cumulative trading fee in USD \"\\n  _cumulativeTradingFeeAmountUSD: BigDecimal!\\n  \" Cumulative withdrawal fee in USD \"\\n  _cumulativeWithdrawalFeeAmountUSD: BigDecimal!\\n  \" The latest reward program. It matches latestProgramId from the StandardRewards contract \"\\n  _latestRewardProgramID: BigInt!\\n}\\n\\ntype LiquidityPoolDailySnapshot @entity @dailySnapshot {\\n  \" { Smart contract address of the pool }-{ # of days since Unix epoch time } \"\\n  id: ID!\\n  \" The protocol this snapshot belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" The pool this snapshot belongs to \"\\n  pool: LiquidityPool!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n  \" Current TVL (Total Value Locked) of this pool \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Daily revenue generated by the liquidity pool, accrued to the supply side. \"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" Daily revenue generated by the liquidity pool, accrued to the protocol. \"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Daily revenue generated by the liquidity pool. \"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \" All trade volume occurred in a given day, in USD \"\\n  dailyVolumeUSD: BigDecimal!\\n  \" All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  dailyVolumeByTokenAmount: [BigInt!]!\\n  \" All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  dailyVolumeByTokenUSD: [BigDecimal!]!\\n  \" All historical trade volume occurred in this pool, in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Amount of input tokens in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalances: [BigInt!]!\\n  \" Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool \"\\n  inputTokenWeights: [BigDecimal!]!\\n  \" Total supply of output token. Note that certain DEXes don\\'t have an output token (e.g. Bancor) \"\\n  outputTokenSupply: BigInt\\n  \" Price per share of output token in USD \"\\n  outputTokenPriceUSD: BigDecimal\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day, in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n}\\n\\ntype LiquidityPoolHourlySnapshot @entity @hourlySnapshot {\\n  \" { Smart contract address of the pool }-{ # of hours since Unix epoch time } \"\\n  id: ID!\\n  \" The protocol this snapshot belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" The pool this snapshot belongs to \"\\n  pool: LiquidityPool!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n  \" Current TVL (Total Value Locked) of this pool \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Hourly revenue generated by the liquidity pool, accrued to the supply side. \"\\n  hourlySupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" Hourly revenue generated by the liquidity pool, accrued to the protocol. \"\\n  hourlyProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Hourly revenue generated by the liquidity pool. \"\\n  hourlyTotalRevenueUSD: BigDecimal!\\n  \" All trade volume occurred in a given hour, in USD \"\\n  hourlyVolumeUSD: BigDecimal!\\n  \" All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  hourlyVolumeByTokenAmount: [BigInt!]!\\n  \" All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  hourlyVolumeByTokenUSD: [BigDecimal!]!\\n  \" All historical trade volume occurred in this pool, in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Amount of input tokens in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalances: [BigInt!]!\\n  \" Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool \"\\n  inputTokenWeights: [BigDecimal!]!\\n  \" Total supply of output token. Note that certain DEXes don\\'t have an output token (e.g. Bancor) \"\\n  outputTokenSupply: BigInt\\n  \" Price per share of output token in USD \"\\n  outputTokenPriceUSD: BigDecimal\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day (not hour), in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n}\\n\\n\"\"\"\\nAn event is any user action that occurs in a protocol. Generally, they are Ethereum events\\nemitted by a function in the smart contracts, stored in transaction receipts as event logs.\\nHowever, some user actions of interest are function calls that don\\'t emit events. For example,\\nthe deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still\\nstore them as events, although they are not technically Ethereum events emitted by smart\\ncontracts.\\n\"\"\"\\ninterface Event {\\n  \" { Event type }-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n}\\n\\ntype Deposit implements Event @entity @transaction {\\n  \" deposit-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool \"\\n  inputTokens: [Token!]!\\n  \" Output token of the pool. E.g. the UNI-LP token \"\\n  outputToken: Token\\n  \" Amount of input tokens in the token\\'s native unit \"\\n  inputTokenAmounts: [BigInt!]!\\n  \" Amount of output tokens in the token\\'s native unit \"\\n  outputTokenAmount: BigInt\\n  \" USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool) \"\\n  amountUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n}\\n\\ntype Withdraw implements Event @entity @transaction {\\n  \" withdraw-{ Transaction hash }-{ Log index }\"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool \"\\n  inputTokens: [Token!]!\\n  \" Output token of the pool (not output token of the event/transaction). E.g. the UNI-LP token \"\\n  outputToken: Token\\n  \" Amount of input tokens in the token\\'s native unit \"\\n  inputTokenAmounts: [BigInt!]!\\n  \" Amount of output tokens in the token\\'s native unit \"\\n  outputTokenAmount: BigInt\\n  \" USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool) \"\\n  amountUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n  _withdrawalFeeAmount: BigInt!\\n  _withdrawalFeeAmountUSD: BigDecimal!\\n}\\n\\ntype Swap implements Event @entity @transaction {\\n  \" swap-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Token deposited into pool \"\\n  tokenIn: Token!\\n  \" Amount of token deposited into pool in native units \"\\n  amountIn: BigInt!\\n  \" Amount of token deposited into pool in USD \"\\n  amountInUSD: BigDecimal!\\n  \" Token withdrawn from pool \"\\n  tokenOut: Token!\\n  \" Amount of token withdrawn from pool in native units \"\\n  amountOut: BigInt!\\n  \" Amount of token withdrawn from pool in USD \"\\n  amountOutUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n  _tradingFeeAmount: BigInt!\\n  _tradingFeeAmountUSD: BigDecimal!\\n}\\n\\ntype Account @entity @regularPolling {\\n  \" Address of the account \"\\n  id: ID!\\n}\\n\\ntype ActiveAccount @entity {\\n  \" { daily/hourly }-{ Address of the account }-{ Days/hours since Unix epoch } \"\\n  id: ID!\\n}\\n\\ntype RewardProgram @entity {\\n  id: ID!\\n  pool: LiquidityPool!\\n  enabled: Boolean!\\n  totalRewards: BigInt!\\n  startTime: BigInt!\\n  endTime: BigInt!\\n  rewardsRate: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema includes several enum types, interfaces, and entity types, each with fields that require documentation. The task is to generate clear and concise descriptions for each field based on the existing structure and naming conventions. The descriptions should be factual and derived from the field names and types, ensuring they are informative for developers and system architects. The documentation should not alter the schema's structure but should enhance understanding by providing context and clarity.\",\n    documented_schema='\"Represents various blockchain networks.\"\\nenum Network {\\n  \"Arbitrum One network.\"\\n  ARBITRUM_ONE\\n  \"Aurora network.\"\\n  AURORA\\n  \"Avalanche network.\"\\n  AVALANCHE\\n  \"Binance Smart Chain network.\"\\n  BSC\\n  \"Celo network.\"\\n  CELO\\n  \"Cronos network.\"\\n  CRONOS\\n  \"Ethereum mainnet.\"\\n  MAINNET\\n  \"Fantom network.\"\\n  FANTOM\\n  \"Fuse network.\"\\n  FUSE\\n  \"Harmony network.\"\\n  HARMONY\\n  \"Juno network.\"\\n  JUNO\\n  \"Moonbeam network.\"\\n  MOONBEAM\\n  \"Moonriver network.\"\\n  MOONRIVER\\n  \"NEAR mainnet.\"\\n  NEAR_MAINNET\\n  \"Optimism network.\"\\n  OPTIMISM\\n  \"Polygon (Matic) network.\"\\n  MATIC\\n  \"xDai network.\"\\n  XDAI\\n}\\n\\n\"Defines types of protocols in the system.\"\\nenum ProtocolType {\\n  \"Exchange protocol type.\"\\n  EXCHANGE\\n  \"Lending protocol type.\"\\n  LENDING\\n  \"Yield protocol type.\"\\n  YIELD\\n  \"Bridge protocol type.\"\\n  BRIDGE\\n}\\n\\n\"Represents a token with its properties.\"\\ntype Token @entity @regularPolling {\\n  \"Unique identifier for the token.\"\\n  id: ID!\\n  \"Name of the token.\"\\n  name: String!\\n  \"Symbol representing the token.\"\\n  symbol: String!\\n  \"Number of decimal places for the token.\"\\n  decimals: Int!\\n  \"Last known price of the token in USD.\"\\n  lastPriceUSD: BigDecimal\\n  \"Block number at which the last price was recorded.\"\\n  lastPriceBlockNumber: BigInt\\n  \"Reference to a pool token, if applicable.\"\\n  _poolToken: Token\\n}\\n\\n\"Specifies types of reward tokens.\"\\nenum RewardTokenType {\\n  \"Reward token for deposits.\"\\n  DEPOSIT\\n  \"Reward token for borrowing.\"\\n  BORROW\\n}\\n\\n\"Represents a reward token with its type.\"\\ntype RewardToken @entity @regularPolling {\\n  \"Unique identifier for the reward token.\"\\n  id: ID!\\n  \"The token being rewarded.\"\\n  token: Token!\\n  \"Type of reward token.\"\\n  type: RewardTokenType!\\n}\\n\\n\"Defines types of fees in a liquidity pool.\"\\nenum LiquidityPoolFeeType {\\n  \"Fixed trading fee type.\"\\n  FIXED_TRADING_FEE\\n  \"Tiered trading fee type.\"\\n  TIERED_TRADING_FEE\\n  \"Dynamic trading fee type.\"\\n  DYNAMIC_TRADING_FEE\\n  \"Fixed liquidity provider fee type.\"\\n  FIXED_LP_FEE\\n  \"Dynamic liquidity provider fee type.\"\\n  DYNAMIC_LP_FEE\\n  \"Fixed protocol fee type.\"\\n  FIXED_PROTOCOL_FEE\\n  \"Dynamic protocol fee type.\"\\n  DYNAMIC_PROTOCOL_FEE\\n  \"Fee for deposits.\"\\n  DEPOSIT_FEE\\n  \"Fee for withdrawals.\"\\n  WITHDRAWAL_FEE\\n}\\n\\n\"Represents a fee structure in a liquidity pool.\"\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \"Unique identifier for the fee.\"\\n  id: ID!\\n  \"Percentage of the fee.\"\\n  feePercentage: BigDecimal\\n  \"Type of the fee.\"\\n  feeType: LiquidityPoolFeeType!\\n}\\n\\n\"Interface for protocol-related entities.\"\\ninterface Protocol {\\n  \"Unique identifier for the protocol.\"\\n  id: ID!\\n  \"Name of the protocol.\"\\n  name: String!\\n  \"Slug for the protocol.\"\\n  slug: String!\\n  \"Version of the schema used.\"\\n  schemaVersion: String!\\n  \"Version of the subgraph.\"\\n  subgraphVersion: String!\\n  \"Version of the methodology.\"\\n  methodologyVersion: String!\\n  \"Network on which the protocol operates.\"\\n  network: Network!\\n  \"Type of the protocol.\"\\n  type: ProtocolType!\\n  \"Total value locked in USD.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Value controlled by the protocol in USD.\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Cumulative revenue from the supply side in USD.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue from the protocol side in USD.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Cumulative total'\n)",
      1
    ],
    [
      "Example({'database_schema': '\"Description for table: Protocol\"\\ntype Protocol @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: type\"\\n  type: ProtocolType!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeDepositVolumeUSD\"\\n  cumulativeDepositVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeWithdrawalVolumeUSD\"\\n  cumulativeWithdrawalVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalVolumeUSD\"\\n  cumulativeTotalVolumeUSD: BigDecimal!\\n  \"Description for column: netVolumeUSD\"\\n  netVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeUniqueDepositors\"\\n  cumulativeUniqueDepositors: Int!\\n  \"Description for column: cumulativeUniqueWithdrawers\"\\n  cumulativeUniqueWithdrawers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: cumulativeDepositCount\"\\n  cumulativeDepositCount: Int!\\n  \"Description for column: cumulativeWithdrawalCount\"\\n  cumulativeWithdrawalCount: Int!\\n  \"Description for column: cumulativeTransactionCount\"\\n  cumulativeTransactionCount: Int!\\n  \"Description for column: totalEigenPodCount\"\\n  totalEigenPodCount: Int!\\n  \"Description for column: totalStrategyCount\"\\n  totalStrategyCount: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: pools\"\\n  pools: [Pool!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: dailyUsageMetrics\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: hourlyUsageMetrics\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: financialMetrics\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}', 'documented_schema': 'type Protocol @entity @regularPolling {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: Bytes!\\n  \" Name of the protocol, including version. e.g. Uniswap v3 \"\\n  name: String!\\n  \" Slug of protocol, including version. e.g. uniswap-v3 \"\\n  slug: String!\\n  \" Version of the subgraph schema, in SemVer format (e.g. 1.0.0) \"\\n  schemaVersion: String!\\n  \" Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) \"\\n  subgraphVersion: String!\\n  \" Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) \"\\n  methodologyVersion: String!\\n  \" The blockchain network this subgraph is indexing on \"\\n  network: Network!\\n  \" The type of protocol (e.g. DEX, Lending, Yield, etc) \"\\n  type: ProtocolType!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Cumulative value of staked eth deposited \"\\n  cumulativeDepositVolumeUSD: BigDecimal!\\n  \" Cumulative value of restaked eth withdrawn \"\\n  cumulativeWithdrawalVolumeUSD: BigDecimal!\\n  \" Volume deposited plus volume withdrawn \"\\n  cumulativeTotalVolumeUSD: BigDecimal!\\n  \" Volume deposited minus volume withdrawn \"\\n  netVolumeUSD: BigDecimal!\\n  \" Number of cumulative unique addresses that deposited staked eth \"\\n  cumulativeUniqueDepositors: Int!\\n  \" Number of cumulative unique addresses that withdrew restaked eth \"\\n  cumulativeUniqueWithdrawers: Int!\\n  \" Number of cumulative unique addresses \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of deposits \"\\n  cumulativeDepositCount: Int!\\n  \" Total number of withdrawals \"\\n  cumulativeWithdrawalCount: Int!\\n  \" Total number of transactions \"\\n  cumulativeTransactionCount: Int!\\n  \" Total number of EigenPods \"\\n  totalEigenPodCount: Int!\\n  \" Total number of Strategies \"\\n  totalStrategyCount: Int!\\n  \" Total number of (EigenPods plus Strategies) \"\\n  totalPoolCount: Int!\\n  \" All pools that belong to this protocol \"\\n  pools: [Pool!]! @derivedFrom(field: \"protocol\")\\n  \" Daily usage metrics for this protocol \"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Hourly usage metrics for this protocol \"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Daily financial metrics for this protocol \"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Protocol` entity with various fields, each having a specific data type and purpose. The task is to generate detailed descriptions for each field based on the information given in the schema. The descriptions should be clear, concise, and factual, providing insight into what each field represents without altering the schema's structure. The fields include identifiers, versioning information, financial metrics, and relationships to other entities. The descriptions will help developers and system architects understand the schema's components effectively.\",\n    documented_schema='\"Description for table: Protocol\"\\ntype Protocol @entity @regularPolling {\\n  \"Unique identifier for the protocol, represented as a byte array.\"\\n  id: Bytes!\\n  \"The name of the protocol.\"\\n  name: String!\\n  \"A URL-friendly version of the protocol name, typically used in web addresses.\"\\n  slug: String!\\n  \"The version of the schema used by the protocol.\"\\n  schemaVersion: String!\\n  \"The version of the subgraph associated with the protocol.\"\\n  subgraphVersion: String!\\n  \"The version of the methodology applied to the protocol.\"\\n  methodologyVersion: String!\\n  \"The blockchain network on which the protocol operates.\"\\n  network: Network!\\n  \"The type of protocol, as defined by the ProtocolType enum.\"\\n  type: ProtocolType!\\n  \"The total value locked in the protocol, measured in USD.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"The value controlled by the protocol itself, measured in USD.\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"The cumulative revenue generated by the supply side of the protocol, measured in USD.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"The cumulative revenue generated by the protocol side, measured in USD.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"The total cumulative revenue generated by the protocol, measured in USD.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"The cumulative volume of deposits made to the protocol, measured in USD.\"\\n  cumulativeDepositVolumeUSD: BigDecimal!\\n  \"The cumulative volume of withdrawals from the protocol, measured in USD.\"\\n  cumulativeWithdrawalVolumeUSD: BigDecimal!\\n  \"The total cumulative volume of transactions through the protocol, measured in USD.\"\\n  cumulativeTotalVolumeUSD: BigDecimal!\\n  \"The net volume of transactions, calculated as deposits minus withdrawals, measured in USD.\"\\n  netVolumeUSD: BigDecimal!\\n  \"The total number of unique depositors who have interacted with the protocol.\"\\n  cumulativeUniqueDepositors: Int!\\n  \"The total number of unique withdrawers who have interacted with the protocol.\"\\n  cumulativeUniqueWithdrawers: Int!\\n  \"The total number of unique users who have interacted with the protocol.\"\\n  cumulativeUniqueUsers: Int!\\n  \"The total number of deposit transactions made to the protocol.\"\\n  cumulativeDepositCount: Int!\\n  \"The total number of withdrawal transactions made from the protocol.\"\\n  cumulativeWithdrawalCount: Int!\\n  \"The total number of transactions made through the protocol.\"\\n  cumulativeTransactionCount: Int!\\n  \"The total number of EigenPods associated with the protocol.\"\\n  totalEigenPodCount: Int!\\n  \"The total number of strategies implemented by the protocol.\"\\n  totalStrategyCount: Int!\\n  \"The total number of pools available within the protocol.\"\\n  totalPoolCount: Int!\\n  \"A list of pools associated with the protocol, derived from the \\'protocol\\' field in the Pool entity.\"\\n  pools: [Pool!]! @derivedFrom(field: \"protocol\")\\n  \"A list of daily usage metrics snapshots associated with the protocol, derived from the \\'protocol\\' field in the UsageMetricsDailySnapshot entity.\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"A list of hourly usage metrics snapshots associated with the protocol, derived from the \\'protocol\\' field in the UsageMetricsHourlySnapshot entity.\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"A list of daily financial metrics snapshots associated with the protocol, derived from the \\'protocol\\' field in the FinancialsDailySnapshot entity.\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Position\"\\ntype Position @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: account\"\\n  account: Account!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: hashOpened\"\\n  hashOpened: Bytes!\\n  \"Description for column: hashClosed\"\\n  hashClosed: Bytes\\n  \"Description for column: blockNumberOpened\"\\n  blockNumberOpened: BigInt!\\n  \"Description for column: timestampOpened\"\\n  timestampOpened: BigInt!\\n  \"Description for column: blockNumberClosed\"\\n  blockNumberClosed: BigInt\\n  \"Description for column: timestampClosed\"\\n  timestampClosed: BigInt\\n  \"Description for column: tickLower\"\\n  tickLower: Tick\\n  \"Description for column: tickUpper\"\\n  tickUpper: Tick\\n  \"Description for column: liquidityToken\"\\n  liquidityToken: Token\\n  \"Description for column: liquidityTokenType\"\\n  liquidityTokenType: TokenType\\n  \"Description for column: liquidity\"\\n  liquidity: BigInt!\\n  \"Description for column: liquidityUSD\"\\n  liquidityUSD: BigDecimal!\\n  \"Description for column: cumulativeDepositTokenAmounts\"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \"Description for column: cumulativeDepositUSD\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Description for column: cumulativeWithdrawTokenAmounts\"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \"Description for column: cumulativeWithdrawUSD\"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \"Description for column: cumulativeRewardUSD\"\\n  cumulativeRewardUSD: [BigInt!]\\n  \"Description for column: depositCount\"\\n  depositCount: Int!\\n  \"Description for column: deposits\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \"Description for column: withdrawCount\"\\n  withdrawCount: Int!\\n  \"Description for column: withdraws\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \"Description for column: snapshots\"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n}', 'documented_schema': 'type Position @entity @regularPolling {\\n  \" { Account address }-{ Market address }-{ Count } \"\\n  id: Bytes!\\n  \" Account that owns this position \"\\n  account: Account!\\n  \" The liquidity pool in which this position was opened \"\\n  pool: LiquidityPool!\\n  \" The hash of the transaction that opened this position \"\\n  hashOpened: Bytes!\\n  \" The hash of the transaction that closed this position \"\\n  hashClosed: Bytes\\n  \" Block number of when the position was opened \"\\n  blockNumberOpened: BigInt!\\n  \" Timestamp when the position was opened \"\\n  timestampOpened: BigInt!\\n  \" Block number of when the position was closed (0 if still open) \"\\n  blockNumberClosed: BigInt\\n  \" Timestamp when the position was closed (0 if still open) \"\\n  timestampClosed: BigInt\\n  \" lower tick of the position \"\\n  tickLower: Tick\\n  \" upper tick of the position \"\\n  tickUpper: Tick\\n  \" Token that is to represent ownership of liquidity \"\\n  liquidityToken: Token\\n  \" Type of token used to track liquidity \"\\n  liquidityTokenType: TokenType\\n  \" total position liquidity \"\\n  liquidity: BigInt!\\n  \" total position liquidity in USD \"\\n  liquidityUSD: BigDecimal!\\n  \" amount of tokens ever deposited to position \"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \" amount of tokens in USD deposited to position \"\\n  cumulativeDepositUSD: BigDecimal!\\n  \" amount of tokens ever withdrawn from position (without fees) \"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \" amount of tokens in USD withdrawn from position (without fees) \"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \" Total reward token accumulated under this position, in USD \"\\n  cumulativeRewardUSD: [BigInt!]\\n  \" Number of deposits related to this position \"\\n  depositCount: Int!\\n  \" All deposit events of this position \"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \" Number of withdrawals related to this position \"\\n  withdrawCount: Int!\\n  \" All withdraw events of this position \"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \" Position daily snapshots for open positions \"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Position` entity with various fields, each representing a specific attribute of a position in a liquidity pool. The fields include identifiers, references to related entities, and various metrics related to the position's activity and status. The descriptions for each field are intended to clarify their purpose and data type, ensuring that developers understand the role of each field within the schema. The documentation should be clear and concise, providing enough context to understand the data without altering the schema's structure.\",\n    documented_schema='\"Description for table: Position\"\\ntype Position @entity @regularPolling {\\n  \"Unique identifier for the position.\"\\n  id: Bytes!\\n  \"Reference to the account associated with this position.\"\\n  account: Account!\\n  \"Reference to the liquidity pool where this position is held.\"\\n  pool: LiquidityPool!\\n  \"Hash of the transaction that opened this position.\"\\n  hashOpened: Bytes!\\n  \"Hash of the transaction that closed this position, if applicable.\"\\n  hashClosed: Bytes\\n  \"Block number when the position was opened.\"\\n  blockNumberOpened: BigInt!\\n  \"Timestamp when the position was opened.\"\\n  timestampOpened: BigInt!\\n  \"Block number when the position was closed, if applicable.\"\\n  blockNumberClosed: BigInt\\n  \"Timestamp when the position was closed, if applicable.\"\\n  timestampClosed: BigInt\\n  \"Lower tick boundary of the position.\"\\n  tickLower: Tick\\n  \"Upper tick boundary of the position.\"\\n  tickUpper: Tick\\n  \"Token representing the liquidity provided in this position.\"\\n  liquidityToken: Token\\n  \"Type of the liquidity token.\"\\n  liquidityTokenType: TokenType\\n  \"Amount of liquidity provided in this position.\"\\n  liquidity: BigInt!\\n  \"Value of the liquidity in USD.\"\\n  liquidityUSD: BigDecimal!\\n  \"Cumulative amounts of tokens deposited into this position.\"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \"Cumulative value of deposits in USD.\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Cumulative amounts of tokens withdrawn from this position.\"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \"Cumulative value of withdrawals in USD.\"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \"Cumulative rewards in USD, if applicable.\"\\n  cumulativeRewardUSD: [BigInt!]\\n  \"Number of deposit transactions made to this position.\"\\n  depositCount: Int!\\n  \"List of deposit transactions associated with this position.\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \"Number of withdrawal transactions made from this position.\"\\n  withdrawCount: Int!\\n  \"List of withdrawal transactions associated with this position.\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \"Snapshots capturing the state of the position over time.\"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: _ActivityHelper\"\\ntype _ActivityHelper @entity {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hourlyActiveUsers\"\\n  hourlyActiveUsers: Int!\\n  \"Description for column: dailyActiveUsers\"\\n  dailyActiveUsers: Int!\\n  \"Description for column: hourlyActiveTransferSenders\"\\n  hourlyActiveTransferSenders: Int!\\n  \"Description for column: dailyActiveTransferSenders\"\\n  dailyActiveTransferSenders: Int!\\n  \"Description for column: hourlyActiveTransferReceivers\"\\n  hourlyActiveTransferReceivers: Int!\\n  \"Description for column: dailyActiveTransferReceivers\"\\n  dailyActiveTransferReceivers: Int!\\n  \"Description for column: hourlyActiveMessageSenders\"\\n  hourlyActiveMessageSenders: Int!\\n  \"Description for column: dailyActiveMessageSenders\"\\n  dailyActiveMessageSenders: Int!\\n  \"Description for column: hourlyActiveLiquidityProviders\"\\n  hourlyActiveLiquidityProviders: Int!\\n  \"Description for column: dailyActiveLiquidityProviders\"\\n  dailyActiveLiquidityProviders: Int!\\n}', 'documented_schema': 'type _ActivityHelper @entity {\\n  id: Bytes!\\n  hourlyActiveUsers: Int!\\n  dailyActiveUsers: Int!\\n  hourlyActiveTransferSenders: Int!\\n  dailyActiveTransferSenders: Int!\\n  hourlyActiveTransferReceivers: Int!\\n  dailyActiveTransferReceivers: Int!\\n  hourlyActiveMessageSenders: Int!\\n  dailyActiveMessageSenders: Int!\\n  hourlyActiveLiquidityProviders: Int!\\n  dailyActiveLiquidityProviders: Int!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines an entity named `_ActivityHelper` with several fields, each representing a specific metric related to user activity. The fields are designed to capture both hourly and daily metrics for various types of user interactions, such as transfers, messages, and liquidity provision. Each field is of type `Int!`, indicating that they are non-nullable integers, except for the `id` field, which is of type `Bytes!`, also non-nullable. The task is to provide clear and concise descriptions for each field based on their names and types, ensuring that the documentation is informative and adheres to the existing schema structure.',\n    documented_schema='\"Description for table: _ActivityHelper\"\\ntype _ActivityHelper @entity {\\n  \"Unique identifier for the activity record, represented as bytes.\"\\n  id: Bytes!\\n  \"Number of users active within the last hour.\"\\n  hourlyActiveUsers: Int!\\n  \"Number of users active within the last day.\"\\n  dailyActiveUsers: Int!\\n  \"Number of users who sent transfers within the last hour.\"\\n  hourlyActiveTransferSenders: Int!\\n  \"Number of users who sent transfers within the last day.\"\\n  dailyActiveTransferSenders: Int!\\n  \"Number of users who received transfers within the last hour.\"\\n  hourlyActiveTransferReceivers: Int!\\n  \"Number of users who received transfers within the last day.\"\\n  dailyActiveTransferReceivers: Int!\\n  \"Number of users who sent messages within the last hour.\"\\n  hourlyActiveMessageSenders: Int!\\n  \"Number of users who sent messages within the last day.\"\\n  dailyActiveMessageSenders: Int!\\n  \"Number of users who provided liquidity within the last hour.\"\\n  hourlyActiveLiquidityProviders: Int!\\n  \"Number of users who provided liquidity within the last day.\"\\n  dailyActiveLiquidityProviders: Int!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transactionHash\"\\n  transactionHash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: isBundle\"\\n  isBundle: Boolean!\\n  \"Description for column: collection\"\\n  collection: Collection!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: priceETH\"\\n  priceETH: BigDecimal!\\n  \"Description for column: strategy\"\\n  strategy: SaleStrategy!\\n  \"Description for column: buyer\"\\n  buyer: String!\\n  \"Description for column: seller\"\\n  seller: String!\\n}', 'documented_schema': '\" Trades exist such as a combination of taker/order and bid/ask. \"\\ntype Trade @entity @transaction {\\n  \" The id for a trade is combination of the following components: { Transaction hash }-{ Log index }-{ (optional) ID within bundle } \"\\n  id: ID!\\n  \" The transaction has that the trade is executed in. This is a unique identifier for the transaction. It is possible that multiple trades are executed in a single transaction. \"\\n  transactionHash: String!\\n  \" This represents the index of the log within the transaction. It is a unique identifier for the log within the transaction. The event corresponds to a trade event. \"\\n  logIndex: Int\\n  \" Block timestamp where the trade is executed. This is based on the timestamp of the block where the trade is executed. \"\\n  timestamp: BigInt!\\n  \" Block number where the trade is executed. A block is a collection of transactions that are executed on the blockchain. \"\\n  blockNumber: BigInt!\\n  \" Whether the trade is in a bundle. Trades can be in a bundle, which means that multiple NFTs are traded together. \"\\n  isBundle: Boolean!\\n  \" Collection involved. This is the collection that the trade, and corresponding NFT, is associated with. \"\\n  collection: Collection!\\n  \" The token ID is the unique identifier for the NFT that is traded. It is unique within the collection. \"\\n  tokenId: BigInt!\\n  \" The amount of token to transfer. It is set at 1 except for ERC1155 batch. \"\\n  amount: BigInt!\\n  \" Price (in ETH). If only 1 tokenId is involved, then the price is determined by the token only. If the trade is incurred by a batch purchasing (available in x2y2), then the price is the average price in the batch. \"\\n  priceETH: BigDecimal!\\n  \" The strategy that the trade is executed with. This is a sale strategy that is used to execute the trade. It is defined by the SaleStrategy Enum. \"\\n  strategy: SaleStrategy!\\n  \" The buyer account address is the address of the account that is purchasing the NFT(s). \"\\n  buyer: String!\\n  \" The seller account address is the address of the account that is selling the NFT(s). \"\\n  seller: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a `Trade` entity with various fields, each representing a specific attribute of a trade transaction. The task is to generate detailed descriptions for each field based on their names and types, ensuring clarity and precision. The descriptions should be factual and straightforward, avoiding any speculative language. The documentation should help developers and system architects understand the purpose and data type of each field without altering the schema structure.',\n    documented_schema='\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Unique identifier for the trade.\"\\n  id: ID!\\n  \"Hash of the transaction associated with the trade.\"\\n  transactionHash: String!\\n  \"Index of the log entry within the transaction.\"\\n  logIndex: Int\\n  \"Timestamp indicating when the trade occurred, represented as a Unix epoch time.\"\\n  timestamp: BigInt!\\n  \"Block number in which the trade was recorded on the blockchain.\"\\n  blockNumber: BigInt!\\n  \"Indicates whether the trade is part of a bundle of trades.\"\\n  isBundle: Boolean!\\n  \"Reference to the collection involved in the trade.\"\\n  collection: Collection!\\n  \"Identifier for the token being traded.\"\\n  tokenId: BigInt!\\n  \"Quantity of tokens involved in the trade.\"\\n  amount: BigInt!\\n  \"Price of the trade expressed in Ethereum (ETH).\"\\n  priceETH: BigDecimal!\\n  \"Strategy used for the sale in the trade.\"\\n  strategy: SaleStrategy!\\n  \"Address of the buyer in the trade.\"\\n  buyer: String!\\n  \"Address of the seller in the trade.\"\\n  seller: String!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt\\n  \"Description for column: nftStandard\"\\n  nftStandard: NftStandard!\\n  \"Description for column: royaltyFee\"\\n  royaltyFee: BigDecimal!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: buyerCount\"\\n  buyerCount: Int!\\n  \"Description for column: sellerCount\"\\n  sellerCount: Int!\\n  \"Description for column: trades\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}', 'documented_schema': 'type Collection @entity @regularPolling {\\n  \" Contract address. \"\\n  id: ID!\\n  \" Collection name, mirrored from the smart contract. Leave null if not available. \"\\n  name: String\\n  \" Collection symbol, mirrored from the smart contract. Leave null if not available. \"\\n  symbol: String\\n  \" Total supply of the collection, mirrored from the smart contract. \"\\n  totalSupply: BigInt\\n  \" NFT Standard the collection uses. \"\\n  nftStandard: NftStandard!\\n  \" Royalty fee rate in percentage. E.g. 2.5% should be 2.5 \"\\n  royaltyFee: BigDecimal!\\n  \" Cumulative trade volume (in ETH) \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" Revenue that goes to the marketplace protocol, aka protocol fee. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" Revenue that goes to creator, aka royalty fee. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" Sum of marketplaceRevenue and creatorRevenue. \"\\n  totalRevenueETH: BigDecimal!\\n  \" Trade count of the collection on the marketplace. \"\\n  tradeCount: Int!\\n  \" Buyer count. \"\\n  buyerCount: Int!\\n  \" Seller count. \"\\n  sellerCount: Int!\\n  \" Trades of the collection. \"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Collection` type with various fields, each representing a specific attribute of a collection entity. The task is to generate detailed descriptions for each field based on the information given in the schema. The descriptions should be clear, concise, and factual, providing insight into what each field represents without altering the schema's structure. The fields include identifiers, financial metrics, and relationships to other entities, which are common in a database schema for managing collections, particularly in contexts like NFTs or digital assets.\",\n    documented_schema='\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Unique identifier for the collection.\"\\n  id: ID!\\n  \"Name of the collection.\"\\n  name: String\\n  \"Symbol representing the collection.\"\\n  symbol: String\\n  \"Total number of items in the collection.\"\\n  totalSupply: BigInt\\n  \"Standard of the NFTs in the collection, such as ERC721 or ERC1155.\"\\n  nftStandard: NftStandard!\\n  \"Fee percentage for royalties on trades within the collection.\"\\n  royaltyFee: BigDecimal!\\n  \"Total trade volume of the collection in Ethereum.\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Revenue generated by the marketplace from the collection in Ethereum.\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Revenue generated by the creator from the collection in Ethereum.\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Total revenue generated from the collection in Ethereum.\"\\n  totalRevenueETH: BigDecimal!\\n  \"Number of trades that have occurred for the collection.\"\\n  tradeCount: Int!\\n  \"Number of unique buyers who have purchased from the collection.\"\\n  buyerCount: Int!\\n  \"Number of unique sellers who have sold items from the collection.\"\\n  sellerCount: Int!\\n  \"List of trades associated with the collection, derived from the \\'collection\\' field in the Trade entity.\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: CreatorContractSetting\"\\ntype CreatorContractSetting @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: factoryContract\"\\n  factoryContract: Bytes!\\n  \"Description for column: kodaSalesSettingsContract\"\\n  kodaSalesSettingsContract: Bytes!\\n  \"Description for column: platform\"\\n  platform: Bytes!\\n  \"Description for column: platformPrimaryCommission\"\\n  platformPrimaryCommission: BigInt!\\n  \"Description for column: platformSecondaryCommission\"\\n  platformSecondaryCommission: BigInt!\\n  \"Description for column: MODULO\"\\n  MODULO: BigInt!\\n}', 'documented_schema': '\" A table of creator contract settings. \"\\ntype CreatorContractSetting @entity {\\n  \" The unique identifier for the creator contract setting. \"\\n  id: ID!\\n  \" The factory contract of the creator contract. \"\\n  factoryContract: Bytes!\\n  \" The KODA sales settings contract of the creator contract. \"\\n  kodaSalesSettingsContract: Bytes!\\n  \" The platform of the creator contract. \"\\n  platform: Bytes!\\n  \" The platform primary commission. \"\\n  platformPrimaryCommission: BigInt!\\n  \" The platform secondary commission. \"\\n  platformSecondaryCommission: BigInt!\\n  \" The modulo for the platform. \"\\n  MODULO: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `CreatorContractSetting`, with several fields. Each field is already accompanied by a brief description. The task is to ensure these descriptions are clear and informative, providing context and purpose for each field without altering the schema structure. The descriptions should be factual and straightforward, focusing on the role and type of data each field holds.',\n    documented_schema='\"Description for table: CreatorContractSetting\"\\ntype CreatorContractSetting @entity {\\n  \"Unique identifier for the creator contract setting.\"\\n  id: ID!\\n  \"Address of the factory contract associated with the creator.\"\\n  factoryContract: Bytes!\\n  \"Address of the contract managing sales settings for the creator.\"\\n  kodaSalesSettingsContract: Bytes!\\n  \"Address representing the platform associated with the creator contract.\"\\n  platform: Bytes!\\n  \"Commission rate for the platform on primary sales, represented as a big integer.\"\\n  platformPrimaryCommission: BigInt!\\n  \"Commission rate for the platform on secondary sales, represented as a big integer.\"\\n  platformSecondaryCommission: BigInt!\\n  \"Constant value used for commission calculations, represented as a big integer.\"\\n  MODULO: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt\\n  \"Description for column: nftStandard\"\\n  nftStandard: NftStandard!\\n  \"Description for column: royaltyFee\"\\n  royaltyFee: BigDecimal!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: buyerCount\"\\n  buyerCount: Int!\\n  \"Description for column: sellerCount\"\\n  sellerCount: Int!\\n  \"Description for column: trades\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}', 'documented_schema': '\" A collection is a group of NFTs that are created by the same creator. This is a unique entity that maps to collections on the marketplace. \"\\ntype Collection @entity @regularPolling {\\n  \" This is the unique identifier for the collection, and is the contract address of the collection. \"\\n  id: ID!\\n  \" This is the name of the collection, and is the name that is given to the collection by the creator. It is mirrored from the smart contract, and left null if not available. \"\\n  name: String\\n  \" This is the symbol of the collection, and is the symbol that is given to the collection by the creator. It is mirrored from the smart contract, and left null if not available. \"\\n  symbol: String\\n  \" This is the total supply of the collection (number of NFTs within a given collection), and is mirrored from the smart contract. \"\\n  totalSupply: BigInt\\n  \" This is the NFT standard that the collection uses. This can be either ERC721, ERC1155, or Unknown. It must be one of the values present within the NftStandard Enum. \"\\n  nftStandard: NftStandard!\\n  \" This is the fee that is taken by the creator of the NFT when it is traded. It is akin to a royalty fee. It is a fee rte in percentage. E.g. 2.5% should be 2.5. \"\\n  royaltyFee: BigDecimal!\\n  \" The cumulative trade volume in ETH that has occurred for the collection. This is the total value of all trades that have occurred for the collection (in ETH). \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The revenue that is collected by the marketplace protocol for facilitating trades of the collection (in ETH). This is akin to a protocol fee. It is represented in ETH. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" The revenue that is collected by the creator of the NFT when it is traded (in ETH). This is akin to a royalty fee. It is represented in ETH. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" The total revenue that has been generated by the collection (in ETH). This is calculated by adding the marketplace revenue and the creator revenue. It is represented in ETH. \"\\n  totalRevenueETH: BigDecimal!\\n  \" This is the number of trades that have occurred for the collection on the marketplace. Each trade is a unique transaction. \"\\n  tradeCount: Int!\\n  \" The total number of unique buyers that have participated in trades for the collection. \"\\n  buyerCount: Int!\\n  \" The total number of unique sellers that have participated in trades for the collection. \"\\n  sellerCount: Int!\\n  \" This maps to the Trade entity, and is a list of trades that have occurred for the collection. \"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Collection` type with various fields, each representing a specific attribute of a collection entity. The task is to generate detailed descriptions for each field based on the information given in the schema. The descriptions should be clear, concise, and factual, providing insight into what each field represents without altering the schema's structure. The fields include identifiers, financial metrics, and relationships to other entities, which are common in a database schema for managing collections, particularly in contexts like NFTs or digital assets.\",\n    documented_schema='\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Unique identifier for the collection.\"\\n  id: ID!\\n  \"Name of the collection.\"\\n  name: String\\n  \"Symbol representing the collection.\"\\n  symbol: String\\n  \"Total number of items in the collection.\"\\n  totalSupply: BigInt\\n  \"Standard of the NFTs in the collection, such as ERC721 or ERC1155.\"\\n  nftStandard: NftStandard!\\n  \"Fee percentage for royalties on trades within the collection.\"\\n  royaltyFee: BigDecimal!\\n  \"Total trade volume of the collection in Ethereum.\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Revenue generated by the marketplace from the collection in Ethereum.\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Revenue generated by the creator from the collection in Ethereum.\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Total revenue generated from the collection in Ethereum.\"\\n  totalRevenueETH: BigDecimal!\\n  \"Number of trades that have occurred for the collection.\"\\n  tradeCount: Int!\\n  \"Number of unique buyers who have purchased from the collection.\"\\n  buyerCount: Int!\\n  \"Number of unique sellers who have sold items from the collection.\"\\n  sellerCount: Int!\\n  \"List of trades associated with the collection, derived from the \\'collection\\' field in the Trade entity.\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: NameChanged\"\\ntype NameChanged implements ResolverEvent @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: resolver\"\\n  resolver: Resolver!\\n  \"Description for column: blockNumber\"\\n  blockNumber: Int!\\n  \"Description for column: transactionID\"\\n  transactionID: Bytes!\\n  \"Description for column: name\"\\n  name: String!\\n}', 'documented_schema': '\" A table of name changed events. A name changed event is an event that occurs when a resolver is used to update a name. This implements the ResolverEvent interface. \"\\ntype NameChanged implements ResolverEvent @entity {\\n  \" The unique identifier for the event. Type: ID! \"\\n  id: ID!\\n  \" The resolver associated with the event. References the Resolver entity that is associated with the event. Type: Resolver! \"\\n  resolver: Resolver!\\n  \" The block number at which the event occurred. Type: Int! \"\\n  blockNumber: Int!\\n  \" The transaction ID for the transaction in which the event occurred. Type: Bytes! \"\\n  transactionID: Bytes!\\n  \" The new ENS name value. Type: String! \"\\n  name: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `NameChanged` which implements the `ResolverEvent` interface and is marked with the `@entity` directive, indicating it is an entity in the database. Each field within the `NameChanged` type has a brief description, which is consistent with the existing documentation style. The task is to ensure that each field is documented clearly and concisely, providing factual information about its purpose and data type without altering the schema structure.',\n    documented_schema='\"Represents an event where a name change has occurred, implementing the ResolverEvent interface.\"\\ntype NameChanged implements ResolverEvent @entity {\\n  \"Unique identifier for the name change event.\"\\n  id: ID!\\n  \"Reference to the resolver associated with the name change.\"\\n  resolver: Resolver!\\n  \"The block number in which the name change transaction was included.\"\\n  blockNumber: Int!\\n  \"Unique identifier for the transaction that triggered the name change.\"\\n  transactionID: Bytes!\\n  \"The new name that has been set.\"\\n  name: String!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for enum type: Network\"\\nenum Network {\\n  \"Description for column: ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"Description for column: ARWEAVE_MAINNET\"\\n  ARWEAVE_MAINNET\\n  \"Description for column: AURORA\"\\n  AURORA\\n  \"Description for column: AVALANCHE\"\\n  AVALANCHE\\n  \"Description for column: BASE\"\\n  BASE\\n  \"Description for column: BOBA\"\\n  BOBA\\n  \"Description for column: BSC\"\\n  BSC\\n  \"Description for column: CELO\"\\n  CELO\\n  \"Description for column: COSMOS\"\\n  COSMOS\\n  \"Description for column: CRONOS\"\\n  CRONOS\\n  \"Description for column: MAINNET\"\\n  MAINNET\\n  \"Description for column: FANTOM\"\\n  FANTOM\\n  \"Description for column: HARMONY\"\\n  HARMONY\\n  \"Description for column: JUNO\"\\n  JUNO\\n  \"Description for column: MOONBEAM\"\\n  MOONBEAM\\n  \"Description for column: MOONRIVER\"\\n  MOONRIVER\\n  \"Description for column: NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"Description for column: OPTIMISM\"\\n  OPTIMISM\\n  \"Description for column: OSMOSIS\"\\n  OSMOSIS\\n  \"Description for column: MATIC\"\\n  MATIC\\n  \"Description for column: XDAI\"\\n  XDAI\\n}', 'documented_schema': '\" Network enum for the schema \"\\nenum Network {\\n  \" The ARBITRUM_ONE network \"\\n  ARBITRUM_ONE\\n  \" The ARWEAVE_MAINNET network \"\\n  ARWEAVE_MAINNET\\n  \" The AURORA network \"\\n  AURORA\\n  \" The AVALANCHE network \"\\n  AVALANCHE\\n  \" The BASE network \"\\n  BASE\\n  \" The BOBA network \"\\n  BOBA\\n  \" The BSC network \"\\n  BSC\\n  \" The CELO network \"\\n  CELO\\n  \" The COSMOS network \"\\n  COSMOS\\n  \" The CRONOS network \"\\n  CRONOS\\n  \" The MAINNET network \"\\n  MAINNET\\n  \" The FANTOM network \"\\n  FANTOM\\n  \" The FUSE network \"\\n  HARMONY\\n  \" The JUNO network \"\\n  JUNO\\n  \" The MOONBEAM network \"\\n  MOONBEAM\\n  \" The MOONRIVER network \"\\n  MOONRIVER\\n  \" The NEAR_MAINNET network \"\\n  NEAR_MAINNET\\n  \" The OPTIMISM network \"\\n  OPTIMISM\\n  \" The OSMOSIS network \"\\n  OSMOSIS\\n  \" The MATIC network \"\\n  MATIC\\n  \" The XDAI network \"\\n  XDAI\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema is an enumeration type named `Network`, which lists various blockchain networks. Each entry in the enum represents a distinct blockchain network, and the descriptions for each entry are placeholders that need to be replaced with more informative descriptions. The task is to provide clear and concise descriptions for each network, ensuring that the documentation is factual and aids in understanding the purpose or identity of each network.',\n    documented_schema='\"Description for enum type: Network\"\\nenum Network {\\n  \"Arbitrum One is a layer 2 scaling solution for Ethereum, designed to improve transaction speed and reduce costs.\"\\n  ARBITRUM_ONE\\n  \"Arweave Mainnet is a decentralized storage network that offers permanent data storage.\"\\n  ARWEAVE_MAINNET\\n  \"Aurora is an Ethereum Virtual Machine (EVM) built on the NEAR Protocol, providing a high-performance environment for Ethereum applications.\"\\n  AURORA\\n  \"Avalanche is a high-performance, scalable blockchain platform for decentralized applications and enterprise blockchain deployments.\"\\n  AVALANCHE\\n  \"Base is a layer 2 network built on Ethereum, designed to offer secure and low-cost transactions.\"\\n  BASE\\n  \"Boba is a layer 2 Ethereum scaling solution that aims to reduce gas fees and improve transaction throughput.\"\\n  BOBA\\n  \"BSC, or Binance Smart Chain, is a blockchain network running in parallel to Binance Chain, enabling smart contract functionality.\"\\n  BSC\\n  \"Celo is a mobile-first blockchain platform focused on increasing cryptocurrency adoption among smartphone users.\"\\n  CELO\\n  \"Cosmos is a decentralized network of independent parallel blockchains, each powered by BFT consensus algorithms.\"\\n  COSMOS\\n  \"Cronos is a blockchain network designed for decentralized finance (DeFi) and decentralized applications (DApps).\"\\n  CRONOS\\n  \"Mainnet refers to the primary Ethereum network where actual transactions occur on the blockchain.\"\\n  MAINNET\\n  \"Fantom is a fast, scalable, and secure smart contract platform designed to overcome the limitations of previous generation blockchain platforms.\"\\n  FANTOM\\n  \"Harmony is a blockchain platform designed to facilitate the creation and use of decentralized applications, focusing on data sharing and decentralized marketplaces.\"\\n  HARMONY\\n  \"Juno is a blockchain network that provides a decentralized, permissionless smart contract platform.\"\\n  JUNO\\n  \"Moonbeam is an Ethereum-compatible smart contract platform on the Polkadot network, providing a seamless experience for developers.\"\\n  MOONBEAM\\n  \"Moonriver is a community-led sister parachain on Kusama, providing a permanently incentivized canary network for Moonbeam.\"\\n  MOONRIVER\\n  \"NEAR Mainnet is the primary network for the NEAR Protocol, a scalable blockchain designed for high-performance applications.\"\\n  NEAR_MAINNET\\n  \"Optimism is a layer 2 scaling solution for Ethereum, designed to improve transaction throughput and reduce latency.\"\\n  OPTIMISM\\n  \"Osmosis is a decentralized exchange (DEX) and automated market maker (AMM) protocol built on the Cosmos SDK.\"\\n  OSMOSIS\\n  \"Matic, now known as Polygon, is a protocol and framework for building and connecting Ethereum-compatible blockchain networks.\"\\n  MATIC\\n  \"xDai is a stable payment blockchain designed for fast and inexpensive transactions, using a stablecoin as its native currency.\"\\n  XDAI\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: ParameterUpdateEvent\"\\ntype ParameterUpdateEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: param\"\\n  param: String!\\n}', 'documented_schema': '\"\"\"\\nParameterUpdateEvent entities are created for every emitted ParameterUpdate event.\\n\"\"\"\\ntype ParameterUpdateEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  \"Parameter that was updated\"\\n  param: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `ParameterUpdateEvent` which implements the `Event` interface. Each field within this type is already accompanied by a brief description. The task is to ensure that these descriptions are clear and informative, providing a concise explanation of each field's purpose and data type. The descriptions should be factual and directly related to the schema's structure without altering the schema itself.\",\n    documented_schema='\"Description for table: ParameterUpdateEvent\"\\ntype ParameterUpdateEvent implements Event @entity {\\n  \"Unique identifier for the parameter update event\"\\n  id: ID!\\n  \"Associated transaction for the parameter update\"\\n  transaction: Transaction!\\n  \"Unix timestamp indicating when the event occurred\"\\n  timestamp: Int!\\n  \"Round number associated with the parameter update\"\\n  round: Round!\\n  \"Name of the parameter that was updated\"\\n  param: String!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: dailyVolumeUSD\"\\n  dailyVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: dailySupplySideRevenueUSD\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyProtocolSideRevenueUSD\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyTotalRevenueUSD\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}', 'documented_schema': 'type FinancialsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: ID!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" All trade volume occurred in a given day, in USD \"\\n  dailyVolumeUSD: BigDecimal!\\n  \" All historical trade volume in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema represents a table named `FinancialsDailySnapshot`, which is used to store daily financial data snapshots for a decentralized exchange automated market maker (DexAmmProtocol). Each field in the schema is associated with a specific aspect of the financial data, such as total value locked, volume, and revenue, both on a daily and cumulative basis. The fields are well-defined with types that indicate the nature of the data they hold, such as `BigDecimal` for financial figures and `BigInt` for numerical identifiers like block numbers and timestamps. The task is to provide clear and concise descriptions for each field, ensuring that the documentation is informative and aids in understanding the purpose and content of each field without altering the schema structure.',\n    documented_schema='\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Unique identifier for the financial snapshot entry.\"\\n  id: ID!\\n  \"Reference to the decentralized exchange protocol associated with this snapshot.\"\\n  protocol: DexAmmProtocol!\\n  \"Total value locked in USD at the time of the snapshot.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Value controlled by the protocol in USD, if applicable.\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Total trading volume in USD for the day.\"\\n  dailyVolumeUSD: BigDecimal!\\n  \"Cumulative trading volume in USD up to the snapshot date.\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Revenue generated for liquidity providers in USD for the day.\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue generated for liquidity providers in USD up to the snapshot date.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Revenue generated for the protocol in USD for the day.\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue generated for the protocol in USD up to the snapshot date.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Total revenue generated in USD for the day, combining both supply and protocol side revenues.\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Cumulative total revenue in USD up to the snapshot date, combining both supply and protocol side revenues.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Block number at which the snapshot was taken.\"\\n  blockNumber: BigInt!\\n  \"Timestamp indicating when the snapshot was recorded.\"\\n  timestamp: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: PollTally\"\\ntype PollTally @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: yes\"\\n  yes: BigDecimal!\\n  \"Description for column: no\"\\n  no: BigDecimal!\\n}', 'documented_schema': '\"\"\"Stake weighted tally associated with a poll\"\"\"\\ntype PollTally @entity {\\n  \"Poll address\"\\n  id: ID!\\n  \"Stake voted yes\"\\n  yes: BigDecimal!\\n  \"Stake voted no\"\\n  no: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `PollTally`, which appears to represent the results of a poll. The entity includes three fields: `id`, `yes`, and `no`. The `id` field is of type `ID!`, indicating it is a unique identifier for each poll tally entry and is required. The `yes` and `no` fields are of type `BigDecimal!`, suggesting they store numerical values representing the count or percentage of affirmative and negative responses, respectively, and are also required. The task is to document these fields with clear and concise descriptions based on their likely roles within the schema.',\n    documented_schema='\"Represents the tally of votes in a poll, capturing the number of affirmative and negative responses.\"\\ntype PollTally @entity {\\n  \"Unique identifier for the poll tally entry.\"\\n  id: ID!\\n  \"Number or percentage of affirmative responses in the poll.\"\\n  yes: BigDecimal!\\n  \"Number or percentage of negative responses in the poll.\"\\n  no: BigDecimal!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: TranscoderDeactivatedEvent\"\\ntype TranscoderDeactivatedEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: delegate\"\\n  delegate: Transcoder!\\n  \"Description for column: deactivationRound\"\\n  deactivationRound: BigInt!\\n}', 'documented_schema': '\"\"\"\\nTranscoderDeactivatedEvent entities are created for every emitted TranscoderDeactivated event.\\n\"\"\"\\ntype TranscoderDeactivatedEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  \"Reference to the delegate that will become deactive\"\\n  delegate: Transcoder!\\n  \"Future round in which the delegate will become deactive\"\\n  deactivationRound: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `TranscoderDeactivatedEvent` which implements an `Event` interface. This type is likely used to represent an event where a transcoder is deactivated. Each field within this type has a specific role:\\n\\n- `id`: A unique identifier for the event, typically used to distinguish it from other events.\\n- `transaction`: Represents the transaction associated with the deactivation event, likely containing details about the blockchain transaction.\\n- `timestamp`: An integer representing the time at which the event occurred, usually in Unix epoch format.\\n- `round`: Refers to the round during which the deactivation event took place, possibly indicating a specific period or cycle in the system.\\n- `delegate`: The transcoder that was deactivated, represented by a `Transcoder` type.\\n- `deactivationRound`: A `BigInt` indicating the specific round when the deactivation becomes effective.\\n\\nThe documentation should provide clear and concise descriptions for each field, ensuring that users understand the purpose and data type of each component without altering the schema structure.',\n    documented_schema='\"Description for table: TranscoderDeactivatedEvent\"\\ntype TranscoderDeactivatedEvent implements Event @entity {\\n  \"Unique identifier for the deactivation event.\"\\n  id: ID!\\n  \"The transaction associated with the deactivation event.\"\\n  transaction: Transaction!\\n  \"The Unix timestamp when the deactivation event occurred.\"\\n  timestamp: Int!\\n  \"The round during which the deactivation event took place.\"\\n  round: Round!\\n  \"The transcoder that was deactivated.\"\\n  delegate: Transcoder!\\n  \"The round when the deactivation becomes effective.\"\\n  deactivationRound: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: AuthorisationChanged\"\\ntype AuthorisationChanged implements ResolverEvent @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: resolver\"\\n  resolver: Resolver!\\n  \"Description for column: blockNumber\"\\n  blockNumber: Int!\\n  \"Description for column: transactionID\"\\n  transactionID: Bytes!\\n  \"Description for column: owner\"\\n  owner: Bytes!\\n  \"Description for column: target\"\\n  target: Bytes!\\n  \"Description for column: isAuthorized\"\\n  isAuthorized: Boolean!\\n}', 'documented_schema': '\" A table of authorisation changed events. An authorisation changed event is an event that occurs when an authorisation is changed wihtin the resolver. This implements the ResolverEvent interface. \"\\ntype AuthorisationChanged implements ResolverEvent @entity {\\n  \" The unique identifier for the event. Type: ID! \"\\n  id: ID!\\n  \" The resolver associated with the event. References the Resolver entity that is associated with the event. Type: Resolver! \"\\n  resolver: Resolver!\\n  \" The block number at which the event occurred. Type: Int! \"\\n  blockNumber: Int!\\n  \" The transaction hash associated with the event. Type: Bytes! \"\\n  transactionID: Bytes!\\n  \" The owner of the authorisation. Type: Bytes! \"\\n  owner: Bytes!\\n  \" The target of the authorisation. Type: Bytes! \"\\n  target: Bytes!\\n  \" Whether the authorisation was added or removed. Type: Boolean! \"\\n  isAuthorized: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `AuthorisationChanged` which implements the `ResolverEvent` interface and is marked with the `@entity` directive, indicating it is an entity in the database. Each field within this type has a specific role:\\n\\n- `id`: A unique identifier for each `AuthorisationChanged` event, typically used to distinguish between different records.\\n- `resolver`: Represents a `Resolver` object, indicating the resolver associated with the authorization change.\\n- `blockNumber`: An integer representing the block number in which the authorization change occurred, useful for tracking the event within a blockchain.\\n- `transactionID`: A byte array that uniquely identifies the transaction associated with the authorization change, providing a link to the specific transaction details.\\n- `owner`: A byte array representing the owner involved in the authorization change, likely an address or identifier.\\n- `target`: A byte array indicating the target entity or address affected by the authorization change.\\n- `isAuthorized`: A boolean value indicating whether the target is authorized or not after the change.\\n\\nThese descriptions are derived directly from the schema, ensuring factual accuracy and clarity.',\n    documented_schema='type AuthorisationChanged implements ResolverEvent @entity {\\n  \"A unique identifier for the authorization change event.\"\\n  id: ID!\\n  \"The resolver associated with the authorization change.\"\\n  resolver: Resolver!\\n  \"The block number where the authorization change occurred.\"\\n  blockNumber: Int!\\n  \"The transaction ID related to the authorization change.\"\\n  transactionID: Bytes!\\n  \"The owner involved in the authorization change.\"\\n  owner: Bytes!\\n  \"The target affected by the authorization change.\"\\n  target: Bytes!\\n  \"Indicates if the target is authorized after the change.\"\\n  isAuthorized: Boolean!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: MulticoinAddrChanged\"\\ntype MulticoinAddrChanged implements ResolverEvent @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: resolver\"\\n  resolver: Resolver!\\n  \"Description for column: blockNumber\"\\n  blockNumber: Int!\\n  \"Description for column: transactionID\"\\n  transactionID: Bytes!\\n  \"Description for column: coinType\"\\n  coinType: BigInt!\\n  \"Description for column: addr\"\\n  addr: Bytes!\\n}', 'documented_schema': '\" A table of multicoin addr changed events. A multicoin addr changed event is an event that occurs when a resolver\\'s address is changed for a specific coin type. This implements the ResolverEvent interface. \"\\ntype MulticoinAddrChanged implements ResolverEvent @entity {\\n  \" The unique identifier for the event. Type: ID! \"\\n  id: ID!\\n  \" The resolver associated with the event. References the Resolver entity that is associated with the event. Type: Resolver! \"\\n  resolver: Resolver!\\n  \" The block number at which the event occurred. Type: Int! \"\\n  blockNumber: Int!\\n  \" The transaction ID for the transaction in which the event occurred. Type: Bytes! \"\\n  transactionID: Bytes!\\n  \" The coin type of the changed address. Type: BigInt! \"\\n  coinType: BigInt!\\n  \" The new address value for the given coin type. Type: Bytes! \"\\n  addr: Bytes!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `MulticoinAddrChanged` which implements the `ResolverEvent` interface and is marked as an entity. Each field within this type has a specific role, and the task is to provide clear and concise descriptions for each field based on their names and types. The `id` field is a unique identifier for the entity. The `resolver` field likely references another entity of type `Resolver`. The `blockNumber` field represents the block number in which the event occurred. The `transactionID` field is a byte array that likely stores the transaction identifier. The `coinType` field, represented as a `BigInt`, indicates the type of cryptocurrency involved. Lastly, the `addr` field is a byte array that stores the address associated with the event.',\n    documented_schema='\"Description for table: MulticoinAddrChanged\"\\ntype MulticoinAddrChanged implements ResolverEvent @entity {\\n  \"Unique identifier for the MulticoinAddrChanged entity.\"\\n  id: ID!\\n  \"Reference to the Resolver entity associated with this event.\"\\n  resolver: Resolver!\\n  \"The block number in which this event was recorded.\"\\n  blockNumber: Int!\\n  \"The transaction identifier associated with this event, stored as bytes.\"\\n  transactionID: Bytes!\\n  \"The type of cryptocurrency involved, represented as a BigInt.\"\\n  coinType: BigInt!\\n  \"The address associated with this event, stored as bytes.\"\\n  addr: Bytes!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: token\"\\n  token: Token\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector!\\n  \"Description for column: bidder\"\\n  bidder: Collector!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: weiValue\"\\n  weiValue: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: lockedUntil\"\\n  lockedUntil: BigInt\\n  \"Description for column: isActive\"\\n  isActive: Boolean!\\n}', 'documented_schema': '\" A table of offers. Encapsulates all offers either on editions or tokens. \"\\ntype Offer @entity {\\n  \" The unique identifier for the offer. This is edition ID or token ID. Type: ID! \"\\n  id: ID!\\n  \" The version. This is the version of the KODA schema used to record the offer. Type: BigInt! \"\\n  version: BigInt!\\n  \" The type. This is the type of the offer, either Token or Edition. Type: String! \"\\n  type: String!\\n  \" The sales type. This is the current sales mechnic being used on this offer. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The token in the offer. This is a nullable token, as editions dont have tokens attached. Type: Token! \"\\n  token: Token\\n  \" The edition in the offer. All offers must be from an edition. Type: Edition! \"\\n  edition: Edition!\\n  \" The current owner of the offer, refering to the collection the offer is from. This is either the token holder or the edition artist. Type: Collector! \"\\n  currentOwner: Collector!\\n  \" The bidder. This is the address of account making the bid. This references the Collector entity. Type: Collector! \"\\n  bidder: Collector!\\n  \" The eth value of the offer. This is human readable eth value of the offer. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The wei value of the offer. This is the wei value, meaning the non-converted value of ETh, of the offer. Type: BigInt! \"\\n  weiValue: BigInt!\\n  \" The timestamp of the offer. This is the timestamp of the offer. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the offer. This is the transaction hash of the offer. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The locked until timestamp of the offer. For V3 offers, they will be locked for a certain amount of time. Type: BigInt! \"\\n  lockedUntil: BigInt\\n  \" The active flag of the offer. This is a boolean that indicates if the offer is active, as only active offers can be seen in the UI. Type: Boolean! \"\\n  isActive: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines an `Offer` entity with various fields, each representing a specific attribute of an offer in a database. The task is to generate clear and concise descriptions for each field based on their names and types, ensuring that the descriptions are factual and informative. The descriptions should help users understand the purpose and data type of each field without altering the schema structure.',\n    documented_schema='\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Unique identifier for the offer.\"\\n  id: ID!\\n  \"Version number of the offer, used for tracking changes.\"\\n  version: BigInt!\\n  \"Type of the offer, represented as a string.\"\\n  type: String!\\n  \"Sales type identifier, represented as a big integer.\"\\n  salesType: BigInt!\\n  \"Associated token for the offer, if applicable.\"\\n  token: Token\\n  \"Edition associated with the offer, must be specified.\"\\n  edition: Edition!\\n  \"Current owner of the offer, represented by a collector entity.\"\\n  currentOwner: Collector!\\n  \"Bidder involved in the offer, represented by a collector entity.\"\\n  bidder: Collector!\\n  \"Value of the offer in Ethereum, represented as a decimal.\"\\n  ethValue: BigDecimal!\\n  \"Value of the offer in Wei, represented as a big integer.\"\\n  weiValue: BigInt!\\n  \"Timestamp indicating when the offer was created or last updated.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction associated with the offer.\"\\n  transactionHash: Bytes!\\n  \"Timestamp until which the offer is locked, if applicable.\"\\n  lockedUntil: BigInt\\n  \"Indicates whether the offer is currently active.\"\\n  isActive: Boolean!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Withdraw\"\\ntype Withdraw implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: YieldAggregator!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: asset\"\\n  asset: Token!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: vault\"\\n  vault: Vault!\\n}', 'documented_schema': 'type Withdraw implements Event @entity @transaction {\\n  \" { Transaction hash }-{ Log index }\"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: YieldAggregator!\\n  \" Address that received tokens \"\\n  to: String!\\n  \" Market that tokens are withdrawn from \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Token withdrawn \"\\n  asset: Token!\\n  \" Amount of token withdrawn in native units \"\\n  amount: BigInt!\\n  \" Amount of token withdrawn in USD \"\\n  amountUSD: BigDecimal!\\n  \" The vault involving this transaction \"\\n  vault: Vault!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a `Withdraw` type that implements an `Event` interface and is annotated with `@entity` and `@transaction` directives, indicating that it represents a transactional entity in the database. Each field within the `Withdraw` type has a specific role and data type, which is crucial for understanding the structure and purpose of the data being modeled. The task is to provide clear and concise documentation for each field, ensuring that the descriptions are informative and adhere to the existing schema format without altering the schema itself.',\n    documented_schema='\"Description for table: Withdraw\"\\ntype Withdraw implements Event @entity @transaction {\\n  \"Unique identifier for the withdrawal event.\"\\n  id: ID!\\n  \"Transaction hash associated with the withdrawal.\"\\n  hash: String!\\n  \"Index of the log entry within the block.\"\\n  logIndex: Int!\\n  \"Protocol through which the withdrawal was made.\"\\n  protocol: YieldAggregator!\\n  \"Address to which the assets were withdrawn.\"\\n  to: String!\\n  \"Address from which the assets were withdrawn.\"\\n  from: String!\\n  \"Block number in which the withdrawal transaction was included.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of when the withdrawal occurred, in seconds since the Unix epoch.\"\\n  timestamp: BigInt!\\n  \"Token that was withdrawn.\"\\n  asset: Token!\\n  \"Amount of the asset that was withdrawn.\"\\n  amount: BigInt!\\n  \"Equivalent amount of the withdrawn asset in USD.\"\\n  amountUSD: BigDecimal!\\n  \"Vault from which the assets were withdrawn.\"\\n  vault: Vault!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: MarketplaceDailySnapshot\"\\ntype MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: marketplace\"\\n  marketplace: Marketplace!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: collectionCount\"\\n  collectionCount: Int!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: cumulativeUniqueTraders\"\\n  cumulativeUniqueTraders: Int!\\n  \"Description for column: dailyActiveTraders\"\\n  dailyActiveTraders: Int!\\n  \"Description for column: dailyTradedCollectionCount\"\\n  dailyTradedCollectionCount: Int!\\n  \"Description for column: dailyTradedItemCount\"\\n  dailyTradedItemCount: Int!\\n}', 'documented_schema': 'type MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \" { Contract address }-{# of days since Unix epoch time} \"\\n  id: ID!\\n  \" The marketplace that this snapshot belongs to. \"\\n  marketplace: Marketplace!\\n  \" Block number where the snapshot is taken. \"\\n  blockNumber: BigInt!\\n  \" Block timestamp when the snapshot is taken. \"\\n  timestamp: BigInt!\\n  \" Number of collections listed on the marketplace. \"\\n  collectionCount: Int!\\n  \" Cumulative trade volume (in ETH) \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" Revenue that goes to the marketplace protocol, aka protocol fee. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" Revenue that goes to creator, aka royalty fee. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" Sum of marketplaceRevenueETH and creatorRevenueETH. \"\\n  totalRevenueETH: BigDecimal!\\n  \" Trade count of the all collections on the marketplace. \"\\n  tradeCount: Int!\\n  \" Cumulative unique traders \"\\n  cumulativeUniqueTraders: Int!\\n  \" Daily active traders \"\\n  dailyActiveTraders: Int!\\n  \" Number of traded collections of the day \"\\n  dailyTradedCollectionCount: Int!\\n  \" Number of traded items of the day \"\\n  dailyTradedItemCount: Int!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema represents a table named `MarketplaceDailySnapshot`, which is designed to capture daily snapshots of marketplace data. Each field in the schema is associated with a specific aspect of the marketplace's daily performance, such as trade volumes, revenue, and trader activity. The descriptions for each field are intended to clarify the purpose and type of data stored in each column, aiding developers in understanding the structure and use of the data.\",\n    documented_schema='\"Description for table: MarketplaceDailySnapshot\"\\ntype MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \"Unique identifier for the daily snapshot entry.\"\\n  id: ID!\\n  \"Reference to the marketplace entity associated with this snapshot.\"\\n  marketplace: Marketplace!\\n  \"The block number at which the snapshot was taken.\"\\n  blockNumber: BigInt!\\n  \"The timestamp indicating when the snapshot was recorded.\"\\n  timestamp: BigInt!\\n  \"The total number of collections available in the marketplace on this day.\"\\n  collectionCount: Int!\\n  \"The cumulative trade volume in ETH up to this day.\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"The total revenue generated by the marketplace in ETH on this day.\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"The total revenue earned by creators in ETH on this day.\"\\n  creatorRevenueETH: BigDecimal!\\n  \"The combined total revenue in ETH from both the marketplace and creators on this day.\"\\n  totalRevenueETH: BigDecimal!\\n  \"The number of trades executed on this day.\"\\n  tradeCount: Int!\\n  \"The cumulative number of unique traders up to this day.\"\\n  cumulativeUniqueTraders: Int!\\n  \"The number of active traders on this day.\"\\n  dailyActiveTraders: Int!\\n  \"The number of collections that were traded on this day.\"\\n  dailyTradedCollectionCount: Int!\\n  \"The number of individual items that were traded on this day.\"\\n  dailyTradedItemCount: Int!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: ArtistMintingConfig\"\\ntype ArtistMintingConfig @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: mints\"\\n  mints: BigInt!\\n  \"Description for column: firstMintInPeriod\"\\n  firstMintInPeriod: BigInt!\\n  \"Description for column: frequencyOverride\"\\n  frequencyOverride: Boolean!\\n}', 'documented_schema': '\" A table of artist minting configurations. \"\\ntype ArtistMintingConfig @entity {\\n  \" The unique identifier for the artist minting configuration. \"\\n  id: ID!\\n  \" The total number of mints. \"\\n  mints: BigInt!\\n  \" The first mint in the period. \"\\n  firstMintInPeriod: BigInt!\\n  \" Whether the user can mint as much as possible. \"\\n  frequencyOverride: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema defines a GraphQL entity named `ArtistMintingConfig` with four fields. Each field is already accompanied by a brief description. The task is to ensure these descriptions are clear and informative, providing context about what each field represents without altering the schema structure. The descriptions should be concise and factual, focusing on the role and data type of each field.',\n    documented_schema='\"Description for table: ArtistMintingConfig\"\\ntype ArtistMintingConfig @entity {\\n  \"Unique identifier for the artist minting configuration.\"\\n  id: ID!\\n  \"Total number of mints associated with the artist.\"\\n  mints: BigInt!\\n  \"Timestamp of the first mint within the current period.\"\\n  firstMintInPeriod: BigInt!\\n  \"Indicates if the default minting frequency is overridden.\"\\n  frequencyOverride: Boolean!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: TokenEvent\"\\ntype TokenEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: buyer\"\\n  buyer: Collector\\n  \"Description for column: bidder\"\\n  bidder: Collector\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: TransferEvent\"\\ntype TransferEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: from\"\\n  from: Bytes!\\n  \"Description for column: to\"\\n  to: Bytes!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: AuctionEvent\"\\ntype AuctionEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: bidder\"\\n  bidder: Bytes!\\n  \"Description for column: caller\"\\n  caller: Bytes!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: lockupUntil\"\\n  lockupUntil: BigInt\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: ActivityEvent\"\\ntype ActivityEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: eventType\"\\n  eventType: String!\\n  \"Description for column: edition\"\\n  edition: Edition\\n  \"Description for column: token\"\\n  token: Token\\n  \"Description for column: creator\"\\n  creator: Bytes!\\n  \"Description for column: creatorCommission\"\\n  creatorCommission: BigInt\\n  \"Description for column: collaborator\"\\n  collaborator: Bytes\\n  \"Description for column: collaboratorCommission\"\\n  collaboratorCommission: BigInt\\n  \"Description for column: triggeredBy\"\\n  triggeredBy: Bytes\\n  \"Description for column: buyer\"\\n  buyer: Bytes\\n  \"Description for column: seller\"\\n  seller: Bytes\\n  \"Description for column: stakeholderAddresses\"\\n  stakeholderAddresses: [Bytes!]!\\n  \"Description for column: contractAddress\"\\n  contractAddress: Bytes\\n  \"Description for column: eventValueInWei\"\\n  eventValueInWei: BigInt\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: _Schema_\"\\ntype _Schema_ @fulltext(name: \"listedTokenSearch\", language: en, algorithm: rank, include: [{entity: \"ListedToken\", fields: [{name: \"metadataName\"}, {name: \"metadataArtist\"}, {name: \"metadataArtistAccount\"}, {name: \"metadataTagString\"}, {name: \"primaryAssetShortType\"}, {name: \"primaryAssetActualType\"}]}]) @fulltext(name: \"editionSearch\", language: en, algorithm: rank, include: [{entity: \"Edition\", fields: [{name: \"metadataName\"}, {name: \"metadataArtist\"}, {name: \"metadataArtistAccount\"}, {name: \"metadataTagString\"}, {name: \"metadataFormat\"}, {name: \"metadataTheme\"}, {name: \"primaryAssetShortType\"}, {name: \"primaryAssetActualType\"}]}])\\n\\n\"Description for table: Day\"\\ntype Day @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: date\"\\n  date: String!\\n  \"Description for column: transferCount\"\\n  transferCount: BigInt!\\n  \"Description for column: editionsCount\"\\n  editionsCount: BigInt!\\n  \"Description for column: bidsAcceptedCount\"\\n  bidsAcceptedCount: BigInt!\\n  \"Description for column: bidsPlacedCount\"\\n  bidsPlacedCount: BigInt!\\n  \"Description for column: bidsRejectedCount\"\\n  bidsRejectedCount: BigInt!\\n  \"Description for column: bidsWithdrawnCount\"\\n  bidsWithdrawnCount: BigInt!\\n  \"Description for column: bidsIncreasedCount\"\\n  bidsIncreasedCount: BigInt!\\n  \"Description for column: totalValuePlaceInBids\"\\n  totalValuePlaceInBids: BigDecimal!\\n  \"Description for column: totalValueCycledInBids\"\\n  totalValueCycledInBids: BigDecimal!\\n  \"Description for column: secondarySalesValue\"\\n  secondarySalesValue: BigDecimal!\\n  \"Description for column: issuedCount\"\\n  issuedCount: BigInt!\\n  \"Description for column: salesCount\"\\n  salesCount: BigInt!\\n  \"Description for column: totalValueInEth\"\\n  totalValueInEth: BigDecimal!\\n  \"Description for column: highestValueInEth\"\\n  highestValueInEth: BigDecimal!\\n  \"Description for column: highestValueToken\"\\n  highestValueToken: Token\\n  \"Description for column: issued\"\\n  issued: [Token!]!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n}\\n\\n\"Description for table: PlatformConfig\"\\ntype PlatformConfig @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: royaltiesRegistry\"\\n  royaltiesRegistry: Bytes\\n  \"Description for column: tokenUriResolver\"\\n  tokenUriResolver: Bytes\\n  \"Description for column: modulo\"\\n  modulo: BigInt\\n  \"Description for column: primarySaleCommission\"\\n  primarySaleCommission: BigInt\\n  \"Description for column: secondarySaleRoyalty\"\\n  secondarySaleRoyalty: BigInt\\n  \"Description for column: marketplaceSecondarySaleRoyalty\"\\n  marketplaceSecondarySaleRoyalty: BigInt\\n  \"Description for column: minBidAmount\"\\n  minBidAmount: BigInt\\n  \"Description for column: mintingPeriod\"\\n  mintingPeriod: BigInt\\n  \"Description for column: maxMintsInPeriod\"\\n  maxMintsInPeriod: BigInt\\n  \"Description for column: merkleProofRoot\"\\n  merkleProofRoot: Bytes\\n  \"Description for column: merkleProofIpfsHash\"\\n  merkleProofIpfsHash: String\\n}\\n\\n\"Description for table: Token\"\\ntype Token @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: transferCount\"\\n  transferCount: BigInt!\\n  \"Description for column: editionNumber\"\\n  editionNumber: String!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: tokenURI\"\\n  tokenURI: String!\\n  \"Description for column: metadata\"\\n  metadata: MetaData\\n  \"Description for column: birthTimestamp\"\\n  birthTimestamp: BigInt!\\n  \"Description for column: primaryValueInEth\"\\n  primaryValueInEth: BigDecimal!\\n  \"Description for column: totalPurchaseValue\"\\n  totalPurchaseValue: BigDecimal!\\n  \"Description for column: totalPurchaseCount\"\\n  totalPurchaseCount: BigInt!\\n  \"Description for column: largestSecondaryValueInEth\"\\n  largestSecondaryValueInEth: BigDecimal!\\n  \"Description for column: largestSalePriceEth\"\\n  largestSalePriceEth: BigDecimal!\\n  \"Description for column: lastSalePriceInEth\"\\n  lastSalePriceInEth: BigDecimal!\\n  \"Description for column: lastTransferTimestamp\"\\n  lastTransferTimestamp: BigInt!\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector\\n  \"Description for column: allOwners\"\\n  allOwners: [Collector!]!\\n  \"Description for column: transfers\"\\n  transfers: [TransferEvent!]!\\n  \"Description for column: tokenEvents\"\\n  tokenEvents: [TokenEvent!]!\\n  \"Description for column: openOffer\"\\n  openOffer: TokenOffer\\n  \"Description for column: currentTopBidder\"\\n  currentTopBidder: Bytes\\n  \"Description for column: artistAccount\"\\n  artistAccount: Bytes!\\n  \"Description for column: editionActive\"\\n  editionActive: Boolean!\\n  \"Description for column: revokedApproval\"\\n  revokedApproval: Boolean!\\n  \"Description for column: isListed\"\\n  isListed: Boolean!\\n  \"Description for column: listPrice\"\\n  listPrice: BigDecimal\\n  \"Description for column: lister\"\\n  lister: Collector\\n  \"Description for column: listingTimestamp\"\\n  listingTimestamp: BigInt\\n  \"Description for column: listing\"\\n  listing: ListedToken\\n  \"Description for column: creatorContract\"\\n  creatorContract: CreatorContract\\n}\\n\\n\"Description for table: ListedToken\"\\ntype ListedToken @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: editionNumber\"\\n  editionNumber: String!\\n  \"Description for column: revokedApproval\"\\n  revokedApproval: Boolean!\\n  \"Description for column: listPrice\"\\n  listPrice: BigDecimal!\\n  \"Description for column: lister\"\\n  lister: Collector!\\n  \"Description for column: listingTimestamp\"\\n  listingTimestamp: BigInt!\\n  \"Description for column: seriesNumber\"\\n  seriesNumber: BigInt\\n  \"Description for column: isFirstEdition\"\\n  isFirstEdition: Boolean\\n  \"Description for column: isLastEdition\"\\n  isLastEdition: Boolean\\n  \"Description for column: isGenesisEdition\"\\n  isGenesisEdition: Boolean\\n  \"Description for column: metadataName\"\\n  metadataName: String!\\n  \"Description for column: metadataArtist\"\\n  metadataArtist: String!\\n  \"Description for column: metadataArtistAccount\"\\n  metadataArtistAccount: String!\\n  \"Description for column: metadataTagString\"\\n  metadataTagString: String!\\n  \"Description for column: primaryAssetShortType\"\\n  primaryAssetShortType: String!\\n  \"Description for column: primaryAssetActualType\"\\n  primaryAssetActualType: String!\\n  \"Description for column: fullToken\"\\n  fullToken: Token!\\n  \"Description for column: reserveAuctionSeller\"\\n  reserveAuctionSeller: Bytes!\\n  \"Description for column: reserveAuctionBidder\"\\n  reserveAuctionBidder: Bytes!\\n  \"Description for column: reservePrice\"\\n  reservePrice: BigInt!\\n  \"Description for column: reserveAuctionBid\"\\n  reserveAuctionBid: BigInt!\\n  \"Description for column: reserveAuctionStartDate\"\\n  reserveAuctionStartDate: BigInt!\\n  \"Description for column: previousReserveAuctionEndTimestamp\"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionEndTimestamp\"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionNumTimesExtended\"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \"Description for column: isReserveAuctionInSuddenDeath\"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \"Description for column: reserveAuctionTotalExtensionLengthInSeconds\"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \"Description for column: isReserveAuctionResulted\"\\n  isReserveAuctionResulted: Boolean!\\n  \"Description for column: isReserveAuctionResultedDateTime\"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \"Description for column: reserveAuctionResulter\"\\n  reserveAuctionResulter: Bytes!\\n  \"Description for column: reserveAuctionCanEmergencyExit\"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \"Description for column: creatorContract\"\\n  creatorContract: CreatorContract\\n}\\n\\n\"Description for table: Composable\"\\ntype Composable @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: items\"\\n  items: [ComposableItem!]\\n}\\n\\n\"Description for table: ComposableItem\"\\ntype ComposableItem @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: address\"\\n  address: String!\\n  \"Description for column: tokenID\"\\n  tokenID: String!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: value\"\\n  value: BigInt!\\n}\\n\\n\"Description for table: CollectiveHandlers\"\\ntype CollectiveHandlers @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: active\"\\n  active: Boolean!\\n  \"Description for column: lastUpdatedTimestamp\"\\n  lastUpdatedTimestamp: BigInt!\\n  \"Description for column: lastUpdatedTransactionHash\"\\n  lastUpdatedTransactionHash: Bytes!\\n}\\n\\n\"Description for table: Collective\"\\ntype Collective @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: baseHandler\"\\n  baseHandler: Bytes!\\n  \"Description for column: creator\"\\n  creator: Bytes!\\n  \"Description for column: recipients\"\\n  recipients: [Bytes!]!\\n  \"Description for column: splits\"\\n  splits: [BigInt!]!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n  \"Description for column: isDeployed\"\\n  isDeployed: Boolean!\\n}\\n\\n\"Description for table: Edition\"\\ntype Edition @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: editionNmber\"\\n  editionNmber: String!\\n  \"Description for column: editionType\"\\n  editionType: BigInt!\\n  \"Description for column: editionData\"\\n  editionData: Bytes\\n  \"Description for column: creatorContract\"\\n  creatorContract: CreatorContract\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: revokedApproval\"\\n  revokedApproval: Boolean!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: tokenIds\"\\n  tokenIds: [String!]!\\n  \"Description for column: tokens\"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \"Description for column: tokenURI\"\\n  tokenURI: String!\\n  \"Description for column: artistAccount\"\\n  artistAccount: Bytes!\\n  \"Description for column: artistCommission\"\\n  artistCommission: BigInt!\\n  \"Description for column: optionalCommissionAccount\"\\n  optionalCommissionAccount: Bytes\\n  \"Description for column: optionalCommissionRate\"\\n  optionalCommissionRate: BigInt\\n  \"Description for column: collaborators\"\\n  collaborators: [Bytes!]!\\n  \"Description for column: collective\"\\n  collective: Collective\\n  \"Description for column: offersOnly\"\\n  offersOnly: Boolean!\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt!\\n  \"Description for column: totalAvailable\"\\n  totalAvailable: BigInt!\\n  \"Description for column: remainingSupply\"\\n  remainingSupply: BigInt!\\n  \"Description for column: totalSold\"\\n  totalSold: BigInt!\\n  \"Description for column: totalBurnt\"\\n  totalBurnt: BigInt!\\n  \"Description for column: originalEditionSize\"\\n  originalEditionSize: BigInt!\\n  \"Description for column: secondaryRoyaltyV4EditionOverride\"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \"Description for column: sales\"\\n  sales: [Token!]!\\n  \"Description for column: totalEthSpentOnEdition\"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \"Description for column: active\"\\n  active: Boolean!\\n  \"Description for column: metadata\"\\n  metadata: MetaData\\n  \"Description for column: isGenesisEdition\"\\n  isGenesisEdition: Boolean!\\n  \"Description for column: isEnhancedEdition\"\\n  isEnhancedEdition: Boolean!\\n  \"Description for column: isOpenEdition\"\\n  isOpenEdition: Boolean\\n  \"Description for column: hasCoverImage\"\\n  hasCoverImage: Boolean!\\n  \"Description for column: artist\"\\n  artist: Artist\\n  \"Description for column: startDate\"\\n  startDate: BigInt!\\n  \"Description for column: endDate\"\\n  endDate: BigInt!\\n  \"Description for column: reserveAuctionSeller\"\\n  reserveAuctionSeller: Bytes!\\n  \"Description for column: reserveAuctionBidder\"\\n  reserveAuctionBidder: Bytes!\\n  \"Description for column: reservePrice\"\\n  reservePrice: BigInt!\\n  \"Description for column: reserveAuctionBid\"\\n  reserveAuctionBid: BigInt!\\n  \"Description for column: reserveAuctionStartDate\"\\n  reserveAuctionStartDate: BigInt!\\n  \"Description for column: previousReserveAuctionEndTimestamp\"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionEndTimestamp\"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionNumTimesExtended\"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \"Description for column: isReserveAuctionInSuddenDeath\"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \"Description for column: reserveAuctionTotalExtensionLengthInSeconds\"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \"Description for column: isReserveAuctionResulted\"\\n  isReserveAuctionResulted: Boolean!\\n  \"Description for column: isReserveAuctionResultedDateTime\"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \"Description for column: reserveAuctionResulter\"\\n  reserveAuctionResulter: Bytes!\\n  \"Description for column: reserveAuctionCanEmergencyExit\"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \"Description for column: priceInWei\"\\n  priceInWei: BigInt!\\n  \"Description for column: stepSaleBasePrice\"\\n  stepSaleBasePrice: BigInt!\\n  \"Description for column: stepSaleStepPrice\"\\n  stepSaleStepPrice: BigInt!\\n  \"Description for column: currentStep\"\\n  currentStep: BigInt!\\n  \"Description for column: auctionEnabled\"\\n  auctionEnabled: Boolean!\\n  \"Description for column: activeBid\"\\n  activeBid: AuctionEvent\\n  \"Description for column: gatedSale\"\\n  gatedSale: GatedSale\\n  \"Description for column: biddingHistory\"\\n  biddingHistory: [AuctionEvent!]!\\n  \"Description for column: transfers\"\\n  transfers: [TransferEvent!]!\\n  \"Description for column: allOwners\"\\n  allOwners: [Collector!]!\\n  \"Description for column: currentOwners\"\\n  currentOwners: [Collector!]!\\n  \"Description for column: primaryOwners\"\\n  primaryOwners: [Collector!]!\\n  \"Description for column: metadataName\"\\n  metadataName: String!\\n  \"Description for column: metadataArtist\"\\n  metadataArtist: String!\\n  \"Description for column: metadataTagString\"\\n  metadataTagString: String!\\n  \"Description for column: metadataArtistAccount\"\\n  metadataArtistAccount: String!\\n  \"Description for column: metadataPrice\"\\n  metadataPrice: BigInt!\\n  \"Description for column: metadataFormat\"\\n  metadataFormat: String\\n  \"Description for column: metadataTheme\"\\n  metadataTheme: String\\n  \"Description for column: primaryAssetShortType\"\\n  primaryAssetShortType: String\\n  \"Description for column: primaryAssetActualType\"\\n  primaryAssetActualType: String\\n}\\n\\n\"Description for table: MetaData\"\\ntype MetaData @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: description\"\\n  description: String\\n  \"Description for column: image\"\\n  image: String\\n  \"Description for column: image_type\"\\n  image_type: String\\n  \"Description for column: image_size_in_bytes\"\\n  image_size_in_bytes: BigInt\\n  \"Description for column: cover_image\"\\n  cover_image: String\\n  \"Description for column: cover_image_type\"\\n  cover_image_type: String\\n  \"Description for column: cover_image_size_in_bytes\"\\n  cover_image_size_in_bytes: BigInt\\n  \"Description for column: animation_url\"\\n  animation_url: String\\n  \"Description for column: image_sphere\"\\n  image_sphere: Boolean\\n  \"Description for column: scarcity\"\\n  scarcity: String\\n  \"Description for column: artist\"\\n  artist: String\\n  \"Description for column: tags\"\\n  tags: [String!]\\n  \"Description for column: production_year\"\\n  production_year: String\\n  \"Description for column: format\"\\n  format: String\\n  \"Description for column: theme\"\\n  theme: String\\n  \"Description for column: nsfw\"\\n  nsfw: Boolean\\n}\\n\\n\"Description for table: TokenOffer\"\\ntype TokenOffer @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: ownerAtTimeOfBid\"\\n  ownerAtTimeOfBid: Collector!\\n  \"Description for column: bidder\"\\n  bidder: Collector!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}\\n\\n\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: token\"\\n  token: Token\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector!\\n  \"Description for column: bidder\"\\n  bidder: Collector!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: weiValue\"\\n  weiValue: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: lockedUntil\"\\n  lockedUntil: BigInt\\n  \"Description for column: isActive\"\\n  isActive: Boolean!\\n}\\n\\n\"Description for table: PhaseMintCount\"\\ntype PhaseMintCount @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: saleId\"\\n  saleId: String!\\n  \"Description for column: editionId\"\\n  editionId: String!\\n  \"Description for column: phaseId\"\\n  phaseId: String!\\n  \"Description for column: minter\"\\n  minter: String!\\n  \"Description for column: count\"\\n  count: BigInt!\\n}\\n\\n\"Description for table: Phase\"\\ntype Phase @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: saleId\"\\n  saleId: String!\\n  \"Description for column: editionId\"\\n  editionId: String!\\n  \"Description for column: phaseId\"\\n  phaseId: String!\\n  \"Description for column: startTime\"\\n  startTime: BigInt!\\n  \"Description for column: endTime\"\\n  endTime: BigInt!\\n  \"Description for column: walletMintLimit\"\\n  walletMintLimit: BigInt!\\n  \"Description for column: priceInWei\"\\n  priceInWei: BigInt!\\n  \"Description for column: mintCap\"\\n  mintCap: BigInt!\\n  \"Description for column: mintCount\"\\n  mintCount: BigInt!\\n  \"Description for column: merkleRoot\"\\n  merkleRoot: Bytes\\n  \"Description for column: merkleIPFSHash\"\\n  merkleIPFSHash: String\\n}\\n\\n\"Description for table: GatedSale\"\\ntype GatedSale @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: editionId\"\\n  editionId: String!\\n  \"Description for column: paused\"\\n  paused: Boolean!\\n  \"Description for column: primarySaleCommission\"\\n  primarySaleCommission: BigInt!\\n  \"Description for column: artistAccount\"\\n  artistAccount: String\\n  \"Description for column: mintCount\"\\n  mintCount: BigInt!\\n  \"Description for column: phases\"\\n  phases: [Phase!]!\\n}\\n\\n\"Description for table: CreatorContract\"\\ntype CreatorContract @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: implementation\"\\n  implementation: Bytes!\\n  \"Description for column: deployer\"\\n  deployer: Bytes!\\n  \"Description for column: creator\"\\n  creator: Bytes!\\n  \"Description for column: paused\"\\n  paused: Boolean!\\n  \"Description for column: owner\"\\n  owner: Bytes!\\n  \"Description for column: secondaryRoyaltyPercentage\"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \"Description for column: minter\"\\n  minter: Bytes!\\n  \"Description for column: defaultFundsHandler\"\\n  defaultFundsHandler: Bytes!\\n  \"Description for column: defaultFundsRecipients\"\\n  defaultFundsRecipients: [Bytes!]!\\n  \"Description for column: defaultFundsShares\"\\n  defaultFundsShares: [BigInt!]!\\n  \"Description for column: ERC165InterfaceID\"\\n  ERC165InterfaceID: Bytes\\n  \"Description for column: isBatchBuyItNow\"\\n  isBatchBuyItNow: Boolean!\\n  \"Description for column: isHidden\"\\n  isHidden: Boolean!\\n  \"Description for column: transferState\"\\n  transferState: BigInt!\\n  \"Description for column: totalNumOfEditions\"\\n  totalNumOfEditions: BigInt!\\n  \"Description for column: totalNumOfTokensSold\"\\n  totalNumOfTokensSold: BigInt!\\n  \"Description for column: totalEthValueOfSales\"\\n  totalEthValueOfSales: BigDecimal!\\n  \"Description for column: totalNumOfTransfers\"\\n  totalNumOfTransfers: BigInt!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: filterRegistry\"\\n  filterRegistry: Bytes\\n}\\n\\n\"Description for table: CreatorContractSetting\"\\ntype CreatorContractSetting @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: factoryContract\"\\n  factoryContract: Bytes!\\n  \"Description for column: kodaSalesSettingsContract\"\\n  kodaSalesSettingsContract: Bytes!\\n  \"Description for column: platform\"\\n  platform: Bytes!\\n  \"Description for column: platformPrimaryCommission\"\\n  platformPrimaryCommission: BigInt!\\n  \"Description for column: platformSecondaryCommission\"\\n  platformSecondaryCommission: BigInt!\\n  \"Description for column: MODULO\"\\n  MODULO: BigInt!\\n}\\n\\n\"Description for table: ArtistMintingConfig\"\\ntype ArtistMintingConfig @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: mints\"\\n  mints: BigInt!\\n  \"Description for column: firstMintInPeriod\"\\n  firstMintInPeriod: BigInt!\\n  \"Description for column: frequencyOverride\"\\n  frequencyOverride: Boolean!\\n}\\n\\n\"Description for table: Artist\"\\ntype Artist @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: address\"\\n  address: Bytes!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: editionsCount\"\\n  editionsCount: BigInt!\\n  \"Description for column: ccEditionsCount\"\\n  ccEditionsCount: BigInt!\\n  \"Description for column: supply\"\\n  supply: BigInt!\\n  \"Description for column: issuedCount\"\\n  issuedCount: BigInt!\\n  \"Description for column: totalValueInEth\"\\n  totalValueInEth: BigDecimal!\\n  \"Description for column: salesCount\"\\n  salesCount: BigInt!\\n  \"Description for column: totalPrimarySales\"\\n  totalPrimarySales: BigInt!\\n  \"Description for column: totalPrimarySalesInEth\"\\n  totalPrimarySalesInEth: BigDecimal!\\n  \"Description for column: totalSecondarySales\"\\n  totalSecondarySales: BigInt!\\n  \"Description for column: totalSecondarySalesInEth\"\\n  totalSecondarySalesInEth: BigDecimal!\\n  \"Description for column: highestSaleValueInEth\"\\n  highestSaleValueInEth: BigDecimal!\\n  \"Description for column: highestSaleToken\"\\n  highestSaleToken: Token\\n  \"Description for column: firstEdition\"\\n  firstEdition: Edition\\n  \"Description for column: firstEditionTimestamp\"\\n  firstEditionTimestamp: BigInt!\\n  \"Description for column: lastEdition\"\\n  lastEdition: Edition\\n  \"Description for column: lastEditionTimestamp\"\\n  lastEditionTimestamp: BigInt!\\n  \"Description for column: editions\"\\n  editions: [Edition!]! @derivedFrom(field: \"artist\")\\n  \"Description for column: editionIds\"\\n  editionIds: [Edition!]!\\n  \"Description for column: mintingConfig\"\\n  mintingConfig: ArtistMintingConfig!\\n  \"Description for column: creatorContracts\"\\n  creatorContracts: [CreatorContract!]\\n}\\n\\n\"Description for table: Collector\"\\ntype Collector @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: address\"\\n  address: Bytes!\\n  \"Description for column: firstSeen\"\\n  firstSeen: BigInt!\\n  \"Description for column: firstPurchaseTimeStamp\"\\n  firstPurchaseTimeStamp: BigInt!\\n  \"Description for column: lastPurchaseTimeStamp\"\\n  lastPurchaseTimeStamp: BigInt!\\n  \"Description for column: primaryPurchaseCount\"\\n  primaryPurchaseCount: BigInt!\\n  \"Description for column: primaryPurchaseEthSpent\"\\n  primaryPurchaseEthSpent: BigDecimal!\\n  \"Description for column: secondarySaleCount\"\\n  secondarySaleCount: BigInt!\\n  \"Description for column: secondarySaleEthTotal\"\\n  secondarySaleEthTotal: BigDecimal!\\n  \"Description for column: secondaryPurchaseCount\"\\n  secondaryPurchaseCount: BigInt!\\n  \"Description for column: secondaryPurchaseEthSpent\"\\n  secondaryPurchaseEthSpent: BigDecimal!\\n  \"Description for column: totalPurchaseCount\"\\n  totalPurchaseCount: BigInt!\\n  \"Description for column: totalPurchaseEthSpent\"\\n  totalPurchaseEthSpent: BigDecimal!\\n  \"Description for column: tokens\"\\n  tokens: [Token!]! @derivedFrom(field: \"currentOwner\")\\n  \"Description for column: tokenIds\"\\n  tokenIds: [Token!]!\\n}', 'documented_schema': '\" TokenEvent is a table for recording events related to tokens \"\\ntype TokenEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the event. Type: BigInt! \"\\n  version: BigInt!\\n  \" The name of the event. Type: String! \"\\n  name: String!\\n  \" The token associated with the event. References the Token entity. Type: Token! \"\\n  token: Token!\\n  \" The edition associated with the event. References the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The buyer associated with the event. References the Collector entity. Type: Collector \"\\n  buyer: Collector\\n  \" The bidder associated with the event. References the Collector entity. Type: Collector \"\\n  bidder: Collector\\n  \" The current owner associated with the event. References the Collector entity. Type: Collector \"\\n  currentOwner: Collector\\n  \" The value of the event in ETH. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. Type: BigInt! \"\\n  blockNumber: BigInt!\\n}\\n\\n\" TransferEvent is a table for recording events related to transfers of tokens \"\\ntype TransferEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the event. Type: BigInt! \"\\n  version: BigInt!\\n  \" The from address of the transfer. The address of the account that initiated the transfer. Type: Bytes! \"\\n  from: Bytes!\\n  \" The to address of the transfer. The address of the account that received the transfer. Type: Bytes! \"\\n  to: Bytes!\\n  \" The token ID of the transfer. The ID of the token being transferred. Type: BigInt! \"\\n  tokenId: BigInt!\\n  \" The edition associated with the transfer. References the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. \"\\n  blockNumber: BigInt!\\n}\\n\\n\" AuctionEvent is a table for recording events related to primary sale auctions \"\\ntype AuctionEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the event. Type: BigInt! \"\\n  version: BigInt!\\n  \" The edition associated with the auction. References the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The name of the auction. Type: String! \"\\n  name: String!\\n  \" The bidder associated with the auction. This is the address of the person who placed the bid. Type: Bytes! \"\\n  bidder: Bytes!\\n  \" The caller associated with the auction. This is the address of the person who called the auction. Type: Bytes! \"\\n  caller: Bytes!\\n  \" The value of the auction in ETH. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The lockupUntil timestamp of the auction. When set the bidder who set this is locked out. Type: BigInt! \"\\n  lockupUntil: BigInt\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. Type: BigInt! \"\\n  blockNumber: BigInt!\\n}\\n\\n\" ActivityEvent is a table for recording events related to various types of activities \"\\ntype ActivityEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The type of the event. Is either Token, Edition or Creator Contract. Type: String! \"\\n  type: String!\\n  \" The version of the KODA schema used to record the event. KODA 2 or 3. Type: BigInt! \"\\n  version: BigInt!\\n  \" The type of the event. e.g. [\\'EditionCreated\\', \\'Purchase\\', \\'BidPlaced\\', \\'BidAccepted\\', \\'BidIncreased\\', \\'BidRejected\\', \\'BidWithdrawn\\']. Type: String! \"\\n  eventType: String!\\n  \" The edition associated with the event. References the Edition entity. All events relate to an edition unless it\\'s v3. Type: Edition! \"\\n  edition: Edition\\n  \" The token associated with the event. References the Token entity. Type: Token! \"\\n  token: Token\\n  \" The creator associated with the event. This is the address of the person who created the edition. Type: Bytes! \"\\n  creator: Bytes!\\n  \" The creator\\'s commission rate. This is the percentage of the sale price that the creator receives, only valid if the event has a value. Type: BigInt! \"\\n  creatorCommission: BigInt\\n  \" The collaborator associated with the event. This is the address of the person who collaborated on the edition. Type: Bytes! \"\\n  collaborator: Bytes\\n  \" The collaborator\\'s commission rate. This is the percentage of the sale price that the collaborator receives, only valid if the event has a value. Type: BigInt! \"\\n  collaboratorCommission: BigInt\\n  \" The buyer associated with the event. This is the account that triggered the transaction. Type: Bytes! \"\\n  triggeredBy: Bytes\\n  \" The buyer associated with the event. This is the account that serves as the buyer. Type: Bytes! \"\\n  buyer: Bytes\\n  \" The seller associated with the event. This is the account that serves as the seller. Type: Bytes! \"\\n  seller: Bytes\\n  \" The stakeholder addresses associated with the event. This is the list of accounts that interacted during the event. Type: [Bytes!]! \"\\n  stakeholderAddresses: [Bytes!]!\\n  \" The contract address associated with the event. This is the address of the contract that recorded the event. Type: Bytes! \"\\n  contractAddress: Bytes\\n  \" The value of the event in WEI. Type: BigInt! \"\\n  eventValueInWei: BigInt\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. Type: BigInt! \"\\n  blockNumber: BigInt!\\n}\\n\\ntype _Schema_ @fulltext(name: \"listedTokenSearch\", language: en, algorithm: rank, include: [{entity: \"ListedToken\", fields: [{name: \"metadataName\"}, {name: \"metadataArtist\"}, {name: \"metadataArtistAccount\"}, {name: \"metadataTagString\"}, {name: \"primaryAssetShortType\"}, {name: \"primaryAssetActualType\"}]}]) @fulltext(name: \"editionSearch\", language: en, algorithm: rank, include: [{entity: \"Edition\", fields: [{name: \"metadataName\"}, {name: \"metadataArtist\"}, {name: \"metadataArtistAccount\"}, {name: \"metadataTagString\"}, {name: \"metadataFormat\"}, {name: \"metadataTheme\"}, {name: \"primaryAssetShortType\"}, {name: \"primaryAssetActualType\"}]}])\\n\\n\" Day is a table for recording rolled up counts for a given day \"\\ntype Day @entity {\\n  \" The unique identifier for the day. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The date of the day. Type: String! \"\\n  date: String!\\n  \" The total number of transfers made in the day. Type: BigInt! \"\\n  transferCount: BigInt!\\n  \" The total number of editions created in the day. Type: BigInt! \"\\n  editionsCount: BigInt!\\n  \" The total number of bids accepted in the day. Type: BigInt! \"\\n  bidsAcceptedCount: BigInt!\\n  \" The total number of bids placed in the day. Type: BigInt! \"\\n  bidsPlacedCount: BigInt!\\n  \" The total number of bids rejected in the day. Type: BigInt! \"\\n  bidsRejectedCount: BigInt!\\n  \" The total number of bids withdrawn in the day. Type: BigInt! \"\\n  bidsWithdrawnCount: BigInt!\\n  \" The total number of bids increased in the day. This is when the value of the bid is increased. Type: BigInt! \"\\n  bidsIncreasedCount: BigInt!\\n  \" The total value of bids placed in the day. This is the total value of all bids placed in the day. Type: BigDecimal! \"\\n  totalValuePlaceInBids: BigDecimal!\\n  \" The total value of bids cycled in the day. This is the total value of all bids cycled in the day. Type: BigDecimal! \"\\n  totalValueCycledInBids: BigDecimal!\\n  \" The total value of secondary sales in the day. This is recorded in ETH. Type: BigDecimal! \"\\n  secondarySalesValue: BigDecimal!\\n  \" The total number of sales in the day. Type: BigInt! \"\\n  issuedCount: BigInt!\\n  \" The total number of sales in the day. Type: BigInt! \"\\n  salesCount: BigInt!\\n  \" The total value of sales in the day. This is recorded in ETH. Type: BigDecimal! \"\\n  totalValueInEth: BigDecimal!\\n  \" The highest value of a sale in the day. This is recorded in ETH. Type: BigDecimal! \"\\n  highestValueInEth: BigDecimal!\\n  \" The highest value token of a sale in the day. This is recorded in ETH. Type: BigDecimal! \"\\n  highestValueToken: Token\\n  \" The list of tokens issued in the day. Derived from the Token entity. Type: [Token!]! \"\\n  issued: [Token!]!\\n  \" The list of editions issued in the day. Derived from the Edition entity. Type: [Edition!]! \"\\n  editions: [Edition!]!\\n}\\n\\n\" PlatformConfig is a table for recording the platform configuration \"\\ntype PlatformConfig @entity {\\n  \" The unique identifier for the platform configuration. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The address of the royalties registry. This references an address. Type: Bytes! \"\\n  royaltiesRegistry: Bytes\\n  \" The address of the token URI resolver. This references an address. Type: Bytes! \"\\n  tokenUriResolver: Bytes\\n  \" The modulo value for the platform. This is a number. Type: BigInt! \"\\n  modulo: BigInt\\n  \" The primary sale commission rate. This is a percentage. Type: BigInt! \"\\n  primarySaleCommission: BigInt\\n  \" The secondary sale royalty rate. This is a percentage. Type: BigInt! \"\\n  secondarySaleRoyalty: BigInt\\n  \" The marketplace secondary sale royalty rate. This is a percentage. Type: BigInt! \"\\n  marketplaceSecondarySaleRoyalty: BigInt\\n  \" The minimum bid amount. This is a number. Type: BigInt! \"\\n  minBidAmount: BigInt\\n  \" The minting period. This is a number that represents the period that minting is allowed during. Type: BigInt! \"\\n  mintingPeriod: BigInt\\n  \" The maximum number of mints in a period. This is a number that represents the maximum number of mints that can be made during the minting period. Type: BigInt! \"\\n  maxMintsInPeriod: BigInt\\n  \" The merkle proof root. This is a hash of the merkle tree. Type: Bytes! \"\\n  merkleProofRoot: Bytes\\n  \" The merkle proof IPFS hash. This is a hash of the merkle tree. Type: String! \"\\n  merkleProofIpfsHash: String\\n}\\n\\n\" Token is a table for recording the details of a token \"\\ntype Token @entity {\\n  \" The unique identifier for the token. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the token. KODA 2, 3 or 4. Type: BigInt! \"\\n  version: BigInt!\\n  \" The current sales mechanic being used on this edition. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The token ID. This is a number. Type: BigInt! \"\\n  tokenId: BigInt!\\n  \" The total number of transfers made for this token. Type: BigInt! \"\\n  transferCount: BigInt!\\n  \" The edition number. This is a composite ID made from the edition ID and the optional contract address for the creator contract. Type: String! \"\\n  editionNumber: String!\\n  \" The edition associated with the token. This references the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The token URI. This is a string. Type: String! \"\\n  tokenURI: String!\\n  \" The metadata associated with the token. This references the MetaData entity. Type: MetaData! \"\\n  metadata: MetaData\\n  \" The birth timestamp. This is a number that represents the timestamp of the first transfer of the token from the zero address. Type: BigInt! \"\\n  birthTimestamp: BigInt!\\n  \" The primary value in ETH when the token was sold from an edition on KO. Type: BigDecimal! \"\\n  primaryValueInEth: BigDecimal!\\n  \" The total purchase value in ETH. This is the total value of all purchases (primary & secondary). Type: BigDecimal! \"\\n  totalPurchaseValue: BigDecimal!\\n  \" The total purchase count. This is the total number of purchases (primary & secondary). Type: BigInt! \"\\n  totalPurchaseCount: BigInt!\\n  \" The largest secondary sale in ETH. This is the largest secondary sale in ETH. Type: BigDecimal! \"\\n  largestSecondaryValueInEth: BigDecimal!\\n  \" The largest sale price in ETH. This is set to the highest sale price for the token, primary or secondary. Type: BigDecimal! \"\\n  largestSalePriceEth: BigDecimal!\\n  \" The last sale price in ETH. This is the last sale price for the token, primary or secondary. Type: BigDecimal! \"\\n  lastSalePriceInEth: BigDecimal!\\n  \" The last transfer timestamp. This is the timestamp of the last transfer of the token. Type: BigInt! \"\\n  lastTransferTimestamp: BigInt!\\n  \" The current owner of the token. This also has a derived field linking to this from Collector.tokens. Type: Collector! \"\\n  currentOwner: Collector\\n  \" The list of all owners of the token. This is a list of all unique owners of the token. Type: [Collector!]! \"\\n  allOwners: [Collector!]!\\n  \" The list of all transfers made for the token. Type: [TransferEvent!]! \"\\n  transfers: [TransferEvent!]!\\n  \" The list of all token events such as secondary sales and transfers. Type: [TokenEvent!]! \"\\n  tokenEvents: [TokenEvent!]!\\n  \" The current top active offer on a token. Type: TokenOffer! \"\\n  openOffer: TokenOffer\\n  \" The current active top bidder on the secondary market for this token. The current active top bidder is the top bidder on the secondary market for this token. Type: Bytes! \"\\n  currentTopBidder: Bytes\\n  \" The artist account associated with the token. This references the artist account. Type: Bytes! \"\\n  artistAccount: Bytes!\\n  \" The edition active flag. This is a boolean that indicates if the edition is active. Type: Boolean! \"\\n  editionActive: Boolean!\\n  \" The revoked approval flag. This is a boolean that indicates if the seller has revoked approved the marketplace. Type: Boolean! \"\\n  revokedApproval: Boolean!\\n  \" The listed flag. This is a boolean that indicates if the token is listed. Type: Boolean! \"\\n  isListed: Boolean!\\n  \" The list price. This is a number. Type: BigDecimal! \"\\n  listPrice: BigDecimal\\n  \" The lister. This references the Collector entity. Type: Collector! \"\\n  lister: Collector\\n  \" The listing timestamp. This is a number that represents the timestamp of the listing. Type: BigInt! \"\\n  listingTimestamp: BigInt\\n  \" The complete attached token. This references the ListedToken entity. Type: ListedToken! \"\\n  listing: ListedToken\\n  \" The creator contract. This references the CreatorContract entity. Optionally capture creator contract address if it is version 4. Type: CreatorContract! \"\\n  creatorContract: CreatorContract\\n}\\n\\n\" ListedToken is a table for recording the details of a token listed on the secondary market. Only applicable for KODA V2/3. \"\\ntype ListedToken @entity {\\n  \" The unique identifier for the listed token. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the token. KODA 2 or 3. Type: BigInt! \"\\n  version: BigInt!\\n  \" The edition number for the listed token. Type: String! \"\\n  editionNumber: String!\\n  \" The revoked approval flag. This is a boolean that indicates if the seller has revoked approved the marketplace. Type: Boolean! \"\\n  revokedApproval: Boolean!\\n  \" The list price. This is a number representing the price the token was listed at. Type: BigDecimal! \"\\n  listPrice: BigDecimal!\\n  \" The lister. This references the Collector entity. Type: Collector! \"\\n  lister: Collector!\\n  \" The listing timestamp. This is a number that represents the timestamp of the listing. Type: BigInt! \"\\n  listingTimestamp: BigInt!\\n  \" The series number for the token. This is similar to the edition number in a series (i.e. edition no. in the series i.e. #10 from the an edition of 10). Type: BigInt! \"\\n  seriesNumber: BigInt\\n  \" The first edition flag. This is a boolean that indicates if the token is the first edition. Type: Boolean! \"\\n  isFirstEdition: Boolean\\n  \" The last edition flag. This is a boolean that indicates if the token is the last edition. Type: Boolean! \"\\n  isLastEdition: Boolean\\n  \" The genesis edition flag. This is a boolean that indicates if the token is the genesis edition. The genesis edition is the first edition of an artist. Type: Boolean! \"\\n  isGenesisEdition: Boolean\\n  \" The name of the token, flattened from the metadata. Type: String! \"\\n  metadataName: String!\\n  \" The artist of the token, flattened from the metadata. Type: String! \"\\n  metadataArtist: String!\\n  \" The artist account of the token, flattened from the metadata. Type: String! \"\\n  metadataArtistAccount: String!\\n  \" The tag string of the token, flattened from the metadata. Type: String! \"\\n  metadataTagString: String!\\n  \" The primary asset short type of the token, flattened from the metadata. Type: String! \"\\n  primaryAssetShortType: String!\\n  \" The primary asset actual type of the token, flattened from the metadata. Type: String! \"\\n  primaryAssetActualType: String!\\n  \" The complete attached token. This references the Token entity. Type: Token! \"\\n  fullToken: Token!\\n  \" The reserve auction seller. This references the edition seller. Type: Bytes! \"\\n  reserveAuctionSeller: Bytes!\\n  \" The reserve auction bidder. This references the current bidder. Type: Bytes! \"\\n  reserveAuctionBidder: Bytes!\\n  \" The reserve price. This is a number, listed for the reserve auction. Type: BigInt! \"\\n  reservePrice: BigInt!\\n  \" The current bid. This is a number, the current bid for the auction. Type: BigInt! \"\\n  reserveAuctionBid: BigInt!\\n  \" The auction start timestamp. This is a number, the timestamp of the auction start time. Type: BigInt! \"\\n  reserveAuctionStartDate: BigInt!\\n  \" The previous reserve auction end timestamp. This is a number, set to the same as reserve unless an extension is in flight. Type: BigInt! \"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction end timestamp. This is a number, the timestamp of the auction end time. Type: BigInt! \"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \" The number of times the auction has been extended. This is a number, the number of times the auction has been extended. Type: BigInt! \"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \" The sudden death flag. This is a boolean that indicates if the auction is in sudden death. Type: Boolean! \"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \" The total extension length in seconds. This is a number, the total length of the extension. Type: BigInt! \"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \" The reserve auction resulted flag. This is a boolean that indicates if the auction has resulted. Type: Boolean! \"\\n  isReserveAuctionResulted: Boolean!\\n  \" The reserve auction resulted timestamp. This is a number, the timestamp of the auction result. Type: BigInt! \"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \" The reserve auction resulter. This references the bytes of the auction resulter. Type: Bytes! \"\\n  reserveAuctionResulter: Bytes!\\n  \" The reserve auction can emergency exit flag. This is a boolean that indicates if the auction can emergency exit. Type: Boolean! \"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \" The creator contract. This references the CreatorContract entity. Optionally capture creator contract address if this is version 4. Type: CreatorContract! \"\\n  creatorContract: CreatorContract\\n}\\n\\n\" Composable is a table for recording the details of a composable item. A composable is a combination of a V3 NFT and a set number of tokens. \"\\ntype Composable @entity {\\n  \" The unique identifier for the composable. This is the address of the composable. Type: ID! \"\\n  id: ID!\\n  \" The list of composable items. This is an array of composable items. Type: [ComposableItem!]! \"\\n  items: [ComposableItem!]\\n}\\n\\n\" A table of composable items. A composable item is one token attached to a composable. \"\\ntype ComposableItem @entity {\\n  \" The unique identifier for the composable item. This is the ID made up of combined tokenID/composing contract/composing IDs. Type: ID! \"\\n  id: ID!\\n  \" The address of the ERC20/ERC721 token. Type: String! \"\\n  address: String!\\n  \" The token ID. This can be thought of as the token ticker. Type: String! \"\\n  tokenID: String!\\n  \" The type of token. This is the technical spec of the token, such as ERC20, ERC721 etc. Type: String! \"\\n  type: String!\\n  \" The value of the token. This is the number of tokens attached or the ERC721 token ID. Type: BigInt! \"\\n  value: BigInt!\\n}\\n\\n\" A table of approved collective handlers. A collective handler is a contract which is cloned and used to handle the collective. \"\\ntype CollectiveHandlers @entity {\\n  \" The unique identifier for the collective handler. This is the base address of the collective handler. Type: ID! \"\\n  id: ID!\\n  \" The active flag. This is a boolean that indicates if the collective handler is active. Type: Boolean! \"\\n  active: Boolean!\\n  \" The last updated timestamp. This is a number, the timestamp of the last update to the collective handler. Type: BigInt! \"\\n  lastUpdatedTimestamp: BigInt!\\n  \" The last updated transaction hash. This is the transaction hash of the last update to the collective handler. Type: Bytes! \"\\n  lastUpdatedTransactionHash: Bytes!\\n}\\n\\n\" A table of collective contracts. \"\\ntype Collective @entity {\\n  \" The unique identifier for the collective. This is the deployed address of the collective. Type: ID! \"\\n  id: ID!\\n  \" The base handler. This is the clone which this is based on. Type: Bytes! \"\\n  baseHandler: Bytes!\\n  \" The creator. This is the address of the creator who deployed the collective. Type: Bytes! \"\\n  creator: Bytes!\\n  \" The recipients. This is an array of addresses who are recipients for the deployed collab. Type: [Bytes!]! \"\\n  recipients: [Bytes!]!\\n  \" The splits. This is an array of numbers who are splits for the deployed collab. Type: [BigInt!]! \"\\n  splits: [BigInt!]!\\n  \" The created timestamp. This is a number, the timestamp of the creation of the collective. Type: BigInt! \"\\n  createdTimestamp: BigInt!\\n  \" The transaction hash. This is the transaction hash of the creation of the collective. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The editions. This is an array of editions assigned to the collective. Type: [Edition!]! \"\\n  editions: [Edition!]!\\n  \" The deployed flag. This is a boolean that indicates if the collective is deployed. Type: Boolean! \"\\n  isDeployed: Boolean!\\n}\\n\\n\" A table of editions. An edition is a collection of tokens. \"\\ntype Edition @entity {\\n  \" The unique identifier for the edition. This is the composite ID made up of the edition ID and the optional contract address for the creator contract. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the edition. KODA 2, 3 or 4. Type: BigInt! \"\\n  version: BigInt!\\n  \" The edition number. This is the edition number. This is not a composite key. Type: String! \"\\n  editionNmber: String!\\n  \" The edition type. This is a legacy field from KODA V2. Type: BigInt! \"\\n  editionType: BigInt!\\n  \" The edition data. This is a legacy field from KODA V2 which contains some additional data about the edition. Type: Bytes! \"\\n  editionData: Bytes\\n  \" The creator contract. This references the CreatorContract entity. Type: CreatorContract! \"\\n  creatorContract: CreatorContract\\n  \" The sales type. This is the current sales mechanic being used on this edition. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The revoked approval flag. This is a boolean that indicates if the seller has revoked approved the marketplace, which is set to true once if the seller has revoked approved the marketplace. Type: Boolean! \"\\n  revokedApproval: Boolean!\\n  \" The created timestamp. This is a number, the timestamp of the creation of the edition. Type: BigInt! \"\\n  createdTimestamp: BigInt!\\n  \" The token IDs. This is an array of token IDs. Type: [String!]! \"\\n  tokenIds: [String!]!\\n  \" The tokens. This is an array of tokens. Type: [Token!]! \"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \" The token URI. This is a string, the URI of the token. Type: String! \"\\n  tokenURI: String!\\n  \" The artist account. This is the address of the artist for the edition. Type: Bytes! \"\\n  artistAccount: Bytes!\\n  \" The artist commission. This is the base artists commission. Type: BigInt! \"\\n  artistCommission: BigInt!\\n  \" The optional commission account. This is the address of the optional commission account. NOTE: deprecated - V2 only - use collaborators for this. Type: Bytes! \"\\n  optionalCommissionAccount: Bytes\\n  \" The optional commission rate. This is the rate of the optional commission. Type: BigInt! \"\\n  optionalCommissionRate: BigInt\\n  \" The collaborators. This is an array of addresses who have collaborated on this edition. Type: [Bytes!]! \"\\n  collaborators: [Bytes!]!\\n  \" The collective. This references the Collective entity. NOTE: nullable V3 collective i.e. its split funds. Type: Collective! \"\\n  collective: Collective\\n  \" The offers only flag. This is a boolean that indicates if the edition is only for offers. Type: Boolean! \"\\n  offersOnly: Boolean!\\n  \" The total supply. This is the total purchases or mints i.e. total number of primary transfers. Type: BigInt! \"\\n  totalSupply: BigInt!\\n  \" The total available. This is the total number available to be purchased i.e. edition size. Type: BigInt! \"\\n  totalAvailable: BigInt!\\n  \" The remaining supply. This is the total remaining i.e. number of primary sale tokens left to buy from this edition. Type: BigInt! \"\\n  remainingSupply: BigInt!\\n  \" The total sold. This is the total number sold i.e. number of primary sale tokens sold. sold = purchase/bid accepted with price > 0. Type: BigInt! \"\\n  totalSold: BigInt!\\n  \" The total burnt. This is the total number burnt i.e. number of primary sale tokens burnt. burnt = send to 0xDead or 0x0 (only applicable for V3). Type: BigInt! \"\\n  totalBurnt: BigInt!\\n  \" The original edition size. This is the original edition size of the edition at mint - this field should NEVER change once set. Type: BigInt! \"\\n  originalEditionSize: BigInt!\\n  \" The secondary royalty V4 edition override. This is the EIP2981 percentage requested by the creator(s) at the edition level. Type: BigInt! \"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \" The sales. This is an array of tokens that have been sold from this edition. Type: [Token!]! \"\\n  sales: [Token!]!\\n  \" The total eth spent on the edition. This is the total amount of ETH spent on the edition. Type: BigDecimal! \"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \" The active flag. This is a boolean that indicates if the edition is active. Type: Boolean! \"\\n  active: Boolean!\\n  \" The metadata. This references the MetaData entity. Type: MetaData! \"\\n  metadata: MetaData\\n  \" The isGenesisEdition flag. This is a boolean that indicates if the edition is the first edition. This is set true if edition is an artists first edition. Type: Boolean! \"\\n  isGenesisEdition: Boolean!\\n  \" The isEnhancedEdition flag. This is a boolean that indicates if the edition is an enhanced edition. This is set true if any of the tokens are enhanced i.e. composed. Type: Boolean! \"\\n  isEnhancedEdition: Boolean!\\n  \" The isOpenEdition flag. This is a boolean that indicates if the edition is an open edition. This is applicable to version 4 and editions where the artist does not mint all of the tokens up front. Type: Boolean! \"\\n  isOpenEdition: Boolean\\n  \" The hasCoverImage flag. This is a boolean that indicates if the edition has a cover image. Type: Boolean! \"\\n  hasCoverImage: Boolean!\\n  \" The artist. This references the Artist entity, and reference the primary minter. Type: Artist! \"\\n  artist: Artist\\n  \" The start date. This is a number, the timestamp of the start date of the edition. Type: BigInt! \"\\n  startDate: BigInt!\\n  \" The end date. The date when the edition is available until (only applicable for V2). Type: BigInt! \"\\n  endDate: BigInt!\\n  \" The reserve auction seller. This is the address of the edition seller. Type: Bytes! \"\\n  reserveAuctionSeller: Bytes!\\n  \" The reserve auction bidder. This is the address of the current bidder. Type: Bytes! \"\\n  reserveAuctionBidder: Bytes!\\n  \" The reserve price. This is the listed reserve price. Type: BigInt! \"\\n  reservePrice: BigInt!\\n  \" The reserve auction bid. This is the current bid. Type: BigInt! \"\\n  reserveAuctionBid: BigInt!\\n  \" The reserve auction start date. This is the timestamp of the auction start. Type: BigInt! \"\\n  reserveAuctionStartDate: BigInt!\\n  \" The previous reserve auction end timestamp. This is set to the same as reserve unless an extension is in flight. Type: BigInt! \"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction end timestamp. This is the timestamp of the auction end. Type: BigInt! \"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction number of times extended. This is the number of times the auction has been extended. Type: BigInt! \"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \" The reserve auction in sudden death flag. This is a boolean that indicates if the auction is in sudden death. Type: Boolean! \"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \" The reserve auction total extension length in seconds. This is the total length of the extension. Type: BigInt! \"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \" The reserve auction resulted flag. This is a boolean that indicates if the auction has resulted. Type: Boolean! \"\\n  isReserveAuctionResulted: Boolean!\\n  \" The reserve auction resulted timestamp. This is the timestamp of the auction result. Type: BigInt! \"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \" The reserve auction resulter. This is the address of the auction resulter. Type: Bytes! \"\\n  reserveAuctionResulter: Bytes!\\n  \" The reserve auction can emergency exit flag. This is a boolean that indicates if the auction can emergency exit. Type: Boolean! \"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \" The price in wei. This is the buy now price / current step price. Type: BigInt! \"\\n  priceInWei: BigInt!\\n  \" The step sale base price. This is the base price of the step sale. Type: BigInt! \"\\n  stepSaleBasePrice: BigInt!\\n  \" The step sale step price. This is the step price of the step sale. Type: BigInt! \"\\n  stepSaleStepPrice: BigInt!\\n  \" The current step. This is the current step of the step sale. Type: BigInt! \"\\n  currentStep: BigInt!\\n  \" The auction enabled flag. This is a boolean that indicates if the auction is enabled. Type: Boolean! \"\\n  auctionEnabled: Boolean!\\n  \" The active bid. This references the AuctionEvent entity. Type: AuctionEvent! \"\\n  activeBid: AuctionEvent\\n  \" The gated sale. This references the GatedSale entity. Represents if the edition is gated, which means the edition is only available to a certain set of users. Type: GatedSale! \"\\n  gatedSale: GatedSale\\n  \" The bidding history. This is an array of AuctionEvent entities. Type: [AuctionEvent!]! \"\\n  biddingHistory: [AuctionEvent!]!\\n  \" The transfers. The total number of token transfers made for all tokens from the edition. Type: [TransferEvent!]! \"\\n  transfers: [TransferEvent!]!\\n  \" The all owners. The list (set) of all unique owners for all tokens. Type: [Collector!]! \"\\n  allOwners: [Collector!]!\\n  \" The current owners. The current set of owners for this edition. Type: [Collector!]! \"\\n  currentOwners: [Collector!]!\\n  \" The primary owners. The owner is set when sold in primary sale. Type: [Collector!]! \"\\n  primaryOwners: [Collector!]!\\n  \" The metadata name. This is the name of the edition. Type: String! \"\\n  metadataName: String!\\n  \" The metadata artist. This is the artist of the edition. Type: String! \"\\n  metadataArtist: String!\\n  \" The metadata tag string. This is the tags of the edition. Type: String! \"\\n  metadataTagString: String!\\n  \" The metadata artist account. This is the artist account of the edition. Type: String! \"\\n  metadataArtistAccount: String!\\n  \" The metadata price. A consolidated price for all sale types, making it orderable in lists. Type: BigInt! \"\\n  metadataPrice: BigInt!\\n  \" The metadata format. This is the format of the edition (null-able as V3 only). Type: String! \"\\n  metadataFormat: String\\n  \" The metadata theme. This is the theme of the edition (null-able as V3 only). Type: String! \"\\n  metadataTheme: String\\n  \" The primary asset short type. This is the short type of the primary asset (null-able leading mime-type field i.e. image or video etc). Type: String! \"\\n  primaryAssetShortType: String\\n  \" The primary asset actual type. This is the actual type of the primary asset (null-able ending mime-type field e.g. mp4, gif, png etc). Type: String! \"\\n  primaryAssetActualType: String\\n}\\n\\n\" A table of metadata. A token/editions and its meta data. \"\\ntype MetaData @entity(immutable: true) {\\n  \" The unique identifier for the metadata. This is the ID of the metadata. Type: ID! \"\\n  id: ID!\\n  \" The name. This is the name of the metadata. Type: String! \"\\n  name: String\\n  \" The description. This is the description of the metadata. Type: String! \"\\n  description: String\\n  \" The image for the metadata. This is the image of the metadata. Type: String! \"\\n  image: String\\n  \" The image type. This is the type of the image (only added july-2020). Type: String! \"\\n  image_type: String\\n  \" The image size in bytes. Type: BigInt! \"\\n  image_size_in_bytes: BigInt\\n  \" The cover image that is used for the metadata (optional - only added july-2020). Type: String! \"\\n  cover_image: String\\n  \" The cover image type. This is the type of the cover image (only added july-2020). Type: String! \"\\n  cover_image_type: String\\n  \" The cover image size in bytes. This is the size of the cover image in bytes (only added july-2020). Type: BigInt! \"\\n  cover_image_size_in_bytes: BigInt\\n  \" The animation URL. This is the URL of the animation. Type: String! \"\\n  animation_url: String\\n  \" The image sphere flag (optional - only added Jan-21). Type: Boolean! \"\\n  image_sphere: Boolean\\n  \" The scarcity. This is the scarcity of the metadata. Type: String! \"\\n  scarcity: String\\n  \" The artist. This is the artist of the metadata. Type: String! \"\\n  artist: String\\n  \" The tags. This is an array of tags for the metadata. Type: [String!]! \"\\n  tags: [String!]\\n  \" The production year. This is the production year of the metadata. Type: String! \"\\n  production_year: String\\n  \" The format. This is the format of the metadata. Type: String! \"\\n  format: String\\n  \" The theme. This is the theme of the metadata. Type: String! \"\\n  theme: String\\n  \" The nsfw flag. This is a boolean that indicates if the metadata is nsfw. Type: Boolean! \"\\n  nsfw: Boolean\\n}\\n\\n\" A table of token offers. A single high level entity capturing the top offer on the secondary marketplace. \"\\ntype TokenOffer @entity(immutable: true) {\\n  \" The unique identifier for the token offer. This is the ID of the token offer. Type: ID! \"\\n  id: ID!\\n  \" The version. This is the version of the KODA schema used to record the token offer. Type: BigInt! \"\\n  version: BigInt!\\n  \" The token. This references the Token entity. Type: Token! \"\\n  token: Token!\\n  \" The edition of the token offer. This references the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The owner at time of bid. When the token is offered for sale, this is the owner of said token. This references the Collector entity. Type: Collector! \"\\n  ownerAtTimeOfBid: Collector!\\n  \" The bidder. This references the Collector entity. Type: Collector! \"\\n  bidder: Collector!\\n  \" The eth value. This is the eth value of the token offer. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The timestamp. This is the timestamp of the token offer. Type: BigInt! \"\\n  timestamp: BigInt!\\n}\\n\\n\" A table of offers. Encapsulates all offers either on editions or tokens. \"\\ntype Offer @entity {\\n  \" The unique identifier for the offer. This is edition ID or token ID. Type: ID! \"\\n  id: ID!\\n  \" The version. This is the version of the KODA schema used to record the offer. Type: BigInt! \"\\n  version: BigInt!\\n  \" The type. This is the type of the offer, either Token or Edition. Type: String! \"\\n  type: String!\\n  \" The sales type. This is the current sales mechnic being used on this offer. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The token in the offer. This is a nullable token, as editions dont have tokens attached. Type: Token! \"\\n  token: Token\\n  \" The edition in the offer. All offers must be from an edition. Type: Edition! \"\\n  edition: Edition!\\n  \" The current owner of the offer, refering to the collection the offer is from. This is either the token holder or the edition artist. Type: Collector! \"\\n  currentOwner: Collector!\\n  \" The bidder. This is the address of account making the bid. This references the Collector entity. Type: Collector! \"\\n  bidder: Collector!\\n  \" The eth value of the offer. This is human readable eth value of the offer. Type: BigDecimal! \"\\n  ethValue: BigDecimal!\\n  \" The wei value of the offer. This is the wei value, meaning the non-converted value of ETh, of the offer. Type: BigInt! \"\\n  weiValue: BigInt!\\n  \" The timestamp of the offer. This is the timestamp of the offer. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the offer. This is the transaction hash of the offer. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The locked until timestamp of the offer. For V3 offers, they will be locked for a certain amount of time. Type: BigInt! \"\\n  lockedUntil: BigInt\\n  \" The active flag of the offer. This is a boolean that indicates if the offer is active, as only active offers can be seen in the UI. Type: Boolean! \"\\n  isActive: Boolean!\\n}\\n\\n\" A table of phase mint counts. Store the total mints per user, per sale & phase. \"\\ntype PhaseMintCount @entity {\\n  \" The unique identifier for the phase mint count. This is a composite key (sale, edition, phase, minter) - unique per user and sale/phase. Type: ID! \"\\n  id: ID!\\n  \" The sale. This is the sale this phase relates to. Type: String! \"\\n  saleId: String!\\n  \" The edition. This is the edition this phase relates to. Type: String! \"\\n  editionId: String!\\n  \" The phase. This is the actual phase number. Type: String! \"\\n  phaseId: String!\\n  \" The minter. This is the minter who is creating the tokens. Type: String! \"\\n  minter: String!\\n  \" The count. This is the total number of tokens minted by the minter in this phase. Type: BigInt! \"\\n  count: BigInt!\\n}\\n\\n\" A table of phase. A gate sale phase configuration. \"\\ntype Phase @entity {\\n  \" The unique identifier for the phase. Type: ID! \"\\n  id: ID!\\n  \" The sale. This is the sale this phase relates to. Type: String! \"\\n  saleId: String!\\n  \" The edition. This is the edition this phase relates to. Type: String! \"\\n  editionId: String!\\n  \" The phase. This is the actual phase number. Type: String! \"\\n  phaseId: String!\\n  \" The start time of the sale as a whole. Type: BigInt! \"\\n  startTime: BigInt!\\n  \" The end time of the sale phase, also the beginning of the next phase if applicable. Type: BigInt! \"\\n  endTime: BigInt!\\n  \" The mint limit per wallet for the phase. Type: BigInt! \"\\n  walletMintLimit: BigInt!\\n  \" The price in wei for one mint. Type: BigInt! \"\\n  priceInWei: BigInt!\\n  \" The maximum amount of mints for the phase. Type: BigInt! \"\\n  mintCap: BigInt!\\n  \" The current amount of items minted in this phase. Type: BigInt! \"\\n  mintCount: BigInt!\\n  \" The merkle tree root for the phase. Type: Bytes! \"\\n  merkleRoot: Bytes\\n  \" The IPFS hash referencing the merkle tree. Type: String! \"\\n  merkleIPFSHash: String\\n}\\n\\n\" A table of gated sale. A gate sale configuration - one per edition. \"\\ntype GatedSale @entity {\\n  \" The unique identifier for the gated sale. This is the ID of the gated sale. Type: ID! \"\\n  id: ID!\\n  \" The edition. This is the edition the sale will mint. Type: String! \"\\n  editionId: String!\\n  \" The paused flag. This is a boolean that indicates if the sale is currently paused. Type: Boolean! \"\\n  paused: Boolean!\\n  \" The primary sale commission. This is the overridden sales commission for KO. Type: BigInt! \"\\n  primarySaleCommission: BigInt!\\n  \" The artist account. This is the address of the artist associated with the given edition ID. Type: String! \"\\n  artistAccount: String\\n  \" The mint count. This is the total mint current for the sale. Type: BigInt! \"\\n  mintCount: BigInt!\\n  \" The phases. This is an array of phases associated with the sale. Type: [Phase!]! \"\\n  phases: [Phase!]!\\n}\\n\\n\" A table of creator contracts. Any KODA V4 Contract Deployed from the V4 factory. \"\\ntype CreatorContract @entity {\\n  \" The unique identifier for the creator contract. This is the ID of the creator contract. Type: ID! \"\\n  id: ID!\\n  \" The block number. This is the block number of the deployment. Type: BigInt! \"\\n  blockNumber: BigInt!\\n  \" The timestamp. This is the timestamp of the deployment. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash. This is the transaction hash of the deployment. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index. This is the transaction index of the deployment. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index. This is the log index of the deployment. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The event address. This is the address of the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The event tx from. This is the address of the transaction from. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The event tx to. This is the address of the transaction to. Type: Bytes! \"\\n  eventTxTo: Bytes\\n  \" The implementation. This is the address of the contract cloned during the deployment of the creator contract. Type: Bytes! \"\\n  implementation: Bytes!\\n  \" The deployer. The deployer may be different to creator in the case that platform deployed a contract. Type: Bytes! \"\\n  deployer: Bytes!\\n  \" The creator. This is the address of the creator of the contract. Type: Bytes! \"\\n  creator: Bytes!\\n  \" The paused flag. This is a boolean that indicates if the contract is currently paused. Type: Boolean! \"\\n  paused: Boolean!\\n  \" The owner. This is the address of the owner of the contract. Type: Bytes! \"\\n  owner: Bytes!\\n  \" The secondary royalty percentage. This is across all editions the currently specified secondary royalty EIP2981. Type: BigInt! \"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \" The minter. This is the address of the minter of the contract. Type: Bytes! \"\\n  minter: Bytes!\\n  \" The default funds handler. This is the address of the default funds handler. Type: Bytes! \"\\n  defaultFundsHandler: Bytes!\\n  \" The default funds recipients. This is an array of addresses of the default funds recipients. Type: [Bytes!]! \"\\n  defaultFundsRecipients: [Bytes!]!\\n  \" The default funds shares. This is an array of BigInts of the default funds shares. Type: [BigInt!]! \"\\n  defaultFundsShares: [BigInt!]!\\n  \" The ERC165 interface ID. This is the interface ID of the contract. Type: Bytes! \"\\n  ERC165InterfaceID: Bytes\\n  \" The batch buy it now flag. This is a boolean that indicates if the contract supports batch buy it now. Type: Boolean! \"\\n  isBatchBuyItNow: Boolean!\\n  \" The banned flag. This is a boolean that indicates if the contract is banned. Type: Boolean! \"\\n  isHidden: Boolean!\\n  \" The transfer state. This is the state of the transfer. Type: BigInt! \"\\n  transferState: BigInt!\\n  \" The total number of editions. This is the total number of editions from a given creator contract. Type: BigInt! \"\\n  totalNumOfEditions: BigInt!\\n  \" The total number of tokens sold. This is the total number of tokens sold from a given creator contract. Type: BigInt! \"\\n  totalNumOfTokensSold: BigInt!\\n  \" The total eth value of sales. This is the total eth value of sales from a given creator contract. Type: BigDecimal! \"\\n  totalEthValueOfSales: BigDecimal!\\n  \" The total number of transfers. This is the total number of transfers from a given creator contract. Type: BigInt! \"\\n  totalNumOfTransfers: BigInt!\\n  \" The editions. This is an array of editions created by the creator contract. Type: [Edition!]! \"\\n  editions: [Edition!]!\\n  \" The name. This is the name of the contract. Type: String! \"\\n  name: String\\n  \" The symbol. This is the symbol of the contract. Type: String! \"\\n  symbol: String\\n  \" The filter registry. This is the filter registry of the contract. Type: Bytes! \"\\n  filterRegistry: Bytes\\n}\\n\\n\" A table of creator contract settings. The creator contract settings have the configuration of the creator contract. \"\\ntype CreatorContractSetting @entity {\\n  \" The unique identifier for the creator contract setting. Type: ID! \"\\n  id: ID!\\n  \" The factory contract. This is the address of the factory contract. Type: Bytes! \"\\n  factoryContract: Bytes!\\n  \" The koda sales settings contract. This is the address of the koda sales settings contract which is used to configure the creator contract settings. Type: Bytes! \"\\n  kodaSalesSettingsContract: Bytes!\\n  \" The platform. This is the address of the platform which the creator contract is deployed from. Type: Bytes! \"\\n  platform: Bytes!\\n  \" The platform primary commission. This is the primary commission of the platform. Type: BigInt! \"\\n  platformPrimaryCommission: BigInt!\\n  \" The platform secondary commission. This is the secondary commission of the platform. Type: BigInt! \"\\n  platformSecondaryCommission: BigInt!\\n  \" The modulo. This is the modulo of the platform. Type: BigInt! \"\\n  MODULO: BigInt!\\n}\\n\\n\" A table of artist minting config. The artist minting config has the configuration of the artist minting. \"\\ntype ArtistMintingConfig @entity {\\n  \" The unique identifier for the artist minting config. Type: ID! \"\\n  id: ID!\\n  \" The mints. This is the total number of mints for the artist. Type: BigInt! \"\\n  mints: BigInt!\\n  \" The first mint in period. This is the first mint of a given period for the artist. Type: BigInt! \"\\n  firstMintInPeriod: BigInt!\\n  \" The frequency override. This is a boolean that indicates if the user can mint as much as possible. Type: Boolean! \"\\n  frequencyOverride: Boolean!\\n}\\n\\n\" A table of artists. An artists is someone who has created editions/tokens. \"\\ntype Artist @entity {\\n  \" The unique identifier for the artist. Type: ID! \"\\n  id: ID!\\n  \" The address. This is the address of the artist. Type: Bytes! \"\\n  address: Bytes!\\n  \" The name. This is the name of the artist. Type: String! \"\\n  name: String\\n  \" The editions count. This is the total number of editions created by the artist. Type: BigInt! \"\\n  editionsCount: BigInt!\\n  \" The editions count. This is the total number of editions created by the artist. Type: BigInt! \"\\n  ccEditionsCount: BigInt!\\n  \" The supply. This is the total supply of the artist. Type: BigInt! \"\\n  supply: BigInt!\\n  \" The issued count. This is the total number of issued tokens by the artist. Type: BigInt! \"\\n  issuedCount: BigInt!\\n  \" The total value in eth. This is the total value of assets in eth of the artist. Type: BigDecimal! \"\\n  totalValueInEth: BigDecimal!\\n  \" The sales count. This is the total number of sales of the artist. Type: BigInt! \"\\n  salesCount: BigInt!\\n  \" The total primary sales. This is the total number of primary sales of the artist. Type: BigInt! \"\\n  totalPrimarySales: BigInt!\\n  \" The total primary sales in eth. This is the total number of primary sales in eth of the artist. Type: BigDecimal! \"\\n  totalPrimarySalesInEth: BigDecimal!\\n  \" The total secondary sales. This is the total number of secondary sales of the artist. Type: BigInt! \"\\n  totalSecondarySales: BigInt!\\n  \" The total secondary sales in eth. This is the total number of secondary sales in eth of the artist. Type: BigDecimal! \"\\n  totalSecondarySalesInEth: BigDecimal!\\n  \" The highest sale value in eth. This is the highest sale value in eth of the artist. Type: BigDecimal! \"\\n  highestSaleValueInEth: BigDecimal!\\n  \" The highest sale token. This is the highest sale token of the artist. Type: Token! \"\\n  highestSaleToken: Token\\n  \" The first edition. This is the first edition that the artist created. Type: Edition! \"\\n  firstEdition: Edition\\n  \" The first edition timestamp. This is the timestamp of the first edition that the artist created. Type: BigInt! \"\\n  firstEditionTimestamp: BigInt!\\n  \" The last edition. This is the last edition that the artist created. Type: Edition! \"\\n  lastEdition: Edition\\n  \" The last edition timestamp. This is the timestamp of the last edition that the artist created. Type: BigInt! \"\\n  lastEditionTimestamp: BigInt!\\n  \" All of the editions that the artist has created. derivedFrom only work at query time, not runtime. Type: [Edition!]! \"\\n  editions: [Edition!]! @derivedFrom(field: \"artist\")\\n  \" All of the edition IDs that the artist has created. Type: [Edition!]! \"\\n  editionIds: [Edition!]!\\n  \" The minting config. This is the minting config of the artist. Type: ArtistMintingConfig! \"\\n  mintingConfig: ArtistMintingConfig!\\n  \" The creator contracts. This is an array of creator contracts created by the artist. Type: [CreatorContract!]! \"\\n  creatorContracts: [CreatorContract!]\\n}\\n\\n\" A table of collectors. A single collector who has at sometime held a KO asset. \"\\ntype Collector @entity {\\n  \" The unique identifier for the collector. Type: ID! \"\\n  id: ID!\\n  \" The address. This is the address of the collector. Type: Bytes! \"\\n  address: Bytes!\\n  \" The first seen. This is the first time the collector has been seen. Type: BigInt! \"\\n  firstSeen: BigInt!\\n  \" The first purchase timestamp. This is the timestamp of the first purchase of the collector. Type: BigInt! \"\\n  firstPurchaseTimeStamp: BigInt!\\n  \" The last purchase timestamp. This is the timestamp of the last purchase of the collector. Type: BigInt! \"\\n  lastPurchaseTimeStamp: BigInt!\\n  \" The primary purchase count. This is the total number of primary purchases of the collector. Type: BigInt! \"\\n  primaryPurchaseCount: BigInt!\\n  \" The primary purchase eth spent. This is the total eth spent on primary purchases of the collector. Type: BigDecimal! \"\\n  primaryPurchaseEthSpent: BigDecimal!\\n  \" The secondary sale count. This is the total number of secondary sales of the collector. Type: BigInt! \"\\n  secondarySaleCount: BigInt!\\n  \" The secondary sale eth total. This is the total eth spent on secondary sales of the collector. Type: BigDecimal! \"\\n  secondarySaleEthTotal: BigDecimal!\\n  \" The secondary purchase count. This is the total number of secondary purchases of the collector. Type: BigInt! \"\\n  secondaryPurchaseCount: BigInt!\\n  \" The secondary purchase eth spent. This is the total eth spent on secondary purchases of the collector. Type: BigDecimal! \"\\n  secondaryPurchaseEthSpent: BigDecimal!\\n  \" The total purchase count. This is the total number of purchases of the collector. Type: BigInt! \"\\n  totalPurchaseCount: BigInt!\\n  \" The total purchase eth spent. This is the total eth spent on purchases of the collector. Type: BigDecimal! \"\\n  totalPurchaseEthSpent: BigDecimal!\\n  \" All of the tokens currently owned by this account. derivedFrom only work at query time, not runtime. Type: [Token!]! \"\\n  tokens: [Token!]! @derivedFrom(field: \"currentOwner\")\\n  \" All of the token IDs currently owned by this account. Type: [Token!]! \"\\n  tokenIds: [Token!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines various entities related to a token-based system, including events, tokens, editions, and other related entities. Each entity has fields with specific data types, and some fields are linked to other entities, indicating relationships. The task is to generate detailed descriptions for each field based on the information provided in the schema. The descriptions should be clear, concise, and factual, providing insight into the purpose and nature of each field without altering the schema's structure.\",\n    documented_schema='\"Description for table: TokenEvent\"\\ntype TokenEvent @entity(immutable: true) {\\n  \"Unique identifier for the token event.\"\\n  id: ID!\\n  \"Version number of the token event.\"\\n  version: BigInt!\\n  \"Name of the token event.\"\\n  name: String!\\n  \"Reference to the associated token.\"\\n  token: Token!\\n  \"Reference to the associated edition.\"\\n  edition: Edition!\\n  \"Collector who purchased the token, if applicable.\"\\n  buyer: Collector\\n  \"Collector who placed a bid on the token, if applicable.\"\\n  bidder: Collector\\n  \"Current owner of the token.\"\\n  currentOwner: Collector\\n  \"Value of the token event in Ethereum.\"\\n  ethValue: BigDecimal!\\n  \"Timestamp of when the event occurred.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction associated with the event.\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block.\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry within the transaction.\"\\n  logIndex: BigInt!\\n  \"Address where the event took place.\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction was sent.\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent, if applicable.\"\\n  eventTxTo: Bytes\\n  \"Block number in which the event was included.\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: TransferEvent\"\\ntype TransferEvent @entity(immutable: true) {\\n  \"Unique identifier for the transfer event.\"\\n  id: ID!\\n  \"Version number of the transfer event.\"\\n  version: BigInt!\\n  \"Address from which the token was transferred.\"\\n  from: Bytes!\\n  \"Address to which the token was transferred.\"\\n  to: Bytes!\\n  \"Identifier of the token being transferred.\"\\n  tokenId: BigInt!\\n  \"Reference to the associated edition.\"\\n  edition: Edition!\\n  \"Timestamp of when the transfer occurred.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction associated with the transfer.\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block.\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry within the transaction.\"\\n  logIndex: BigInt!\\n  \"Address where the transfer event took place.\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction was sent.\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent, if applicable.\"\\n  eventTxTo: Bytes\\n  \"Block number in which the transfer was included.\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: AuctionEvent\"\\ntype AuctionEvent @entity(immutable: true) {\\n  \"Unique identifier for the auction event.\"\\n  id: ID!\\n  \"Version number of the auction event.\"\\n  version: BigInt!\\n  \"Reference to the associated edition.\"\\n  edition: Edition!\\n  \"Name of the auction event.\"\\n  name: String!\\n  \"Address of the bidder in the auction.\"\\n  bidder: Bytes!\\n  \"Address of the caller who initiated the auction.\"\\n  caller: Bytes!\\n  \"Value of the auction event in Ethereum.\"\\n  ethValue: BigDecimal!\\n  \"Timestamp until which the auction is locked up.\"\\n  lockupUntil: BigInt\\n  \"Timestamp of when the auction event occurred.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction associated with the auction.\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block.\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry within the transaction.\"\\n  logIndex: BigInt!\\n  \"Address where the auction event took place.\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction was sent.\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent, if applicable.\"\\n  eventTxTo: Bytes\\n  \"Block number in which the auction was included.\"\\n  blockNumber: BigInt!\\n}\\n\\n\"Description for table: ActivityEvent\"\\ntype ActivityEvent @entity(immutable: true) {\\n  \"Unique identifier for the activity event.\"\\n  id: ID!\\n  \"Type of the activity event.\"\\n  type: String!\\n  \"Version number of the activity event.\"\\n  version: BigInt!\\n  \"Specific type of event that occurred.\"\\n  eventType: String!'\n)",
      1
    ],
    [
      "Example({'database_schema': '\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transactionHash\"\\n  transactionHash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: isBundle\"\\n  isBundle: Boolean!\\n  \"Description for column: collection\"\\n  collection: Collection!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: priceETH\"\\n  priceETH: BigDecimal!\\n  \"Description for column: strategy\"\\n  strategy: SaleStrategy!\\n  \"Description for column: buyer\"\\n  buyer: String!\\n  \"Description for column: seller\"\\n  seller: String!\\n}', 'documented_schema': '\" Trades exist such as a combination of taker/order and bid/ask. \"\\ntype Trade @entity @transaction {\\n  \" { Transaction hash }-{ Log index }-{ (optional) ID within bundle } \"\\n  id: ID!\\n  \" Event transaction hash. \"\\n  transactionHash: String!\\n  \" Event log index. \"\\n  logIndex: Int\\n  \" Block timestamp where the trade is executed. \"\\n  timestamp: BigInt!\\n  \" Block number where the trade is executed. \"\\n  blockNumber: BigInt!\\n  \" Whether the trade is in a bundle. \"\\n  isBundle: Boolean!\\n  \" Collection involved \"\\n  collection: Collection!\\n  \" Token ID of the traded NFT. \"\\n  tokenId: BigInt!\\n  \" The amount of token to transfer. It is set at 1 except for ERC1155 batch. \"\\n  amount: BigInt!\\n  \" Price (in ETH). If only 1 tokenId is involved, then the price is determined by the token only. If the trade is incurred by a batch purchasing (available in x2y2), then the price is the average price in the batch. \"\\n  priceETH: BigDecimal!\\n  \" Stretegy that the trade is executed. \"\\n  strategy: SaleStrategy!\\n  \" Buyer account address \"\\n  buyer: String!\\n  \" Seller account address \"\\n  seller: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a `Trade` entity with various fields, each representing a specific attribute of a trade transaction. The task is to generate detailed descriptions for each field based on their names and types, ensuring clarity and precision. The descriptions should be factual and straightforward, avoiding any speculative language. The documentation should help developers and system architects understand the purpose and data type of each field without altering the schema structure.',\n    documented_schema='\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Unique identifier for the trade.\"\\n  id: ID!\\n  \"Hash of the transaction associated with the trade.\"\\n  transactionHash: String!\\n  \"Index of the log entry within the transaction.\"\\n  logIndex: Int\\n  \"Timestamp indicating when the trade occurred, represented as a Unix epoch time.\"\\n  timestamp: BigInt!\\n  \"Block number in which the trade was recorded on the blockchain.\"\\n  blockNumber: BigInt!\\n  \"Indicates whether the trade is part of a bundle of trades.\"\\n  isBundle: Boolean!\\n  \"Reference to the collection involved in the trade.\"\\n  collection: Collection!\\n  \"Identifier for the token being traded.\"\\n  tokenId: BigInt!\\n  \"Quantity of tokens involved in the trade.\"\\n  amount: BigInt!\\n  \"Price of the trade expressed in Ethereum (ETH).\"\\n  priceETH: BigDecimal!\\n  \"Strategy used for the sale in the trade.\"\\n  strategy: SaleStrategy!\\n  \"Address of the buyer in the trade.\"\\n  buyer: String!\\n  \"Address of the seller in the trade.\"\\n  seller: String!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: DexAmmProtocol\"\\ntype DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: type\"\\n  type: ProtocolType!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: totalLiquidityUSD\"\\n  totalLiquidityUSD: BigDecimal!\\n  \"Description for column: activeLiquidityUSD\"\\n  activeLiquidityUSD: BigDecimal!\\n  \"Description for column: uncollectedProtocolSideValueUSD\"\\n  uncollectedProtocolSideValueUSD: BigDecimal!\\n  \"Description for column: uncollectedSupplySideValueUSD\"\\n  uncollectedSupplySideValueUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: cumulativeUniqueLPs\"\\n  cumulativeUniqueLPs: Int!\\n  \"Description for column: cumulativeUniqueTraders\"\\n  cumulativeUniqueTraders: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: openPositionCount\"\\n  openPositionCount: Int!\\n  \"Description for column: cumulativePositionCount\"\\n  cumulativePositionCount: Int!\\n  \"Description for column: lastSnapshotDayID\"\\n  lastSnapshotDayID: Int!\\n  \"Description for column: lastUpdateTimestamp\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Description for column: lastUpdateBlockNumber\"\\n  lastUpdateBlockNumber: BigInt!\\n  \"Description for column: dailyUsageMetrics\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: hourlyUsageMetrics\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: financialMetrics\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: pools\"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \"Description for column: _regenesis\"\\n  _regenesis: Boolean!\\n}', 'documented_schema': 'type DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: Bytes!\\n  \" Name of the protocol, including version. e.g. Uniswap v3 \"\\n  name: String!\\n  \" Slug of protocol, including version. e.g. uniswap-v3 \"\\n  slug: String!\\n  \" Version of the subgraph schema, in SemVer format (e.g. 1.0.0) \"\\n  schemaVersion: String!\\n  \" Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) \"\\n  subgraphVersion: String!\\n  \" Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) \"\\n  methodologyVersion: String!\\n  \" The blockchain network this subgraph is indexing on \"\\n  network: Network!\\n  \" The type of protocol (e.g. DEX, Lending, Yield, etc) \"\\n  type: ProtocolType!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" The sum of all active and non-active liquidity in USD for this pool. \"\\n  totalLiquidityUSD: BigDecimal!\\n  \" All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick. \"\\n  activeLiquidityUSD: BigDecimal!\\n  \" All protocol-side value locking in USD that remains uncollected and unused in the protocol. \"\\n  uncollectedProtocolSideValueUSD: BigDecimal!\\n  \" All supply-side value locking in USD that remains uncollected and unused in the protocol. \"\\n  uncollectedSupplySideValueUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" All historical volume in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Number of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Number of cumulative liquidity providers \"\\n  cumulativeUniqueLPs: Int!\\n  \" Number of cumulative traders \"\\n  cumulativeUniqueTraders: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Total number of open positions \"\\n  openPositionCount: Int!\\n  \" Total number of positions (open and closed) \"\\n  cumulativePositionCount: Int!\\n  \" Day ID of the most recent daily snapshot \"\\n  lastSnapshotDayID: Int!\\n  \" Timestamp of the last time this entity was updated \"\\n  lastUpdateTimestamp: BigInt!\\n  \" Block number of the last time this entity was updated \"\\n  lastUpdateBlockNumber: BigInt!\\n  \" Daily usage metrics for this protocol \"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Hourly usage metrics for this protocol \"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" Daily financial metrics for this protocol \"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \" All pools that belong to this protocol \"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \" This is a boolean to indicate whether or not the pools have been instantiated the were initialized before Optimism regenesis \"\\n  _regenesis: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `DexAmmProtocol` which implements the `Protocol` interface and is annotated with `@entity` and `@regularPolling`. This type represents a decentralized exchange automated market maker protocol, capturing various metrics and attributes related to its operation. Each field within the type is accompanied by a placeholder for a description, indicating the need for detailed documentation. The fields include identifiers, versioning information, financial metrics, user statistics, and relationships to other entities such as usage metrics and liquidity pools. The task is to provide clear and concise descriptions for each field based on their names and types, ensuring that the documentation is informative and aids in understanding the schema's structure and purpose.\",\n    documented_schema='\"Description for table: DexAmmProtocol\"\\ntype DexAmmProtocol implements Protocol @entity @regularPolling {\\n  \"Unique identifier for the protocol instance.\"\\n  id: Bytes!\\n  \"Human-readable name of the protocol.\"\\n  name: String!\\n  \"URL-friendly identifier for the protocol, often used in routing.\"\\n  slug: String!\\n  \"Version of the schema used by the protocol.\"\\n  schemaVersion: String!\\n  \"Version of the subgraph deployed for the protocol.\"\\n  subgraphVersion: String!\\n  \"Version of the methodology applied in the protocol\\'s calculations.\"\\n  methodologyVersion: String!\\n  \"Blockchain network on which the protocol operates.\"\\n  network: Network!\\n  \"Type of protocol, indicating its specific category or function.\"\\n  type: ProtocolType!\\n  \"Total value locked in the protocol, denominated in USD.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Total liquidity available in the protocol, denominated in USD.\"\\n  totalLiquidityUSD: BigDecimal!\\n  \"Active liquidity currently being utilized in the protocol, denominated in USD.\"\\n  activeLiquidityUSD: BigDecimal!\\n  \"Value of protocol-side assets that have not been collected, denominated in USD.\"\\n  uncollectedProtocolSideValueUSD: BigDecimal!\\n  \"Value of supply-side assets that have not been collected, denominated in USD.\"\\n  uncollectedSupplySideValueUSD: BigDecimal!\\n  \"Value of assets controlled by the protocol, denominated in USD.\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Cumulative trading volume processed by the protocol, denominated in USD.\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Cumulative revenue generated for liquidity providers, denominated in USD.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue generated for the protocol itself, denominated in USD.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Total cumulative revenue generated by the protocol, denominated in USD.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Total number of unique users who have interacted with the protocol.\"\\n  cumulativeUniqueUsers: Int!\\n  \"Total number of unique liquidity providers who have participated in the protocol.\"\\n  cumulativeUniqueLPs: Int!\\n  \"Total number of unique traders who have executed trades on the protocol.\"\\n  cumulativeUniqueTraders: Int!\\n  \"Total number of liquidity pools created within the protocol.\"\\n  totalPoolCount: Int!\\n  \"Current number of open positions within the protocol.\"\\n  openPositionCount: Int!\\n  \"Total number of positions ever opened within the protocol.\"\\n  cumulativePositionCount: Int!\\n  \"Identifier for the last daily snapshot taken of the protocol\\'s state.\"\\n  lastSnapshotDayID: Int!\\n  \"Timestamp of the last update made to the protocol\\'s data.\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Block number of the last update made to the protocol\\'s data.\"\\n  lastUpdateBlockNumber: BigInt!\\n  \"Daily snapshots of usage metrics related to the protocol.\"\\n  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Hourly snapshots of usage metrics related to the protocol.\"\\n  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"Daily snapshots of financial metrics related to the protocol.\"\\n  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: \"protocol\")\\n  \"List of liquidity pools associated with the protocol.\"\\n  pools: [LiquidityPool!]! @derivedFrom(field: \"protocol\")\\n  \"Flag indicating whether the protocol has undergone a regenesis event.\"\\n  _regenesis: Boolean!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Deposit\"\\ntype Deposit implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: inputTokenAmounts\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Description for column: outputTokenAmount\"\\n  outputTokenAmount: BigInt\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n}', 'documented_schema': 'type Deposit implements Event @entity @transaction {\\n  \" deposit-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool \"\\n  inputTokens: [Token!]!\\n  \" Output token of the pool. E.g. the UNI-LP token \"\\n  outputToken: Token\\n  \" Amount of input tokens in the token\\'s native unit \"\\n  inputTokenAmounts: [BigInt!]!\\n  \" Amount of output tokens in the token\\'s native unit \"\\n  outputTokenAmount: BigInt\\n  \" USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool) \"\\n  amountUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Deposit` type that implements an `Event` interface and is annotated with `@entity` and `@transaction` directives, indicating that it represents a transactional entity in a decentralized application, likely related to a decentralized exchange or automated market maker (AMM) protocol. Each field within the `Deposit` type is already accompanied by a placeholder description. The task is to enhance these descriptions to provide clear and concise documentation for each field, ensuring that the descriptions are factual and directly related to the schema's structure and purpose.\",\n    documented_schema='\"Description for table: Deposit\"\\ntype Deposit implements Event @entity @transaction {\\n  \"Unique identifier for the deposit event.\"\\n  id: ID!\\n  \"Transaction hash associated with the deposit event.\"\\n  hash: String!\\n  \"Index of the log entry within the block for the deposit event.\"\\n  logIndex: Int!\\n  \"Protocol associated with the deposit, represented by the DexAmmProtocol type.\"\\n  protocol: DexAmmProtocol!\\n  \"Address receiving the deposit.\"\\n  to: String!\\n  \"Address from which the deposit originates.\"\\n  from: String!\\n  \"Block number in which the deposit transaction was included.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of when the deposit transaction was processed.\"\\n  timestamp: BigInt!\\n  \"List of tokens deposited, represented by the Token type.\"\\n  inputTokens: [Token!]!\\n  \"Token received as output from the deposit, represented by the Token type.\"\\n  outputToken: Token\\n  \"Amounts of each input token deposited.\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Amount of the output token received from the deposit.\"\\n  outputTokenAmount: BigInt\\n  \"Total value of the deposit in USD.\"\\n  amountUSD: BigDecimal!\\n  \"Liquidity pool involved in the deposit, represented by the LiquidityPool type.\"\\n  pool: LiquidityPool!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: _MarketList\"\\ntype _MarketList @entity {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: markets\"\\n  markets: [Bytes!]!\\n}', 'documented_schema': 'type _MarketList @entity {\\n  \" Same ID as LendingProtocol \"\\n  id: Bytes!\\n  \" IDs of all markets in the LendingProtocol \"\\n  markets: [Bytes!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema defines a GraphQL entity named `_MarketList` with two fields: `id` and `markets`. The `id` field is of type `Bytes!`, indicating it is a non-nullable unique identifier for the `_MarketList` entity. The `markets` field is an array of `Bytes!`, suggesting it holds a list of non-nullable byte values, each likely representing a unique identifier for a market. The descriptions should clarify these roles without altering the schema structure.',\n    documented_schema='\"Description for table: _MarketList\"\\ntype _MarketList @entity {\\n  \"Unique identifier for the market list.\"\\n  id: Bytes!\\n  \"List of unique identifiers for markets associated with this market list.\"\\n  markets: [Bytes!]!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: EarningsClaimedEvent\"\\ntype EarningsClaimedEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: delegator\"\\n  delegator: Delegator!\\n  \"Description for column: delegate\"\\n  delegate: Transcoder!\\n  \"Description for column: startRound\"\\n  startRound: BigInt!\\n  \"Description for column: endRound\"\\n  endRound: Round!\\n  \"Description for column: rewardTokens\"\\n  rewardTokens: BigDecimal!\\n  \"Description for column: fees\"\\n  fees: BigDecimal!\\n}', 'documented_schema': '\"\"\"\\nEarningsClaimedEvent entities are created for every emitted EarningsClaimed event.\\n\"\"\"\\ntype EarningsClaimedEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  \"Reference to the delegator that claimed its earnings\"\\n  delegator: Delegator!\\n  \"Reference to the delegator\\'s delegate\"\\n  delegate: Transcoder!\\n  \"First round that the delegator\\'s pending stake was computed from\"\\n  startRound: BigInt!\\n  \"Last round that the delegator\\'s pending stake was computed from\"\\n  endRound: Round!\\n  \"Reward tokens claimed by the delegator\"\\n  rewardTokens: BigDecimal!\\n  \"Fees claimed by the delegator\"\\n  fees: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `EarningsClaimedEvent` which implements the `Event` interface. Each field within this type is already accompanied by a brief description. The task is to enhance these descriptions to provide more detailed and precise information about each field, ensuring clarity and understanding for developers and system architects. The descriptions should be factual and based on the information available in the schema.',\n    documented_schema='\"Description for table: EarningsClaimedEvent\"\\ntype EarningsClaimedEvent implements Event @entity {\\n  \"Unique identifier for the earnings claimed event.\"\\n  id: ID!\\n  \"Reference to the transaction associated with the earnings claimed event.\"\\n  transaction: Transaction!\\n  \"Unix timestamp indicating when the earnings were claimed.\"\\n  timestamp: Int!\\n  \"The round during which the earnings were claimed.\"\\n  round: Round!\\n  \"The account address of the delegator who claimed the earnings.\"\\n  delegator: Delegator!\\n  \"The account address of the delegate (transcoder) associated with the earnings claim.\"\\n  delegate: Transcoder!\\n  \"The starting round number from which the earnings were claimed.\"\\n  startRound: BigInt!\\n  \"The ending round number up to which the earnings were claimed.\"\\n  endRound: Round!\\n  \"The amount of reward tokens claimed during the event.\"\\n  rewardTokens: BigDecimal!\\n  \"The amount of fees claimed during the event.\"\\n  fees: BigDecimal!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Position\"\\ntype Position @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: account\"\\n  account: Account!\\n  \"Description for column: market\"\\n  market: Market!\\n  \"Description for column: asset\"\\n  asset: Token!\\n  \"Description for column: hashOpened\"\\n  hashOpened: Bytes!\\n  \"Description for column: hashClosed\"\\n  hashClosed: Bytes\\n  \"Description for column: blockNumberOpened\"\\n  blockNumberOpened: BigInt!\\n  \"Description for column: timestampOpened\"\\n  timestampOpened: BigInt!\\n  \"Description for column: blockNumberClosed\"\\n  blockNumberClosed: BigInt\\n  \"Description for column: timestampClosed\"\\n  timestampClosed: BigInt\\n  \"Description for column: side\"\\n  side: PositionSide!\\n  \"Description for column: type\"\\n  type: InterestRateType\\n  \"Description for column: isCollateral\"\\n  isCollateral: Boolean\\n  \"Description for column: isIsolated\"\\n  isIsolated: Boolean\\n  \"Description for column: balance\"\\n  balance: BigInt!\\n  \"Description for column: principal\"\\n  principal: BigInt\\n  \"Description for column: depositCount\"\\n  depositCount: Int!\\n  \"Description for column: deposits\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \"Description for column: withdrawCount\"\\n  withdrawCount: Int!\\n  \"Description for column: withdraws\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \"Description for column: borrowCount\"\\n  borrowCount: Int!\\n  \"Description for column: borrows\"\\n  borrows: [Borrow!]! @derivedFrom(field: \"position\")\\n  \"Description for column: repayCount\"\\n  repayCount: Int!\\n  \"Description for column: repays\"\\n  repays: [Repay!]! @derivedFrom(field: \"position\")\\n  \"Description for column: liquidationCount\"\\n  liquidationCount: Int!\\n  \"Description for column: liquidations\"\\n  liquidations: [Liquidate!]! @derivedFrom(field: \"positions\")\\n  \"Description for column: transferredCount\"\\n  transferredCount: Int!\\n  \"Description for column: receivedCount\"\\n  receivedCount: Int!\\n  \"Description for column: transfers\"\\n  transfers: [Transfer!]! @derivedFrom(field: \"positions\")\\n  \"Description for column: snapshots\"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n  \"Description for column: _eMode\"\\n  _eMode: Boolean\\n}', 'documented_schema': 'type Position @entity @regularPolling {\\n  \" { Account address }-{ Market address }-{ Position Side }-{ Optional: Interest Rate Type}-{ Counter } \"\\n  id: ID!\\n  \" Account that owns this position \"\\n  account: Account!\\n  \" The market in which this position was opened \"\\n  market: Market!\\n  \" The asset in which this position was opened with \"\\n  asset: Token!\\n  \" The hash of the transaction that opened this position \"\\n  hashOpened: Bytes!\\n  \" The hash of the transaction that closed this position \"\\n  hashClosed: Bytes\\n  \" Block number of when the position was opened \"\\n  blockNumberOpened: BigInt!\\n  \" Timestamp when the position was opened \"\\n  timestampOpened: BigInt!\\n  \" Block number of when the position was closed (0 if still open) \"\\n  blockNumberClosed: BigInt\\n  \" Timestamp when the position was closed (0 if still open) \"\\n  timestampClosed: BigInt\\n  \" Side of the position (either lender or borrower) \"\\n  side: PositionSide!\\n  \" Type of interest rate used for this position (stable or variable). Generally for borrow side positions.\"\\n  type: InterestRateType\\n  \" Whether this position has been enabled as a collateral (only applies to LENDER positions). For protocols (e.g. MakerDAO) that doesn\\'t require enabling explicitly, this will always be true. \"\\n  isCollateral: Boolean\\n  \" Whether this position is being isolated from risk from other positions (only applies to LENDER positions). For protocols (e.g. Aave V3) this reduces risk exposure from other user positions. \"\\n  isIsolated: Boolean\\n  \" Token balance in this position, in native amounts \"\\n  balance: BigInt!\\n  \" The token balance of this position without interest generated (Used to calculate interest generated on a position) \"\\n  principal: BigInt\\n  \" Number of deposits related to this position \"\\n  depositCount: Int!\\n  \" All deposit events of this position \"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \" Number of withdrawals related to this position \"\\n  withdrawCount: Int!\\n  \" All withdraw events of this position \"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \" Number of borrows related to this position \"\\n  borrowCount: Int!\\n  \" All borrow events of this position \"\\n  borrows: [Borrow!]! @derivedFrom(field: \"position\")\\n  \" Number of repays related to this position \"\\n  repayCount: Int!\\n  \" All repay events of this position \"\\n  repays: [Repay!]! @derivedFrom(field: \"position\")\\n  \" Number of liquidations related to this position (incremented when this position is liquidated) \"\\n  liquidationCount: Int!\\n  \" Liquidation event related to this position (if exists) \"\\n  liquidations: [Liquidate!]! @derivedFrom(field: \"positions\")\\n  \" Number of times this position has transferred \"\\n  transferredCount: Int!\\n  \" Number of times this position has received a transfer \"\\n  receivedCount: Int!\\n  \" All transfer events related to this position \"\\n  transfers: [Transfer!]! @derivedFrom(field: \"positions\")\\n  \" Position daily snapshots for open positions \"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n  \" efficient mode flag \"\\n  _eMode: Boolean\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Position` type with various fields, each representing a specific attribute or relationship of a financial position entity. The task is to generate clear and concise descriptions for each field based on their names and types, ensuring that the descriptions are informative and adhere to the schema's existing documentation style. The descriptions should provide insight into the purpose and nature of each field without altering the schema's structure.\",\n    documented_schema='\"Description for table: Position\"\\ntype Position @entity @regularPolling {\\n  \"Unique identifier for the position.\"\\n  id: ID!\\n  \"Account associated with the position.\"\\n  account: Account!\\n  \"Market in which the position is held.\"\\n  market: Market!\\n  \"Token representing the asset of the position.\"\\n  asset: Token!\\n  \"Hash of the transaction when the position was opened.\"\\n  hashOpened: Bytes!\\n  \"Hash of the transaction when the position was closed, if applicable.\"\\n  hashClosed: Bytes\\n  \"Block number when the position was opened.\"\\n  blockNumberOpened: BigInt!\\n  \"Timestamp when the position was opened.\"\\n  timestampOpened: BigInt!\\n  \"Block number when the position was closed, if applicable.\"\\n  blockNumberClosed: BigInt\\n  \"Timestamp when the position was closed, if applicable.\"\\n  timestampClosed: BigInt\\n  \"Side of the position, indicating whether it is long or short.\"\\n  side: PositionSide!\\n  \"Type of interest rate applied to the position.\"\\n  type: InterestRateType\\n  \"Indicates if the position is used as collateral.\"\\n  isCollateral: Boolean\\n  \"Indicates if the position is isolated.\"\\n  isIsolated: Boolean\\n  \"Current balance of the position.\"\\n  balance: BigInt!\\n  \"Principal amount of the position.\"\\n  principal: BigInt\\n  \"Number of deposits made to the position.\"\\n  depositCount: Int!\\n  \"List of deposits associated with the position.\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"position\")\\n  \"Number of withdrawals made from the position.\"\\n  withdrawCount: Int!\\n  \"List of withdrawals associated with the position.\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"position\")\\n  \"Number of borrow actions associated with the position.\"\\n  borrowCount: Int!\\n  \"List of borrows associated with the position.\"\\n  borrows: [Borrow!]! @derivedFrom(field: \"position\")\\n  \"Number of repay actions associated with the position.\"\\n  repayCount: Int!\\n  \"List of repayments associated with the position.\"\\n  repays: [Repay!]! @derivedFrom(field: \"position\")\\n  \"Number of liquidations associated with the position.\"\\n  liquidationCount: Int!\\n  \"List of liquidations associated with the position.\"\\n  liquidations: [Liquidate!]! @derivedFrom(field: \"positions\")\\n  \"Number of times the position was transferred.\"\\n  transferredCount: Int!\\n  \"Number of times the position was received.\"\\n  receivedCount: Int!\\n  \"List of transfers associated with the position.\"\\n  transfers: [Transfer!]! @derivedFrom(field: \"positions\")\\n  \"Snapshots capturing the state of the position over time.\"\\n  snapshots: [PositionSnapshot!]! @derivedFrom(field: \"position\")\\n  \"Indicates if the position is in eMode.\"\\n  _eMode: Boolean\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: days\"\\n  days: Int!\\n  \"Description for column: protocol\"\\n  protocol: LendingProtocol!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: protocolControlledValueUSD\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Description for column: mintedTokenSupplies\"\\n  mintedTokenSupplies: [BigInt!]\\n  \"Description for column: dailySupplySideRevenueUSD\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyProtocolSideRevenueUSD\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: dailyTotalRevenueUSD\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: revenueDetail\"\\n  revenueDetail: RevenueDetail\\n  \"Description for column: totalDepositBalanceUSD\"\\n  totalDepositBalanceUSD: BigDecimal!\\n  \"Description for column: dailyDepositUSD\"\\n  dailyDepositUSD: BigDecimal!\\n  \"Description for column: cumulativeDepositUSD\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Description for column: totalBorrowBalanceUSD\"\\n  totalBorrowBalanceUSD: BigDecimal!\\n  \"Description for column: dailyBorrowUSD\"\\n  dailyBorrowUSD: BigDecimal!\\n  \"Description for column: cumulativeBorrowUSD\"\\n  cumulativeBorrowUSD: BigDecimal!\\n  \"Description for column: dailyLiquidateUSD\"\\n  dailyLiquidateUSD: BigDecimal!\\n  \"Description for column: cumulativeLiquidateUSD\"\\n  cumulativeLiquidateUSD: BigDecimal!\\n  \"Description for column: dailyWithdrawUSD\"\\n  dailyWithdrawUSD: BigDecimal!\\n  \"Description for column: dailyRepayUSD\"\\n  dailyRepayUSD: BigDecimal!\\n  \"Description for column: dailyTransferUSD\"\\n  dailyTransferUSD: BigDecimal!\\n  \"Description for column: dailyFlashloanUSD\"\\n  dailyFlashloanUSD: BigDecimal!\\n}', 'documented_schema': 'type FinancialsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: Bytes!\\n  \" Number of days since Unix epoch time \"\\n  days: Int!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: LendingProtocol!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n  \" Current TVL (Total Value Locked) of the entire protocol \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. \"\\n  protocolControlledValueUSD: BigDecimal\\n  \" Total supply of minted tokens in native amounts, with same ordering as mintedTokens. Only applies to CDP \"\\n  mintedTokenSupplies: [BigInt!]\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \" Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \" Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi\u2019s 0.05%). OpenSea 10% sell fee. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \" All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Details of revenue sources and amounts \"\\n  revenueDetail: RevenueDetail\\n  \" Current balance of all deposited assets, in USD. Note this metric should be the same as TVL. \"\\n  totalDepositBalanceUSD: BigDecimal!\\n  \" Total assets deposited on a given day, in USD \"\\n  dailyDepositUSD: BigDecimal!\\n  \" Sum of all historical deposits in USD (only considers deposits and not withdrawals) \"\\n  cumulativeDepositUSD: BigDecimal!\\n  \" Current balance of all borrowed/minted assets, in USD. \"\\n  totalBorrowBalanceUSD: BigDecimal!\\n  \" Total assets borrowed/minted on a given day, in USD. \"\\n  dailyBorrowUSD: BigDecimal!\\n  \" Sum of all historical borrows/mints in USD (i.e. total loan origination). \"\\n  cumulativeBorrowUSD: BigDecimal!\\n  \" Total assets liquidated on a given day, in USD. \"\\n  dailyLiquidateUSD: BigDecimal!\\n  \" Sum of all historical liquidations in USD \"\\n  cumulativeLiquidateUSD: BigDecimal!\\n  \" Total assets withdrawn on a given day, in USD. \"\\n  dailyWithdrawUSD: BigDecimal!\\n  \" Total assets repaid on a given day, in USD. \"\\n  dailyRepayUSD: BigDecimal!\\n  \" Total assets transferred on a given day, in USD. \"\\n  dailyTransferUSD: BigDecimal!\\n  \" Total flashloans executed on a given day, in USD. \"\\n  dailyFlashloanUSD: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema represents a table named `FinancialsDailySnapshot`, which is used to capture daily financial metrics for a lending protocol. Each field in the schema is associated with a specific financial metric or identifier, and the descriptions need to be clear and precise to aid in understanding the purpose of each field. The schema includes fields for tracking various financial statistics such as total value locked, revenue, deposits, borrows, and liquidations, all measured in USD. The descriptions should reflect the nature of these metrics, ensuring that users can easily comprehend the data captured by each field.',\n    documented_schema='\"Description for table: FinancialsDailySnapshot\"\\ntype FinancialsDailySnapshot @entity @dailySnapshot {\\n  \"Unique identifier for the financial snapshot.\"\\n  id: Bytes!\\n  \"Number of days since the protocol\\'s inception.\"\\n  days: Int!\\n  \"Reference to the lending protocol associated with this snapshot.\"\\n  protocol: LendingProtocol!\\n  \"Block number at which the snapshot was taken.\"\\n  blockNumber: BigInt!\\n  \"Timestamp indicating when the snapshot was recorded.\"\\n  timestamp: BigInt!\\n  \"Total value locked in the protocol, measured in USD.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Value controlled by the protocol, measured in USD.\"\\n  protocolControlledValueUSD: BigDecimal\\n  \"Supplies of minted tokens at the time of the snapshot.\"\\n  mintedTokenSupplies: [BigInt!]\\n  \"Revenue generated by the supply side on a daily basis, measured in USD.\"\\n  dailySupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue generated by the supply side, measured in USD.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Revenue generated by the protocol side on a daily basis, measured in USD.\"\\n  dailyProtocolSideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue generated by the protocol side, measured in USD.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Total revenue generated on a daily basis, measured in USD.\"\\n  dailyTotalRevenueUSD: BigDecimal!\\n  \"Cumulative total revenue generated, measured in USD.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Detailed breakdown of revenue components.\"\\n  revenueDetail: RevenueDetail\\n  \"Total balance of deposits, measured in USD.\"\\n  totalDepositBalanceUSD: BigDecimal!\\n  \"Total deposits made on a daily basis, measured in USD.\"\\n  dailyDepositUSD: BigDecimal!\\n  \"Cumulative total of deposits, measured in USD.\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Total balance of borrowed funds, measured in USD.\"\\n  totalBorrowBalanceUSD: BigDecimal!\\n  \"Total amount borrowed on a daily basis, measured in USD.\"\\n  dailyBorrowUSD: BigDecimal!\\n  \"Cumulative total of borrowed funds, measured in USD.\"\\n  cumulativeBorrowUSD: BigDecimal!\\n  \"Total value of liquidations on a daily basis, measured in USD.\"\\n  dailyLiquidateUSD: BigDecimal!\\n  \"Cumulative total value of liquidations, measured in USD.\"\\n  cumulativeLiquidateUSD: BigDecimal!\\n  \"Total value of withdrawals on a daily basis, measured in USD.\"\\n  dailyWithdrawUSD: BigDecimal!\\n  \"Total value of repayments on a daily basis, measured in USD.\"\\n  dailyRepayUSD: BigDecimal!\\n  \"Total value of transfers on a daily basis, measured in USD.\"\\n  dailyTransferUSD: BigDecimal!\\n  \"Total value of flashloans on a daily basis, measured in USD.\"\\n  dailyFlashloanUSD: BigDecimal!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: type\"\\n  type: String!\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: token\"\\n  token: Token\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: currentOwner\"\\n  currentOwner: Collector!\\n  \"Description for column: bidder\"\\n  bidder: Collector!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: weiValue\"\\n  weiValue: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: lockedUntil\"\\n  lockedUntil: BigInt\\n  \"Description for column: isActive\"\\n  isActive: Boolean!\\n}', 'documented_schema': '\" A table of offers either on editions or tokens. \"\\ntype Offer @entity {\\n  \" The unique identifier for the offer. \"\\n  id: ID!\\n  \" The version of the offer (KODA 2 or 3). \"\\n  version: BigInt!\\n  \" The type of the offer (Token or Edition). \"\\n  type: String!\\n  \" The sales type of the offer (The current sales mechnic being used on this offer). \"\\n  salesType: BigInt!\\n  \" The token of the offer (nullable token, as editions dont have tokens attached). \"\\n  token: Token\\n  \" The edition of the offer (All offers must be from an edition). \"\\n  edition: Edition!\\n  \" The current owner of the offer (This is either the token holder or the edition artist). \"\\n  currentOwner: Collector!\\n  \" The bidder of the offer. \"\\n  bidder: Collector!\\n  \" The eth value of the offer. \"\\n  ethValue: BigDecimal!\\n  \" The wei value of the offer. \"\\n  weiValue: BigInt!\\n  \" The timestamp of the offer. \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the offer. \"\\n  transactionHash: Bytes!\\n  \" The locked until timestamp of the offer (for V3 offers, they will be locked for a certain amount of time). \"\\n  lockedUntil: BigInt\\n  \" If the offer is active. \"\\n  isActive: Boolean!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines an `Offer` entity with various fields, each representing a specific attribute of an offer in a database. The task is to generate clear and concise descriptions for each field based on their names and types, ensuring that the descriptions are factual and informative. The descriptions should help users understand the purpose and data type of each field without altering the schema structure.',\n    documented_schema='\"Description for table: Offer\"\\ntype Offer @entity {\\n  \"Unique identifier for the offer.\"\\n  id: ID!\\n  \"Version number of the offer, used for tracking changes.\"\\n  version: BigInt!\\n  \"Type of the offer, represented as a string.\"\\n  type: String!\\n  \"Sales type identifier, represented as a big integer.\"\\n  salesType: BigInt!\\n  \"Associated token for the offer, if applicable.\"\\n  token: Token\\n  \"Edition associated with the offer, must be specified.\"\\n  edition: Edition!\\n  \"Current owner of the offer, represented by a collector entity.\"\\n  currentOwner: Collector!\\n  \"Bidder involved in the offer, represented by a collector entity.\"\\n  bidder: Collector!\\n  \"Value of the offer in Ethereum, represented as a decimal.\"\\n  ethValue: BigDecimal!\\n  \"Value of the offer in Wei, represented as a big integer.\"\\n  weiValue: BigInt!\\n  \"Timestamp indicating when the offer was created or last updated.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction associated with the offer.\"\\n  transactionHash: Bytes!\\n  \"Timestamp until which the offer is locked, if applicable.\"\\n  lockedUntil: BigInt\\n  \"Indicates whether the offer is currently active.\"\\n  isActive: Boolean!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: TransferBondEvent\"\\ntype TransferBondEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: amount\"\\n  amount: BigDecimal!\\n  \"Description for column: newDelegator\"\\n  newDelegator: Delegator!\\n  \"Description for column: oldDelegator\"\\n  oldDelegator: Delegator!\\n  \"Description for column: newUnbondingLockId\"\\n  newUnbondingLockId: Int!\\n  \"Description for column: oldUnbondingLockId\"\\n  oldUnbondingLockId: Int!\\n}', 'documented_schema': '\"\"\"\\nTransferBond entities are created for every emitted TransferBond event.\\n\"\"\"\\ntype TransferBondEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  amount: BigDecimal!\\n  newDelegator: Delegator!\\n  oldDelegator: Delegator!\\n  newUnbondingLockId: Int!\\n  oldUnbondingLockId: Int!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `TransferBondEvent` which implements the `Event` interface. Each field within this type is associated with a specific data type and has a brief description. The task is to expand these descriptions to provide more detailed and informative documentation for each field, ensuring clarity and understanding for developers who interact with this schema. The descriptions should be factual and based solely on the information provided in the schema.',\n    documented_schema='\"Description for table: TransferBondEvent\"\\ntype TransferBondEvent implements Event @entity {\\n  \"Unique identifier for the transfer bond event.\"\\n  id: ID!\\n  \"Reference to the transaction associated with this transfer bond event.\"\\n  transaction: Transaction!\\n  \"Unix timestamp indicating when the transfer bond event occurred.\"\\n  timestamp: Int!\\n  \"Reference to the round during which the transfer bond event took place.\"\\n  round: Round!\\n  \"Amount of the bond being transferred, represented as a BigDecimal.\"\\n  amount: BigDecimal!\\n  \"Delegator who is receiving the bond in this transfer.\"\\n  newDelegator: Delegator!\\n  \"Delegator who is transferring the bond away.\"\\n  oldDelegator: Delegator!\\n  \"Identifier for the new unbonding lock associated with the new delegator.\"\\n  newUnbondingLockId: Int!\\n  \"Identifier for the old unbonding lock associated with the old delegator.\"\\n  oldUnbondingLockId: Int!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: LiquidityPoolFee\"\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: feePercentage\"\\n  feePercentage: BigDecimal\\n  \"Description for column: feeType\"\\n  feeType: LiquidityPoolFeeType!\\n}', 'documented_schema': 'type LiquidityPoolFee @entity @regularPolling {\\n  \" { Fee type }-{ Pool address } \"\\n  id: ID!\\n  \" Fee as a percentage of the trade (swap) amount. Does not always apply \"\\n  feePercentage: BigDecimal\\n  \" Type of fee this pool uses \"\\n  feeType: LiquidityPoolFeeType!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema defines a GraphQL type `LiquidityPoolFee` which represents a fee structure within a liquidity pool. Each field within this type has a specific role: `id` serves as a unique identifier, `feePercentage` indicates the percentage of the fee, and `feeType` specifies the type of fee using an enum `LiquidityPoolFeeType`. The task is to document these fields clearly and concisely without altering the schema structure.',\n    documented_schema='\"Description for table: LiquidityPoolFee\"\\ntype LiquidityPoolFee @entity @regularPolling {\\n  \"Unique identifier for the liquidity pool fee.\"\\n  id: ID!\\n  \"The percentage value of the fee applied in the liquidity pool.\"\\n  feePercentage: BigDecimal\\n  \"The type of fee applied, represented by the LiquidityPoolFeeType enum.\"\\n  feeType: LiquidityPoolFeeType!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: DelegatedStake\"\\ntype DelegatedStake @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: indexer\"\\n  indexer: Indexer!\\n  \"Description for column: delegator\"\\n  delegator: Delegator!\\n  \"Description for column: stakedTokens\"\\n  stakedTokens: BigInt!\\n  \"Description for column: unstakedTokens\"\\n  unstakedTokens: BigInt!\\n  \"Description for column: lockedTokens\"\\n  lockedTokens: BigInt!\\n  \"Description for column: lockedUntil\"\\n  lockedUntil: Int!\\n  \"Description for column: shareAmount\"\\n  shareAmount: BigInt!\\n  \"Description for column: personalExchangeRate\"\\n  personalExchangeRate: BigDecimal!\\n  \"Description for column: realizedRewards\"\\n  realizedRewards: BigDecimal!\\n  \"Description for column: createdAt\"\\n  createdAt: Int!\\n  \"Description for column: lastDelegatedAt\"\\n  lastDelegatedAt: Int\\n  \"Description for column: lastUndelegatedAt\"\\n  lastUndelegatedAt: Int\\n  \"Description for column: transferredToL2\"\\n  transferredToL2: Boolean!\\n  \"Description for column: transferredToL2At\"\\n  transferredToL2At: BigInt\\n  \"Description for column: transferredToL2AtBlockNumber\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Description for column: transferredToL2AtTx\"\\n  transferredToL2AtTx: String\\n  \"Description for column: stakedTokensTransferredToL2\"\\n  stakedTokensTransferredToL2: BigInt!\\n  \"Description for column: idOnL2\"\\n  idOnL2: String\\n  \"Description for column: idOnL1\"\\n  idOnL1: String\\n}', 'documented_schema': '\"\"\"Delegator stake for a single Indexer\"\"\"\\ntype DelegatedStake @entity {\\n  \"Concatenation of Delegator address and Indexer address\"\\n  id: ID!\\n  \"Index the stake is delegated to\"\\n  indexer: Indexer!\\n  \"Delegator\"\\n  delegator: Delegator!\\n  \"CUMULATIVE tokens delegated\"\\n  stakedTokens: BigInt!\\n  \"CUMULATIVE tokens undelegated\"\\n  unstakedTokens: BigInt!\\n  \"CURRENT tokens locked\"\\n  lockedTokens: BigInt!\\n  \"Epoch the locked tokens get unlocked\"\\n  lockedUntil: Int!\\n  \"Shares owned in the delegator pool. Used to calculate total amount delegated\"\\n  shareAmount: BigInt!\\n  \"The rate this delegator paid for their shares (calculated using average cost basis). Used for rewards calculations\"\\n  personalExchangeRate: BigDecimal!\\n  \"Realized rewards from undelegating and realizing a reward\"\\n  realizedRewards: BigDecimal!\\n  \"Time this delegator first delegated to an indexer\"\\n  createdAt: Int!\\n  \"Last time this delegator delegated towards this indexer\"\\n  lastDelegatedAt: Int\\n  \"Last time this delegator undelegated from this indexer\"\\n  lastUndelegatedAt: Int\\n  \"Whether the delegation has been transferred from L1 to L2\"\\n  transferredToL2: Boolean!\\n  \"Timestamp for the L1 -> L2 Transfer\"\\n  transferredToL2At: BigInt\\n  \"Block number for the L1 -> L2 Transfer\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Transaction hash for the L1 -> L2 Transfer\"\\n  transferredToL2AtTx: String\\n  \"Amount of GRT transferred to L2. Only visible from L1, as there\\'s no events for it on L2\"\\n  stakedTokensTransferredToL2: BigInt!\\n  \"ID of the delegation on L2. Null if it\\'s not transferred\"\\n  idOnL2: String\\n  \"ID of the delegation on L1. Null if it\\'s not transferred\"\\n  idOnL1: String\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `DelegatedStake`, which represents a record of delegated stakes in a blockchain context. Each field within this entity has a specific role, and the descriptions should reflect their purpose and data type accurately. The fields include identifiers, relationships to other entities, and various metrics related to staking, such as token amounts and timestamps. The documentation should clarify these roles without altering the schema structure, ensuring that developers can understand the data model effectively.',\n    documented_schema='\"Description for table: DelegatedStake\"\\ntype DelegatedStake @entity {\\n  \"Unique identifier for the delegated stake record.\"\\n  id: ID!\\n  \"Reference to the indexer associated with this delegated stake.\"\\n  indexer: Indexer!\\n  \"Reference to the delegator who has delegated the stake.\"\\n  delegator: Delegator!\\n  \"Total number of tokens currently staked by the delegator.\"\\n  stakedTokens: BigInt!\\n  \"Total number of tokens that have been unstaked by the delegator.\"\\n  unstakedTokens: BigInt!\\n  \"Number of tokens that are currently locked and cannot be withdrawn.\"\\n  lockedTokens: BigInt!\\n  \"Timestamp indicating until when the tokens are locked.\"\\n  lockedUntil: Int!\\n  \"Amount of shares representing the delegator\\'s stake.\"\\n  shareAmount: BigInt!\\n  \"Exchange rate specific to the delegator\\'s stake, used for calculating rewards.\"\\n  personalExchangeRate: BigDecimal!\\n  \"Total rewards realized by the delegator from staking.\"\\n  realizedRewards: BigDecimal!\\n  \"Timestamp when the delegated stake was created.\"\\n  createdAt: Int!\\n  \"Timestamp of the last delegation action performed by the delegator.\"\\n  lastDelegatedAt: Int\\n  \"Timestamp of the last undelegation action performed by the delegator.\"\\n  lastUndelegatedAt: Int\\n  \"Indicates whether the stake has been transferred to Layer 2.\"\\n  transferredToL2: Boolean!\\n  \"Timestamp when the stake was transferred to Layer 2.\"\\n  transferredToL2At: BigInt\\n  \"Block number at which the stake was transferred to Layer 2.\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Transaction identifier for the transfer to Layer 2.\"\\n  transferredToL2AtTx: String\\n  \"Number of staked tokens transferred to Layer 2.\"\\n  stakedTokensTransferredToL2: BigInt!\\n  \"Identifier for the stake on Layer 2.\"\\n  idOnL2: String\\n  \"Identifier for the stake on Layer 1.\"\\n  idOnL1: String\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for enum type: Network\"\\nenum Network {\\n  \"Description for column: ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"Description for column: ARWEAVE_MAINNET\"\\n  ARWEAVE_MAINNET\\n  \"Description for column: AURORA\"\\n  AURORA\\n  \"Description for column: AVALANCHE\"\\n  AVALANCHE\\n  \"Description for column: BOBA\"\\n  BOBA\\n  \"Description for column: BSC\"\\n  BSC\\n  \"Description for column: CELO\"\\n  CELO\\n  \"Description for column: COSMOS\"\\n  COSMOS\\n  \"Description for column: CRONOS\"\\n  CRONOS\\n  \"Description for column: MAINNET\"\\n  MAINNET\\n  \"Description for column: FANTOM\"\\n  FANTOM\\n  \"Description for column: FUSE\"\\n  FUSE\\n  \"Description for column: HARMONY\"\\n  HARMONY\\n  \"Description for column: JUNO\"\\n  JUNO\\n  \"Description for column: MOONBEAM\"\\n  MOONBEAM\\n  \"Description for column: MOONRIVER\"\\n  MOONRIVER\\n  \"Description for column: NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"Description for column: OPTIMISM\"\\n  OPTIMISM\\n  \"Description for column: OSMOSIS\"\\n  OSMOSIS\\n  \"Description for column: MATIC\"\\n  MATIC\\n  \"Description for column: XDAI\"\\n  XDAI\\n}\\n\\n\"Description for enum type: NftStandard\"\\nenum NftStandard {\\n  \"Description for column: ERC721\"\\n  ERC721\\n  \"Description for column: ERC1155\"\\n  ERC1155\\n  \"Description for column: UNKNOWN\"\\n  UNKNOWN\\n}\\n\\n\"Description for enum type: SaleStrategy\"\\nenum SaleStrategy {\\n  \"Description for column: STANDARD_SALE\"\\n  STANDARD_SALE\\n  \"Description for column: ANY_ITEM_FROM_COLLECTION\"\\n  ANY_ITEM_FROM_COLLECTION\\n  \"Description for column: ANY_ITEM_FROM_SET\"\\n  ANY_ITEM_FROM_SET\\n  \"Description for column: DUTCH_AUCTION\"\\n  DUTCH_AUCTION\\n  \"Description for column: PRIVATE_SALE\"\\n  PRIVATE_SALE\\n}\\n\\n\"Description for table: Marketplace\"\\ntype Marketplace @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: slug\"\\n  slug: String!\\n  \"Description for column: network\"\\n  network: Network!\\n  \"Description for column: schemaVersion\"\\n  schemaVersion: String!\\n  \"Description for column: subgraphVersion\"\\n  subgraphVersion: String!\\n  \"Description for column: methodologyVersion\"\\n  methodologyVersion: String!\\n  \"Description for column: collectionCount\"\\n  collectionCount: Int!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: cumulativeUniqueTraders\"\\n  cumulativeUniqueTraders: Int!\\n}\\n\\n\"Description for table: Collection\"\\ntype Collection @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt\\n  \"Description for column: nftStandard\"\\n  nftStandard: NftStandard!\\n  \"Description for column: royaltyFee\"\\n  royaltyFee: BigDecimal!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: buyerCount\"\\n  buyerCount: Int!\\n  \"Description for column: sellerCount\"\\n  sellerCount: Int!\\n  \"Description for column: trades\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}\\n\\n\"Description for table: Trade\"\\ntype Trade @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transactionHash\"\\n  transactionHash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: isBundle\"\\n  isBundle: Boolean!\\n  \"Description for column: collection\"\\n  collection: Collection!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: priceETH\"\\n  priceETH: BigDecimal!\\n  \"Description for column: strategy\"\\n  strategy: SaleStrategy!\\n  \"Description for column: buyer\"\\n  buyer: String!\\n  \"Description for column: seller\"\\n  seller: String!\\n}\\n\\n\"Description for table: MarketplaceDailySnapshot\"\\ntype MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: marketplace\"\\n  marketplace: Marketplace!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: collectionCount\"\\n  collectionCount: Int!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: cumulativeUniqueTraders\"\\n  cumulativeUniqueTraders: Int!\\n  \"Description for column: dailyActiveTraders\"\\n  dailyActiveTraders: Int!\\n  \"Description for column: dailyTradedCollectionCount\"\\n  dailyTradedCollectionCount: Int!\\n  \"Description for column: dailyTradedItemCount\"\\n  dailyTradedItemCount: Int!\\n}\\n\\n\"Description for table: CollectionDailySnapshot\"\\ntype CollectionDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: collection\"\\n  collection: Collection!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: royaltyFee\"\\n  royaltyFee: BigDecimal!\\n  \"Description for column: dailyMinSalePrice\"\\n  dailyMinSalePrice: BigDecimal!\\n  \"Description for column: dailyMaxSalePrice\"\\n  dailyMaxSalePrice: BigDecimal!\\n  \"Description for column: cumulativeTradeVolumeETH\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Description for column: dailyTradeVolumeETH\"\\n  dailyTradeVolumeETH: BigDecimal!\\n  \"Description for column: marketplaceRevenueETH\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Description for column: creatorRevenueETH\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Description for column: totalRevenueETH\"\\n  totalRevenueETH: BigDecimal!\\n  \"Description for column: tradeCount\"\\n  tradeCount: Int!\\n  \"Description for column: dailyTradedItemCount\"\\n  dailyTradedItemCount: Int!\\n}\\n\\n\"Description for table: _Item\"\\ntype _Item @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n}', 'documented_schema': '\" Represents the blockchain network that the data is being collected from. \"\\nenum Network {\\n  \" The Arbitrum One network. \"\\n  ARBITRUM_ONE\\n  \" The Arweave Mainnet. \"\\n  ARWEAVE_MAINNET\\n  \" The Aurora network. \"\\n  AURORA\\n  \" The Avalanche network. \"\\n  AVALANCHE\\n  \" The Boba network. \"\\n  BOBA\\n  \" The Binance Smart Chain network (aka BNB Chain). \"\\n  BSC\\n  \" The Celo network. \"\\n  CELO\\n  \" The Cosmos network. \"\\n  COSMOS\\n  \" The Cronos network. \"\\n  CRONOS\\n  \" The Ethereum Mainnet. \"\\n  MAINNET\\n  \" The Fantom network. \"\\n  FANTOM\\n  \" The Fuse network. \"\\n  FUSE\\n  \" The Harmony network. \"\\n  HARMONY\\n  \" The Juno network. \"\\n  JUNO\\n  \" The Moonbeam network. \"\\n  MOONBEAM\\n  \" The Moonriver network. \"\\n  MOONRIVER\\n  \" The NEAR Mainnet. \"\\n  NEAR_MAINNET\\n  \" The Optimism network. \"\\n  OPTIMISM\\n  \" The Osmosis network. \"\\n  OSMOSIS\\n  \" The Matic network (aka Polygon). \"\\n  MATIC\\n  \" The xDai network (aka Gnosis Chain). \"\\n  XDAI\\n}\\n\\n\" The NFT standard that the collection uses. This is a defined standard that the Ethereum blockchain uses to create NFTs. \"\\nenum NftStandard {\\n  \" The ERC721 NFT standard. \"\\n  ERC721\\n  \" The ERC1155 NFT standard. \"\\n  ERC1155\\n  \" An unknown NFT standard. \"\\n  UNKNOWN\\n}\\n\\n\" Represents a sales strategy that executes an order. There are five types of sale strategies: Standard Sale, Any Item from Collection, Any Item from Set, Dutch Auction, and Private Sale. \"\\nenum SaleStrategy {\\n  \" Represents a sales strategy that executes an order at a fixed price that can be taken either by a bid or an ask. \"\\n  STANDARD_SALE\\n  \" Represents a sales strategy that executes an order at a fixed price that can be matched by any tokenId for the collection. \"\\n  ANY_ITEM_FROM_COLLECTION\\n  \" Represents a sales strategy that executes an order at a fixed price that can be matched by any tokenId in a set of tokenIds. \"\\n  ANY_ITEM_FROM_SET\\n  \" Represents a trategy to launch a Dutch Auction for a token where the price decreases linearly until a specified timestamp and end price defined by the seller. \"\\n  DUTCH_AUCTION\\n  \" Represents a strategy to set up an order that can only be executed by a specific address (aka a Private Sale). \"\\n  PRIVATE_SALE\\n}\\n\\n\" A marketplace is a platform where NFTs are traded. This is a unique entity that maps to marketplaces (smart contracts) on the blockchain. \"\\ntype Marketplace @entity @regularPolling {\\n  \" Smart contract address of the protocol\\'s main contract (Factory, Registry, etc) \"\\n  id: ID!\\n  \" Human readable name of the NFT marketplace, in this case OpenSea. \"\\n  name: String!\\n  \" The human readable trading slug of the NFT marketplace, in this case opensea. \"\\n  slug: String!\\n  \" The blockchain network this subgraph is indexing on. This corresponds to the network that data is being collected from. Options are presented in the Enum above. \"\\n  network: Network!\\n  \" This is the version of the schema, in SemVer format (e.g. 1.0.0), that the subgraph is implementing. This is because this schema is built from a common standard that is maintained by Messari. \"\\n  schemaVersion: String!\\n  \" This is the version of the subgraph implementation, in SemVer format (e.g. 1.0.0), that the subgraph is implementing. This is independent of schema, and pertains to how various actions update relevant fields. This is because this schema is built from a common standard that is maintained by Messari. \"\\n  subgraphVersion: String!\\n  \" This is the version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0). This is because the methodology used to compute metrics may change over time, and this field is used to track those changes. \"\\n  methodologyVersion: String!\\n  \" This is a field that is updated to reflect the number of collections listed on the marketplace. A collection is a group of NFTs that are created by the same creator. \"\\n  collectionCount: Int!\\n  \" This is a field that is updated to reflect the number of trades that have occurred on the marketplace, and is inclusive of all collections. \"\\n  tradeCount: Int!\\n  \" This is a field that is updated to reflect the cumulative trade volume in ETH that has occurred on the marketplace. Includes all trades from all collections. \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The revenue (in ETH) that goes to the marketplace protocol, aka protocol fee. This is the fee that is taken by the marketplace protocol for facilitating trades. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" This is the cumulative fees (in ETH) that have been taken by the creators of NFTs on the markeplace when they are traded. This is akin to a royalty fee. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" This is the total revenue that has been generated by the marketplace. This is calculated by adding the marketplace revenue and the creator revenue. \"\\n  totalRevenueETH: BigDecimal!\\n  \" This is a field that is updated to reflect the number of unique traders that have participated in trades on the marketplace. \"\\n  cumulativeUniqueTraders: Int!\\n}\\n\\n\" A collection is a group of NFTs that are created by the same creator. This is a unique entity that maps to collections on the marketplace. \"\\ntype Collection @entity @regularPolling {\\n  \" This is the unique identifier for the collection, and is the contract address of the collection. \"\\n  id: ID!\\n  \" This is the name of the collection, and is the name that is given to the collection by the creator. It is mirrored from the smart contract, and left null if not available. \"\\n  name: String\\n  \" This is the symbol of the collection, and is the symbol that is given to the collection by the creator. It is mirrored from the smart contract, and left null if not available. \"\\n  symbol: String\\n  \" This is the total supply of the collection (number of NFTs within a given collection), and is mirrored from the smart contract. \"\\n  totalSupply: BigInt\\n  \" This is the NFT standard that the collection uses. This can be either ERC721, ERC1155, or Unknown. It must be one of the values present within the NftStandard Enum. \"\\n  nftStandard: NftStandard!\\n  \" This is the fee that is taken by the creator of the NFT when it is traded. It is akin to a royalty fee. It is a fee rte in percentage. E.g. 2.5% should be 2.5. \"\\n  royaltyFee: BigDecimal!\\n  \" The cumulative trade volume in ETH that has occurred for the collection. This is the total value of all trades that have occurred for the collection (in ETH). \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The revenue that is collected by the marketplace protocol for facilitating trades of the collection (in ETH). This is akin to a protocol fee. It is represented in ETH. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" The revenue that is collected by the creator of the NFT when it is traded (in ETH). This is akin to a royalty fee. It is represented in ETH. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" The total revenue that has been generated by the collection (in ETH). This is calculated by adding the marketplace revenue and the creator revenue. It is represented in ETH. \"\\n  totalRevenueETH: BigDecimal!\\n  \" This is the number of trades that have occurred for the collection on the marketplace. Each trade is a unique transaction. \"\\n  tradeCount: Int!\\n  \" The total number of unique buyers that have participated in trades for the collection. \"\\n  buyerCount: Int!\\n  \" The total number of unique sellers that have participated in trades for the collection. \"\\n  sellerCount: Int!\\n  \" This maps to the Trade entity, and is a list of trades that have occurred for the collection. \"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}\\n\\n\" Trades exist such as a combination of taker/order and bid/ask. \"\\ntype Trade @entity @transaction {\\n  \" The id for a trade is combination of the following components: { Transaction hash }-{ Log index }-{ (optional) ID within bundle } \"\\n  id: ID!\\n  \" The transaction has that the trade is executed in. This is a unique identifier for the transaction. It is possible that multiple trades are executed in a single transaction. \"\\n  transactionHash: String!\\n  \" This represents the index of the log within the transaction. It is a unique identifier for the log within the transaction. The event corresponds to a trade event. \"\\n  logIndex: Int\\n  \" Block timestamp where the trade is executed. This is based on the timestamp of the block where the trade is executed. \"\\n  timestamp: BigInt!\\n  \" Block number where the trade is executed. A block is a collection of transactions that are executed on the blockchain. \"\\n  blockNumber: BigInt!\\n  \" Whether the trade is in a bundle. Trades can be in a bundle, which means that multiple NFTs are traded together. \"\\n  isBundle: Boolean!\\n  \" Collection involved. This is the collection that the trade, and corresponding NFT, is associated with. \"\\n  collection: Collection!\\n  \" The token ID is the unique identifier for the NFT that is traded. It is unique within the collection. \"\\n  tokenId: BigInt!\\n  \" The amount of token to transfer. It is set at 1 except for ERC1155 batch. \"\\n  amount: BigInt!\\n  \" Price (in ETH). If only 1 tokenId is involved, then the price is determined by the token only. If the trade is incurred by a batch purchasing (available in x2y2), then the price is the average price in the batch. \"\\n  priceETH: BigDecimal!\\n  \" The strategy that the trade is executed with. This is a sale strategy that is used to execute the trade. It is defined by the SaleStrategy Enum. \"\\n  strategy: SaleStrategy!\\n  \" The buyer account address is the address of the account that is purchasing the NFT(s). \"\\n  buyer: String!\\n  \" The seller account address is the address of the account that is selling the NFT(s). \"\\n  seller: String!\\n}\\n\\n\" A daily snapshot of the marketplace. This entity tracks the daily metrics of the marketplace. \"\\ntype MarketplaceDailySnapshot @entity @dailySnapshot {\\n  \" The id for a daily snapshot of the marketplace is a combination of the contract address and the number of days since the Unix epoch time: { Contract address }-{# of days since Unix epoch time } \"\\n  id: ID!\\n  \" This maps to the Marketplace entity that the snapshot is of. \"\\n  marketplace: Marketplace!\\n  \" This is the block number when the snapshot was taken. It is a unique identifier for the block based on the network the marketplace is on. \"\\n  blockNumber: BigInt!\\n  \" This is the timestamp of the block when the snapshot was taken. The timestamp is a Unix timestamp. \"\\n  timestamp: BigInt!\\n  \" A cumulative count of all collections listed on the marketplace. This is a value determined at the time of the snapshot. \"\\n  collectionCount: Int!\\n  \" The total trading volume in ETH that has occurred on the marketplace during the day of the snapshot. This is the total value of all trades that have occurred on the marketplace in the given day. \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The total revenue generated by the marketplace protocol during the day of the snapshot. This is the fee that is taken by the marketplace protocol for facilitating trades. This is akin to a protocol fee. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" The total creator revenue collected on the marketplace during the day of the snapshot. This is the fee that is taken by the creators of NFTs on the markeplace when they are traded. This is akin to a royalty fee. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" The total revenue that has been generated by the marketplace during the day of the snapshot. This is calculated by adding the marketplace revenue and the creator revenue. \"\\n  totalRevenueETH: BigDecimal!\\n  \" The total number of trades that have occurred on the marketplace during the day of the snapshot. \"\\n  tradeCount: Int!\\n  \" The number of unique traders that have participated in trades on the marketplace for the given day. This is a cumulative count of all unique traders that have participated in trades on the marketplace on that day. \"\\n  cumulativeUniqueTraders: Int!\\n  \" The number of unique traders that have participated in trades on the marketplace for the given day. This is a count of all unique traders that have participated in trades on the marketplace on that day. \"\\n  dailyActiveTraders: Int!\\n  \" The number of collections that have been traded on the marketplace during the day of the snapshot. This is a cumulative value of the distinct collections that have been traded on the marketplace on that day. \"\\n  dailyTradedCollectionCount: Int!\\n  \" The number of traded items that have been traded on the marketplace during the day of the snapshot. This is a count of all NFTs that have been traded on the marketplace on that day. \"\\n  dailyTradedItemCount: Int!\\n}\\n\\n\" A daily snapshot of a collection. This entity tracks the daily metrics of a collection. \"\\ntype CollectionDailySnapshot @entity @dailySnapshot {\\n  \" The id for a daily snapshot of a collection is a combination of the contract address and the number of days since the Unix epoch time: { Contract address }-{# of days since epoch unix time } \"\\n  id: ID!\\n  \" This maps to the Collection entity that the snapshot is of. The collection is a group of NFTs that are created by the same creator. \"\\n  collection: Collection!\\n  \" Block number when the snapshot was taken. It is a unique identifier for the block based on the network the collection is on. \"\\n  blockNumber: BigInt!\\n  \" The block timestamp of the block when the snapshot was taken. The timestamp is a Unix timestamp. \"\\n  timestamp: BigInt!\\n  \" The royalty fee is the fee that is taken by the creator of the NFT when it is traded. It is akin to a royalty fee. It is a fee rate in percentage. E.g. 2.5% should be 2.5. \"\\n  royaltyFee: BigDecimal!\\n  \" The minimum sale price of the day (in ETH) is the lowest price that an NFT from the collection has been sold for on the marketplace during the day of the snapshot. \"\\n  dailyMinSalePrice: BigDecimal!\\n  \" The maximum sale price of the day (in ETH) is the highest price that an NFT from the collection has been sold for on the marketplace during the day of the snapshot. \"\\n  dailyMaxSalePrice: BigDecimal!\\n  \" The cumulative trade volume in ETH that has occurred for the collection in the given day. This is the total value of all trades that have occurred for the collection (in ETH) for that day. \"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \" The total trading volume in ETH that has occurred for the collection during the day of the snapshot. This is the total value of all trades that have occurred for the collection in the given day. \"\\n  dailyTradeVolumeETH: BigDecimal!\\n  \" The revenue that is collected by the marketplace protocol for facilitating trades of the collection (in ETH) for the given day. This is akin to the total protocol fee collected for a day. \"\\n  marketplaceRevenueETH: BigDecimal!\\n  \" The revenue that is collected by the creator of the NFT when it is traded (in ETH) for the given day. This is akin to the total royalty fee collected for a day. \"\\n  creatorRevenueETH: BigDecimal!\\n  \" This is the total revenue that has been generated by the collection for the given day. This is calculated by adding the marketplace revenue and the creator revenue. \"\\n  totalRevenueETH: BigDecimal!\\n  \" The total number of trades that have occurred for the collection on the marketplace on a given day. Each trade is a unique transaction. \"\\n  tradeCount: Int!\\n  \" The total number of unique NFTs that have been traded from the collection on the marketplace on a given day. \"\\n  dailyTradedItemCount: Int!\\n}\\n\\n\" A helper utility entity that works as a set for deduplication purpose. \"\\ntype _Item @entity {\\n  \" The unique identifier for the item. This is a combination of the type of item and the account address. MARKETPLACE_ACCOUNT-{ Account } or COLLECTION_ACCOUNT-{ Buyer/Seller }-{ Collection ID }-{ Account } depending on the type of item. \"\\n  id: ID!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema includes several enum types and entity types, each with fields that require documentation. The enum types represent various categories such as networks, NFT standards, and sale strategies, while the entity types represent different aspects of a marketplace, collections, trades, and snapshots. The task is to provide clear and concise descriptions for each field based on the information given in the schema. The descriptions should be factual and straightforward, avoiding any speculative language. The documentation should maintain the existing schema structure without altering it.',\n    documented_schema='\"Enum representing various blockchain networks.\"\\nenum Network {\\n  \"Arbitrum One network.\"\\n  ARBITRUM_ONE\\n  \"Arweave Mainnet network.\"\\n  ARWEAVE_MAINNET\\n  \"Aurora network.\"\\n  AURORA\\n  \"Avalanche network.\"\\n  AVALANCHE\\n  \"Boba network.\"\\n  BOBA\\n  \"Binance Smart Chain network.\"\\n  BSC\\n  \"Celo network.\"\\n  CELO\\n  \"Cosmos network.\"\\n  COSMOS\\n  \"Cronos network.\"\\n  CRONOS\\n  \"Ethereum Mainnet network.\"\\n  MAINNET\\n  \"Fantom network.\"\\n  FANTOM\\n  \"Fuse network.\"\\n  FUSE\\n  \"Harmony network.\"\\n  HARMONY\\n  \"Juno network.\"\\n  JUNO\\n  \"Moonbeam network.\"\\n  MOONBEAM\\n  \"Moonriver network.\"\\n  MOONRIVER\\n  \"Near Mainnet network.\"\\n  NEAR_MAINNET\\n  \"Optimism network.\"\\n  OPTIMISM\\n  \"Osmosis network.\"\\n  OSMOSIS\\n  \"Polygon (Matic) network.\"\\n  MATIC\\n  \"xDai network.\"\\n  XDAI\\n}\\n\\n\"Enum representing NFT standards.\"\\nenum NftStandard {\\n  \"ERC721 standard for NFTs.\"\\n  ERC721\\n  \"ERC1155 standard for NFTs.\"\\n  ERC1155\\n  \"Unknown NFT standard.\"\\n  UNKNOWN\\n}\\n\\n\"Enum representing different sale strategies.\"\\nenum SaleStrategy {\\n  \"Standard sale strategy.\"\\n  STANDARD_SALE\\n  \"Sale of any item from a collection.\"\\n  ANY_ITEM_FROM_COLLECTION\\n  \"Sale of any item from a set.\"\\n  ANY_ITEM_FROM_SET\\n  \"Dutch auction sale strategy.\"\\n  DUTCH_AUCTION\\n  \"Private sale strategy.\"\\n  PRIVATE_SALE\\n}\\n\\n\"Entity representing a marketplace.\"\\ntype Marketplace @entity @regularPolling {\\n  \"Unique identifier for the marketplace.\"\\n  id: ID!\\n  \"Name of the marketplace.\"\\n  name: String!\\n  \"Slug for the marketplace.\"\\n  slug: String!\\n  \"Network on which the marketplace operates.\"\\n  network: Network!\\n  \"Version of the schema used by the marketplace.\"\\n  schemaVersion: String!\\n  \"Version of the subgraph used by the marketplace.\"\\n  subgraphVersion: String!\\n  \"Version of the methodology used by the marketplace.\"\\n  methodologyVersion: String!\\n  \"Number of collections in the marketplace.\"\\n  collectionCount: Int!\\n  \"Total number of trades in the marketplace.\"\\n  tradeCount: Int!\\n  \"Cumulative trade volume in ETH.\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Revenue generated by the marketplace in ETH.\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Revenue generated by creators in ETH.\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Total revenue generated in ETH.\"\\n  totalRevenueETH: BigDecimal!\\n  \"Cumulative number of unique traders.\"\\n  cumulativeUniqueTraders: Int!\\n}\\n\\n\"Entity representing a collection of NFTs.\"\\ntype Collection @entity @regularPolling {\\n  \"Unique identifier for the collection.\"\\n  id: ID!\\n  \"Name of the collection.\"\\n  name: String\\n  \"Symbol representing the collection.\"\\n  symbol: String\\n  \"Total supply of NFTs in the collection.\"\\n  totalSupply: BigInt\\n  \"NFT standard used by the collection.\"\\n  nftStandard: NftStandard!\\n  \"Royalty fee for the collection.\"\\n  royaltyFee: BigDecimal!\\n  \"Cumulative trade volume for the collection in ETH.\"\\n  cumulativeTradeVolumeETH: BigDecimal!\\n  \"Revenue generated by the marketplace from the collection in ETH.\"\\n  marketplaceRevenueETH: BigDecimal!\\n  \"Revenue generated by creators from the collection in ETH.\"\\n  creatorRevenueETH: BigDecimal!\\n  \"Total revenue generated from the collection in ETH.\"\\n  totalRevenueETH: BigDecimal!\\n  \"Total number of trades involving the collection.\"\\n  tradeCount: Int!\\n  \"Number of unique buyers in the collection.\"\\n  buyerCount: Int!\\n  \"Number of unique sellers in the collection.\"\\n  sellerCount: Int!\\n  \"List of trades associated with the collection.\"\\n  trades: [Trade!]! @derivedFrom(field: \"collection\")\\n}\\n\\n\"Entity representing a trade of NFTs.\"\\ntype Trade @entity'\n)",
      1
    ],
    [
      "Example({'database_schema': '\"Description for enum type: TokenType\"\\nenum TokenType {\\n  \"Description for column: REBASING\"\\n  REBASING\\n  \"Description for column: NON_REBASING\"\\n  NON_REBASING\\n}', 'documented_schema': 'enum TokenType {\\n  \" Rebasing tokens continuously adjust balances / supply as interest is accrued (e.g. Aave debt balances adjust at each block with interest) \"\\n  REBASING\\n  \" Non-rebasing token balances / supply do not change as interest is accrued (e.g. Compound\\'s cToken\\'s do not adjust balance, the exchange rate changes with interest) \"\\n  NON_REBASING\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema is an enum type named `TokenType` with two possible values: `REBASING` and `NON_REBASING`. The task is to generate detailed descriptions for each of these enum values. The descriptions should be clear and concise, providing insight into what each enum value represents without altering the schema structure.',\n    documented_schema='\"Description for enum type: TokenType\"\\nenum TokenType {\\n  \"Indicates a token that adjusts its supply periodically based on certain conditions.\"\\n  REBASING\\n  \"Indicates a token with a fixed supply that does not change over time.\"\\n  NON_REBASING\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: TickHourlySnapshot\"\\ntype TickHourlySnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hour\"\\n  hour: Int!\\n  \"Description for column: tick\"\\n  tick: Tick!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: liquidityGross\"\\n  liquidityGross: BigInt!\\n  \"Description for column: liquidityGrossUSD\"\\n  liquidityGrossUSD: BigDecimal!\\n  \"Description for column: liquidityNet\"\\n  liquidityNet: BigInt!\\n  \"Description for column: liquidityNetUSD\"\\n  liquidityNetUSD: BigDecimal!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}', 'documented_schema': 'type TickHourlySnapshot @entity(immutable: true) @hourlySnapshot {\\n  \" { pool address }-{ tick index }-{ hour ID } \"\\n  id: Bytes!\\n  \" Number of hours since Unix epoch time \"\\n  hour: Int!\\n  \" tick index \"\\n  tick: Tick!\\n  \" liquidity pool this tick belongs to \"\\n  pool: LiquidityPool!\\n  \" total liquidity pool has as tick lower or upper \"\\n  liquidityGross: BigInt!\\n  \" total liquidity in USD pool has as tick lower or upper \"\\n  liquidityGrossUSD: BigDecimal!\\n  \" how much liquidity changes when tick crossed \"\\n  liquidityNet: BigInt!\\n  \" how much liquidity in USD changes when tick crossed \"\\n  liquidityNetUSD: BigDecimal!\\n  \" Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed) \"\\n  timestamp: BigInt!\\n  \" Block number of when this snapshot was taken/last modified (May be taken after interval has passed) \"\\n  blockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `TickHourlySnapshot` which is marked as an immutable entity and is associated with hourly snapshots. Each field within this type has a specific role and data type, which is crucial for understanding the structure and purpose of the data captured by this schema. The task is to provide clear and concise documentation for each field based on its name and type, ensuring that the descriptions are informative and helpful for developers or system architects who will interact with this schema.',\n    documented_schema='\"Description for table: TickHourlySnapshot\"\\ntype TickHourlySnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Unique identifier for the snapshot, represented as a byte array.\"\\n  id: Bytes!\\n  \"The hour of the snapshot, stored as an integer.\"\\n  hour: Int!\\n  \"Reference to the associated tick data.\"\\n  tick: Tick!\\n  \"Reference to the associated liquidity pool.\"\\n  pool: LiquidityPool!\\n  \"Total gross liquidity at the time of the snapshot, stored as a big integer.\"\\n  liquidityGross: BigInt!\\n  \"Total gross liquidity in USD at the time of the snapshot, stored as a decimal.\"\\n  liquidityGrossUSD: BigDecimal!\\n  \"Net liquidity at the time of the snapshot, stored as a big integer.\"\\n  liquidityNet: BigInt!\\n  \"Net liquidity in USD at the time of the snapshot, stored as a decimal.\"\\n  liquidityNetUSD: BigDecimal!\\n  \"Timestamp of the snapshot, stored as a big integer.\"\\n  timestamp: BigInt!\\n  \"Block number at the time of the snapshot, stored as a big integer.\"\\n  blockNumber: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: CreatorContract\"\\ntype CreatorContract @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: implementation\"\\n  implementation: Bytes!\\n  \"Description for column: deployer\"\\n  deployer: Bytes!\\n  \"Description for column: creator\"\\n  creator: Bytes!\\n  \"Description for column: paused\"\\n  paused: Boolean!\\n  \"Description for column: owner\"\\n  owner: Bytes!\\n  \"Description for column: secondaryRoyaltyPercentage\"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \"Description for column: minter\"\\n  minter: Bytes!\\n  \"Description for column: defaultFundsHandler\"\\n  defaultFundsHandler: Bytes!\\n  \"Description for column: defaultFundsRecipients\"\\n  defaultFundsRecipients: [Bytes!]!\\n  \"Description for column: defaultFundsShares\"\\n  defaultFundsShares: [BigInt!]!\\n  \"Description for column: ERC165InterfaceID\"\\n  ERC165InterfaceID: Bytes\\n  \"Description for column: isBatchBuyItNow\"\\n  isBatchBuyItNow: Boolean!\\n  \"Description for column: isHidden\"\\n  isHidden: Boolean!\\n  \"Description for column: transferState\"\\n  transferState: BigInt!\\n  \"Description for column: totalNumOfEditions\"\\n  totalNumOfEditions: BigInt!\\n  \"Description for column: totalNumOfTokensSold\"\\n  totalNumOfTokensSold: BigInt!\\n  \"Description for column: totalEthValueOfSales\"\\n  totalEthValueOfSales: BigDecimal!\\n  \"Description for column: totalNumOfTransfers\"\\n  totalNumOfTransfers: BigInt!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: filterRegistry\"\\n  filterRegistry: Bytes\\n}', 'documented_schema': '\" A table of KODA V4 contracts deployed from the V4 factory. \"\\ntype CreatorContract @entity {\\n  \" The unique identifier for the creator contract. \"\\n  id: ID!\\n  \" The block number of the deployment. \"\\n  blockNumber: BigInt!\\n  \" The timestamp of the deployment. \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the deployment. \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the deployment. \"\\n  transactionIndex: BigInt!\\n  \" The log index of the deployment. \"\\n  logIndex: BigInt!\\n  \" The address of the event. \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. \"\\n  eventTxTo: Bytes\\n  \" The address of the implementation contract. \"\\n  implementation: Bytes!\\n  \" The deployer address of the creator contract. \"\\n  deployer: Bytes!\\n  \" The creator address of the creator contract. \"\\n  creator: Bytes!\\n  \" Whether the creator contract is paused. \"\\n  paused: Boolean!\\n  \" The owner of the creator contract. \"\\n  owner: Bytes!\\n  \" The secondary royalty percentage for the creator contract (Across all editions the currently specified secondary royalty EIP2981). \"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \" The minter of the creator contract. \"\\n  minter: Bytes!\\n  \" The default funds handler for the creator contract. \"\\n  defaultFundsHandler: Bytes!\\n  \" The default funds recipients for the creator contract. \"\\n  defaultFundsRecipients: [Bytes!]!\\n  \" The default funds shares for the creator contract. \"\\n  defaultFundsShares: [BigInt!]!\\n  \" The ERC165 interface ID for the creator contract. \"\\n  ERC165InterfaceID: Bytes\\n  \" If the creator contract is batch buy it now. \"\\n  isBatchBuyItNow: Boolean!\\n  \" If the creator contract is hidden. \"\\n  isHidden: Boolean!\\n  \" The transfer state of the creator contract. \"\\n  transferState: BigInt!\\n  \" The total number of editions created by the creator contract. \"\\n  totalNumOfEditions: BigInt!\\n  \" The total number of tokens sold by the creator contract. \"\\n  totalNumOfTokensSold: BigInt!\\n  \" The total ETH value of sales by the creator contract. \"\\n  totalEthValueOfSales: BigDecimal!\\n  \" The total number of transfers by the creator contract. \"\\n  totalNumOfTransfers: BigInt!\\n  \" The editions created by the creator contract. \"\\n  editions: [Edition!]!\\n  \" The name of the creator contract. \"\\n  name: String\\n  \" The symbol of the creator contract. \"\\n  symbol: String\\n  \" The filter registry of the creator contract. \"\\n  filterRegistry: Bytes\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema represents a table named `CreatorContract` with various fields, each having a specific data type and purpose. The task is to generate clear and concise descriptions for each field based on the information given in the schema. The descriptions should be factual and straightforward, providing insight into what each field represents or is used for, without altering the schema\\'s structure. The descriptions should avoid speculative language and should not include phrases like \"in the CreatorContract table\" to maintain clarity and focus on the field itself.',\n    documented_schema='\"Description for table: CreatorContract\"\\ntype CreatorContract @entity {\\n  \"Unique identifier for the creator contract.\"\\n  id: ID!\\n  \"Block number at which the contract was created.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of when the contract was created.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction that created the contract.\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block.\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry within the transaction.\"\\n  logIndex: BigInt!\\n  \"Address associated with the event.\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction was sent.\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent, if applicable.\"\\n  eventTxTo: Bytes\\n  \"Address of the contract implementation.\"\\n  implementation: Bytes!\\n  \"Address of the entity that deployed the contract.\"\\n  deployer: Bytes!\\n  \"Address of the creator associated with the contract.\"\\n  creator: Bytes!\\n  \"Indicates whether the contract is paused.\"\\n  paused: Boolean!\\n  \"Address of the owner of the contract.\"\\n  owner: Bytes!\\n  \"Percentage of secondary royalties set for the contract.\"\\n  secondaryRoyaltyPercentage: BigInt!\\n  \"Address of the minter associated with the contract.\"\\n  minter: Bytes!\\n  \"Default address for handling funds.\"\\n  defaultFundsHandler: Bytes!\\n  \"List of default recipient addresses for funds.\"\\n  defaultFundsRecipients: [Bytes!]!\\n  \"List of shares corresponding to each default fund recipient.\"\\n  defaultFundsShares: [BigInt!]!\\n  \"ERC165 interface identifier, if applicable.\"\\n  ERC165InterfaceID: Bytes\\n  \"Indicates if batch buy-it-now functionality is enabled.\"\\n  isBatchBuyItNow: Boolean!\\n  \"Indicates if the contract is hidden.\"\\n  isHidden: Boolean!\\n  \"State of the transfer process.\"\\n  transferState: BigInt!\\n  \"Total number of editions available in the contract.\"\\n  totalNumOfEditions: BigInt!\\n  \"Total number of tokens sold from the contract.\"\\n  totalNumOfTokensSold: BigInt!\\n  \"Total Ethereum value of all sales made.\"\\n  totalEthValueOfSales: BigDecimal!\\n  \"Total number of transfers that have occurred.\"\\n  totalNumOfTransfers: BigInt!\\n  \"List of editions associated with the contract.\"\\n  editions: [Edition!]!\\n  \"Name of the contract, if specified.\"\\n  name: String\\n  \"Symbol representing the contract, if specified.\"\\n  symbol: String\\n  \"Address of the filter registry, if applicable.\"\\n  filterRegistry: Bytes\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: _FlashLoanPremium\"\\ntype _FlashLoanPremium @entity {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: premiumRateTotal\"\\n  premiumRateTotal: BigDecimal!\\n  \"Description for column: premiumRateToProtocol\"\\n  premiumRateToProtocol: BigDecimal!\\n}', 'documented_schema': 'type _FlashLoanPremium @entity {\\n  \" protocol id \"\\n  id: Bytes!\\n  \" total premium rate \"\\n  premiumRateTotal: BigDecimal!\\n  \" premium rate to protocol \"\\n  premiumRateToProtocol: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `_FlashLoanPremium`, which includes three fields: `id`, `premiumRateTotal`, and `premiumRateToProtocol`. Each field is associated with a specific data type, and the schema already includes brief descriptions for each field. The task is to enhance these descriptions to provide more detailed and informative documentation while maintaining the existing schema structure and ensuring accuracy based on the provided information.',\n    documented_schema='\"Description for table: _FlashLoanPremium\"\\ntype _FlashLoanPremium @entity {\\n  \"Unique identifier for the flash loan premium entry.\"\\n  id: Bytes!\\n  \"The total premium rate applied to the flash loan.\"\\n  premiumRateTotal: BigDecimal!\\n  \"The portion of the premium rate allocated to the protocol.\"\\n  premiumRateToProtocol: BigDecimal!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for enum type: DisputeStatus\"\\nenum DisputeStatus {\\n  \"Description for column: Undecided\"\\n  Undecided\\n  \"Description for column: Accepted\"\\n  Accepted\\n  \"Description for column: Rejected\"\\n  Rejected\\n  \"Description for column: Draw\"\\n  Draw\\n}', 'documented_schema': 'enum DisputeStatus {\\n  Undecided\\n  Accepted\\n  Rejected\\n  Draw\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema is an enum type named `DisputeStatus`, which represents the possible statuses of a dispute. Each value within the enum is a distinct status that a dispute can have. The task is to ensure that each enum value is documented with a clear and concise description that accurately reflects its role within the enum. The existing descriptions are placeholders and need to be replaced with more informative descriptions that explain what each status signifies.',\n    documented_schema='\"Description for enum type: DisputeStatus\"\\nenum DisputeStatus {\\n  \"The dispute is currently unresolved and awaiting a decision.\"\\n  Undecided\\n  \"The dispute has been reviewed and accepted as valid.\"\\n  Accepted\\n  \"The dispute has been reviewed and rejected as invalid.\"\\n  Rejected\\n  \"The dispute has been reviewed and resulted in a draw, with no clear resolution.\"\\n  Draw\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for enum type: Network\"\\nenum Network {\\n  \"Description for column: ARBITRUM_ONE\"\\n  ARBITRUM_ONE\\n  \"Description for column: ARWEAVE_MAINNET\"\\n  ARWEAVE_MAINNET\\n  \"Description for column: AURORA\"\\n  AURORA\\n  \"Description for column: AVALANCHE\"\\n  AVALANCHE\\n  \"Description for column: BOBA\"\\n  BOBA\\n  \"Description for column: BSC\"\\n  BSC\\n  \"Description for column: CELO\"\\n  CELO\\n  \"Description for column: COSMOS\"\\n  COSMOS\\n  \"Description for column: CRONOS\"\\n  CRONOS\\n  \"Description for column: MAINNET\"\\n  MAINNET\\n  \"Description for column: FANTOM\"\\n  FANTOM\\n  \"Description for column: FUSE\"\\n  FUSE\\n  \"Description for column: HARMONY\"\\n  HARMONY\\n  \"Description for column: JUNO\"\\n  JUNO\\n  \"Description for column: MOONBEAM\"\\n  MOONBEAM\\n  \"Description for column: MOONRIVER\"\\n  MOONRIVER\\n  \"Description for column: NEAR_MAINNET\"\\n  NEAR_MAINNET\\n  \"Description for column: OPTIMISM\"\\n  OPTIMISM\\n  \"Description for column: OSMOSIS\"\\n  OSMOSIS\\n  \"Description for column: MATIC\"\\n  MATIC\\n  \"Description for column: XDAI\"\\n  XDAI\\n}', 'documented_schema': '\" Represents the blockchain network that the data is being collected from. \"\\nenum Network {\\n  \" The Arbitrum One network. \"\\n  ARBITRUM_ONE\\n  \" The Arweave Mainnet. \"\\n  ARWEAVE_MAINNET\\n  \" The Aurora network. \"\\n  AURORA\\n  \" The Avalanche network. \"\\n  AVALANCHE\\n  \" The Boba network. \"\\n  BOBA\\n  \" The Binance Smart Chain network (aka BNB Chain). \"\\n  BSC\\n  \" The Celo network. \"\\n  CELO\\n  \" The Cosmos network. \"\\n  COSMOS\\n  \" The Cronos network. \"\\n  CRONOS\\n  \" The Ethereum Mainnet. \"\\n  MAINNET\\n  \" The Fantom network. \"\\n  FANTOM\\n  \" The Fuse network. \"\\n  FUSE\\n  \" The Harmony network. \"\\n  HARMONY\\n  \" The Juno network. \"\\n  JUNO\\n  \" The Moonbeam network. \"\\n  MOONBEAM\\n  \" The Moonriver network. \"\\n  MOONRIVER\\n  \" The NEAR Mainnet. \"\\n  NEAR_MAINNET\\n  \" The Optimism network. \"\\n  OPTIMISM\\n  \" The Osmosis network. \"\\n  OSMOSIS\\n  \" The Matic network (aka Polygon). \"\\n  MATIC\\n  \" The xDai network (aka Gnosis Chain). \"\\n  XDAI\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema is an enumeration type named `Network`, which lists various blockchain networks. Each entry in the enum represents a distinct blockchain network, and the descriptions for each entry are placeholders that need to be replaced with more informative descriptions. The task is to provide clear and concise descriptions for each network, ensuring that the documentation is factual and aids in understanding the purpose or identity of each network.',\n    documented_schema='\"Description for enum type: Network\"\\nenum Network {\\n  \"Represents the Arbitrum One network, a layer 2 scaling solution for Ethereum.\"\\n  ARBITRUM_ONE\\n  \"Represents the Arweave Mainnet, a decentralized storage network.\"\\n  ARWEAVE_MAINNET\\n  \"Represents the Aurora network, an Ethereum Virtual Machine (EVM) on the NEAR Protocol.\"\\n  AURORA\\n  \"Represents the Avalanche network, a platform for decentralized applications and custom blockchain networks.\"\\n  AVALANCHE\\n  \"Represents the Boba network, a layer 2 scaling solution for Ethereum.\"\\n  BOBA\\n  \"Represents the Binance Smart Chain (BSC), a blockchain network running in parallel with Binance Chain.\"\\n  BSC\\n  \"Represents the Celo network, a blockchain platform focused on mobile-first decentralized applications.\"\\n  CELO\\n  \"Represents the Cosmos network, an ecosystem of interconnected blockchains.\"\\n  COSMOS\\n  \"Represents the Cronos network, a blockchain network for decentralized finance and NFTs.\"\\n  CRONOS\\n  \"Represents the Ethereum Mainnet, the primary public Ethereum blockchain.\"\\n  MAINNET\\n  \"Represents the Fantom network, a fast, scalable blockchain for digital assets and dApps.\"\\n  FANTOM\\n  \"Represents the Fuse network, a blockchain platform for open-source finance.\"\\n  FUSE\\n  \"Represents the Harmony network, a blockchain platform designed for decentralized applications.\"\\n  HARMONY\\n  \"Represents the Juno network, a decentralized, permissionless smart contract network.\"\\n  JUNO\\n  \"Represents the Moonbeam network, an Ethereum-compatible smart contract platform on Polkadot.\"\\n  MOONBEAM\\n  \"Represents the Moonriver network, a community-led sister parachain on Kusama.\"\\n  MOONRIVER\\n  \"Represents the NEAR Mainnet, a scalable blockchain designed for high-performance applications.\"\\n  NEAR_MAINNET\\n  \"Represents the Optimism network, a layer 2 scaling solution for Ethereum.\"\\n  OPTIMISM\\n  \"Represents the Osmosis network, a decentralized exchange and automated market maker protocol.\"\\n  OSMOSIS\\n  \"Represents the Polygon network (formerly Matic), a protocol for building and connecting Ethereum-compatible blockchain networks.\"\\n  MATIC\\n  \"Represents the xDai network, a stable payment blockchain designed for fast and inexpensive transactions.\"\\n  XDAI\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: GraphAccount\"\\ntype GraphAccount @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: names\"\\n  names: [GraphAccountName!]! @derivedFrom(field: \"graphAccount\")\\n  \"Description for column: defaultName\"\\n  defaultName: GraphAccountName\\n  \"Description for column: createdAt\"\\n  createdAt: Int!\\n  \"Description for column: defaultDisplayName\"\\n  defaultDisplayName: String\\n  \"Description for column: metadata\"\\n  metadata: GraphAccountMeta\\n  \"Description for column: operatorOf\"\\n  operatorOf: [GraphAccount!]! @derivedFrom(field: \"operators\")\\n  \"Description for column: operators\"\\n  operators: [GraphAccount!]!\\n  \"Description for column: balance\"\\n  balance: BigInt!\\n  \"Description for column: balanceReceivedFromL1Signalling\"\\n  balanceReceivedFromL1Signalling: BigInt!\\n  \"Description for column: balanceReceivedFromL1Delegation\"\\n  balanceReceivedFromL1Delegation: BigInt!\\n  \"Description for column: curationApproval\"\\n  curationApproval: BigInt!\\n  \"Description for column: stakingApproval\"\\n  stakingApproval: BigInt!\\n  \"Description for column: gnsApproval\"\\n  gnsApproval: BigInt!\\n  \"Description for column: subgraphs\"\\n  subgraphs: [Subgraph!]! @derivedFrom(field: \"owner\")\\n  \"Description for column: developerCreatedAt\"\\n  developerCreatedAt: Int\\n  \"Description for column: subgraphQueryFees\"\\n  subgraphQueryFees: BigInt!\\n  \"Description for column: createdDisputes\"\\n  createdDisputes: [Dispute!]! @derivedFrom(field: \"fisherman\")\\n  \"Description for column: disputesAgainst\"\\n  disputesAgainst: [Dispute!]! @derivedFrom(field: \"indexer\")\\n  \"Description for column: curator\"\\n  curator: Curator\\n  \"Description for column: indexer\"\\n  indexer: Indexer\\n  \"Description for column: delegator\"\\n  delegator: Delegator\\n  \"Description for column: nameSignalTransactions\"\\n  nameSignalTransactions: [NameSignalTransaction!]! @derivedFrom(field: \"signer\")\\n  \"Description for column: bridgeWithdrawalTransactions\"\\n  bridgeWithdrawalTransactions: [BridgeWithdrawalTransaction!]! @derivedFrom(field: \"signer\")\\n  \"Description for column: bridgeDepositTransactions\"\\n  bridgeDepositTransactions: [BridgeDepositTransaction!]! @derivedFrom(field: \"signer\")\\n  \"Description for column: tokenLockWallets\"\\n  tokenLockWallets: [TokenLockWallet!]!\\n}', 'documented_schema': '\"\"\"\\nAn account within the graph network. Contains metadata and all relevant data for this accounts\\ndelegating, curating, and indexing.\\n\"\"\"\\ntype GraphAccount @entity {\\n  \"Graph account ID\"\\n  id: ID!\\n  \"All names this graph account has claimed from all name systems\"\\n  names: [GraphAccountName!]! @derivedFrom(field: \"graphAccount\")\\n  \"Default name the graph account has chosen\"\\n  defaultName: GraphAccountName\\n  \"Time the account was created\"\\n  createdAt: Int!\\n  \"Default display name is the current default name. Used for filtered queries in the explorer\"\\n  defaultDisplayName: String\\n  metadata: GraphAccountMeta\\n  \"Operator of other Graph Accounts\"\\n  operatorOf: [GraphAccount!]! @derivedFrom(field: \"operators\")\\n  \"Operators of this Graph Accounts\"\\n  operators: [GraphAccount!]!\\n  \"Graph token balance\"\\n  balance: BigInt!\\n  \"Balance received due to failed signal transfer from L1\"\\n  balanceReceivedFromL1Signalling: BigInt!\\n  \"Balance received due to failed delegation transfer from L1\"\\n  balanceReceivedFromL1Delegation: BigInt!\\n  \"Amount this account has approved staking to transfer their GRT\"\\n  curationApproval: BigInt!\\n  \"Amount this account has approved curation to transfer their GRT\"\\n  stakingApproval: BigInt!\\n  \"Amount this account has approved the GNS to transfer their GRT\"\\n  gnsApproval: BigInt!\\n  \"Subgraphs the graph account owns\"\\n  subgraphs: [Subgraph!]! @derivedFrom(field: \"owner\")\\n  \"Time that this graph account became a developer\"\\n  developerCreatedAt: Int\\n  \"NOT IMPLEMENTED - Total query fees the subgraphs created by this account have accumulated in GRT\"\\n  subgraphQueryFees: BigInt!\\n  \"Disputes this graph account has created\"\\n  createdDisputes: [Dispute!]! @derivedFrom(field: \"fisherman\")\\n  \"Disputes against this graph account\"\\n  disputesAgainst: [Dispute!]! @derivedFrom(field: \"indexer\")\\n  \"Curator fields for this GraphAccount. Null if never curated\"\\n  curator: Curator\\n  \"Indexer fields for this GraphAccount. Null if never indexed\"\\n  indexer: Indexer\\n  \"Delegator fields for this GraphAccount. Null if never delegated\"\\n  delegator: Delegator\\n  \"Name signal transactions created by this GraphAccount\"\\n  nameSignalTransactions: [NameSignalTransaction!]! @derivedFrom(field: \"signer\")\\n  bridgeWithdrawalTransactions: [BridgeWithdrawalTransaction!]! @derivedFrom(field: \"signer\")\\n  bridgeDepositTransactions: [BridgeDepositTransaction!]! @derivedFrom(field: \"signer\")\\n  tokenLockWallets: [TokenLockWallet!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `GraphAccount` with various fields, each having a specific role within the entity. The task is to document each field with clear and concise descriptions based on the information available in the schema. The descriptions should provide insight into the purpose and nature of each field without altering the schema's structure. The documentation should be factual and straightforward, avoiding any assumptions or speculative language.\",\n    documented_schema='\"Description for table: GraphAccount\"\\ntype GraphAccount @entity {\\n  \"Unique identifier for the GraphAccount.\"\\n  id: ID!\\n  \"List of names associated with the GraphAccount, derived from the graphAccount field.\"\\n  names: [GraphAccountName!]! @derivedFrom(field: \"graphAccount\")\\n  \"The default name for the GraphAccount.\"\\n  defaultName: GraphAccountName\\n  \"Timestamp indicating when the GraphAccount was created.\"\\n  createdAt: Int!\\n  \"The default display name for the GraphAccount.\"\\n  defaultDisplayName: String\\n  \"Metadata associated with the GraphAccount.\"\\n  metadata: GraphAccountMeta\\n  \"List of GraphAccounts operated by this account, derived from the operators field.\"\\n  operatorOf: [GraphAccount!]! @derivedFrom(field: \"operators\")\\n  \"List of operators for this GraphAccount.\"\\n  operators: [GraphAccount!]!\\n  \"Current balance of the GraphAccount.\"\\n  balance: BigInt!\\n  \"Balance received from L1 signalling.\"\\n  balanceReceivedFromL1Signalling: BigInt!\\n  \"Balance received from L1 delegation.\"\\n  balanceReceivedFromL1Delegation: BigInt!\\n  \"Approval amount for curation.\"\\n  curationApproval: BigInt!\\n  \"Approval amount for staking.\"\\n  stakingApproval: BigInt!\\n  \"Approval amount for GNS (Graph Name Service).\"\\n  gnsApproval: BigInt!\\n  \"List of subgraphs owned by the GraphAccount, derived from the owner field.\"\\n  subgraphs: [Subgraph!]! @derivedFrom(field: \"owner\")\\n  \"Timestamp indicating when the developer created the account.\"\\n  developerCreatedAt: Int\\n  \"Fees collected from subgraph queries.\"\\n  subgraphQueryFees: BigInt!\\n  \"List of disputes created by the GraphAccount, derived from the fisherman field.\"\\n  createdDisputes: [Dispute!]! @derivedFrom(field: \"fisherman\")\\n  \"List of disputes against the GraphAccount, derived from the indexer field.\"\\n  disputesAgainst: [Dispute!]! @derivedFrom(field: \"indexer\")\\n  \"Curator role associated with the GraphAccount.\"\\n  curator: Curator\\n  \"Indexer role associated with the GraphAccount.\"\\n  indexer: Indexer\\n  \"Delegator role associated with the GraphAccount.\"\\n  delegator: Delegator\\n  \"List of name signal transactions signed by the GraphAccount, derived from the signer field.\"\\n  nameSignalTransactions: [NameSignalTransaction!]! @derivedFrom(field: \"signer\")\\n  \"List of bridge withdrawal transactions signed by the GraphAccount, derived from the signer field.\"\\n  bridgeWithdrawalTransactions: [BridgeWithdrawalTransaction!]! @derivedFrom(field: \"signer\")\\n  \"List of bridge deposit transactions signed by the GraphAccount, derived from the signer field.\"\\n  bridgeDepositTransactions: [BridgeDepositTransaction!]! @derivedFrom(field: \"signer\")\\n  \"List of token lock wallets associated with the GraphAccount.\"\\n  tokenLockWallets: [TokenLockWallet!]!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: PositionSnapshot\"\\ntype PositionSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hash\"\\n  hash: Bytes!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: nonce\"\\n  nonce: BigInt!\\n  \"Description for column: position\"\\n  position: Position!\\n  \"Description for column: liquidityTokenType\"\\n  liquidityTokenType: TokenType\\n  \"Description for column: liquidity\"\\n  liquidity: BigInt\\n  \"Description for column: liquidityUSD\"\\n  liquidityUSD: BigDecimal\\n  \"Description for column: cumulativeDepositTokenAmounts\"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \"Description for column: cumulativeDepositUSD\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Description for column: cumulativeWithdrawTokenAmounts\"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \"Description for column: cumulativeWithdrawUSD\"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \"Description for column: cumulativeRewardTokenAmounts\"\\n  cumulativeRewardTokenAmounts: [BigInt!]\\n  \"Description for column: cumulativeRewardUSD\"\\n  cumulativeRewardUSD: [BigInt!]\\n  \"Description for column: depositCount\"\\n  depositCount: Int!\\n  \"Description for column: withdrawCount\"\\n  withdrawCount: Int!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}', 'documented_schema': 'type PositionSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \" { Position ID }-{ Transaction hash }-{ Log index } \"\\n  id: Bytes!\\n  \" Transaction hash of the transaction that triggered this snapshot \"\\n  hash: Bytes!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" Nonce of the transaction that triggered this snapshot \"\\n  nonce: BigInt!\\n  \" Position of this snapshot \"\\n  position: Position!\\n  \" Type of token used to track liquidity \"\\n  liquidityTokenType: TokenType\\n  \" total position liquidity \"\\n  liquidity: BigInt\\n  \" total position liquidity in USD \"\\n  liquidityUSD: BigDecimal\\n  \" amount of tokens ever deposited to position \"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \" amount of tokens in USD deposited to position \"\\n  cumulativeDepositUSD: BigDecimal!\\n  \" amount of tokens ever withdrawn from position (without fees) \"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \" amount of tokens in USD withdrawn from position (without fees) \"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \" Total reward token accumulated under this position, in native amounts \"\\n  cumulativeRewardTokenAmounts: [BigInt!]\\n  \" Total reward token accumulated under this position, in USD \"\\n  cumulativeRewardUSD: [BigInt!]\\n  \" Number of deposits related to this position \"\\n  depositCount: Int!\\n  \" Number of withdrawals related to this position \"\\n  withdrawCount: Int!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `PositionSnapshot` with various fields, each having a specific data type and some with existing descriptions. The task is to generate detailed and concise descriptions for each field based on the information available in the schema. The descriptions should be factual and straightforward, providing clarity on what each field represents without altering the schema's structure.\",\n    documented_schema='\"Description for table: PositionSnapshot\"\\ntype PositionSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Unique identifier for the position snapshot.\"\\n  id: Bytes!\\n  \"Hash of the transaction associated with the position snapshot.\"\\n  hash: Bytes!\\n  \"Index of the log entry within the block for the transaction.\"\\n  logIndex: Int!\\n  \"Nonce value used in the transaction.\"\\n  nonce: BigInt!\\n  \"Reference to the associated position entity.\"\\n  position: Position!\\n  \"Type of liquidity token involved in the position.\"\\n  liquidityTokenType: TokenType\\n  \"Amount of liquidity in the position.\"\\n  liquidity: BigInt\\n  \"Value of the liquidity in USD.\"\\n  liquidityUSD: BigDecimal\\n  \"Cumulative amounts of deposit tokens in the position.\"\\n  cumulativeDepositTokenAmounts: [BigInt!]!\\n  \"Total value of deposits in USD.\"\\n  cumulativeDepositUSD: BigDecimal!\\n  \"Cumulative amounts of withdrawn tokens from the position.\"\\n  cumulativeWithdrawTokenAmounts: [BigInt!]!\\n  \"Total value of withdrawals in USD.\"\\n  cumulativeWithdrawUSD: BigDecimal!\\n  \"Cumulative amounts of reward tokens earned in the position.\"\\n  cumulativeRewardTokenAmounts: [BigInt!]\\n  \"Total value of rewards in USD.\"\\n  cumulativeRewardUSD: [BigInt!]\\n  \"Number of deposit transactions recorded.\"\\n  depositCount: Int!\\n  \"Number of withdrawal transactions recorded.\"\\n  withdrawCount: Int!\\n  \"Block number in which the snapshot was recorded.\"\\n  blockNumber: BigInt!\\n  \"Timestamp indicating when the snapshot was taken.\"\\n  timestamp: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: SupportedToken\"\\ntype SupportedToken @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: Bytes!\\n}', 'documented_schema': 'type SupportedToken @entity(immutable: true) {\\n  id: Bytes!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema consists of a single entity, `SupportedToken`, which is marked as immutable, indicating that once created, instances of this entity cannot be modified. The entity contains a single field, `id`, which is of type `Bytes!`. The exclamation mark denotes that this field is non-nullable, meaning it must always have a value. The `id` field likely serves as a unique identifier for each instance of the `SupportedToken` entity.',\n    documented_schema='\"Description for table: SupportedToken\"\\ntype SupportedToken @entity(immutable: true) {\\n  \"Unique identifier for the supported token, represented as a non-nullable byte array.\"\\n  id: Bytes!\\n}'\n)",
      4
    ],
    [
      "Example({'database_schema': '\"Description for table: GatedSale\"\\ntype GatedSale @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: editionId\"\\n  editionId: String!\\n  \"Description for column: paused\"\\n  paused: Boolean!\\n  \"Description for column: primarySaleCommission\"\\n  primarySaleCommission: BigInt!\\n  \"Description for column: artistAccount\"\\n  artistAccount: String\\n  \"Description for column: mintCount\"\\n  mintCount: BigInt!\\n  \"Description for column: phases\"\\n  phases: [Phase!]!\\n}', 'documented_schema': '\" A table of gated sale. A gate sale configuration - one per edition. \"\\ntype GatedSale @entity {\\n  \" The unique identifier for the gated sale. This is the ID of the gated sale. Type: ID! \"\\n  id: ID!\\n  \" The edition. This is the edition the sale will mint. Type: String! \"\\n  editionId: String!\\n  \" The paused flag. This is a boolean that indicates if the sale is currently paused. Type: Boolean! \"\\n  paused: Boolean!\\n  \" The primary sale commission. This is the overridden sales commission for KO. Type: BigInt! \"\\n  primarySaleCommission: BigInt!\\n  \" The artist account. This is the address of the artist associated with the given edition ID. Type: String! \"\\n  artistAccount: String\\n  \" The mint count. This is the total mint current for the sale. Type: BigInt! \"\\n  mintCount: BigInt!\\n  \" The phases. This is an array of phases associated with the sale. Type: [Phase!]! \"\\n  phases: [Phase!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `GatedSale`, which represents a sale with specific conditions or restrictions. Each field within this entity has a specific role:\\n\\n- `id`: Serves as the unique identifier for each `GatedSale` instance.\\n- `editionId`: Likely represents the identifier for a specific edition associated with the sale.\\n- `paused`: Indicates whether the sale is currently paused.\\n- `primarySaleCommission`: Represents the commission amount for the primary sale, stored as a large integer.\\n- `artistAccount`: Optionally stores the account information of the artist involved in the sale.\\n- `mintCount`: Tracks the number of items minted during the sale.\\n- `phases`: Contains a list of `Phase` objects, detailing different stages or conditions of the sale.\\n\\nThe documentation should provide clear and concise descriptions for each field, ensuring that users understand their purpose and data type without altering the schema structure.',\n    documented_schema='\"Description for table: GatedSale\"\\ntype GatedSale @entity {\\n  \"Unique identifier for the GatedSale instance.\"\\n  id: ID!\\n  \"Identifier for the specific edition associated with the sale.\"\\n  editionId: String!\\n  \"Indicates if the sale is currently paused.\"\\n  paused: Boolean!\\n  \"Commission amount for the primary sale, represented as a large integer.\"\\n  primarySaleCommission: BigInt!\\n  \"Optional account information of the artist involved in the sale.\"\\n  artistAccount: String\\n  \"Number of items minted during the sale.\"\\n  mintCount: BigInt!\\n  \"List of phases detailing different stages or conditions of the sale.\"\\n  phases: [Phase!]!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Pool\"\\ntype Pool @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: protocol\"\\n  protocol: BridgeProtocol!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: relation\"\\n  relation: Bytes\\n  \"Description for column: type\"\\n  type: BridgePoolType!\\n  \"Description for column: inputToken\"\\n  inputToken: Token!\\n  \"Description for column: destinationTokens\"\\n  destinationTokens: [CrosschainToken!]!\\n  \"Description for column: routes\"\\n  routes: [PoolRoute!]!\\n  \"Description for column: outputToken\"\\n  outputToken: Token\\n  \"Description for column: rewardTokens\"\\n  rewardTokens: [RewardToken!]\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: createdBlockNumber\"\\n  createdBlockNumber: BigInt!\\n  \"Description for column: mintSupply\"\\n  mintSupply: BigInt\\n  \"Description for column: inputTokenBalance\"\\n  inputTokenBalance: BigInt!\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: netValueExportedUSD\"\\n  netValueExportedUSD: BigDecimal!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeIn\"\\n  cumulativeVolumeIn: BigInt!\\n  \"Description for column: cumulativeVolumeOut\"\\n  cumulativeVolumeOut: BigInt!\\n  \"Description for column: netVolume\"\\n  netVolume: BigInt!\\n  \"Description for column: cumulativeVolumeInUSD\"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeOutUSD\"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n  \"Description for column: netVolumeUSD\"\\n  netVolumeUSD: BigDecimal!\\n  \"Description for column: outputTokenSupply\"\\n  outputTokenSupply: BigInt\\n  \"Description for column: outputTokenPriceUSD\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"Description for column: dailySnapshots\"\\n  dailySnapshots: [PoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: hourlySnapshots\"\\n  hourlySnapshots: [PoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: _lastDailySnapshotTimestamp\"\\n  _lastDailySnapshotTimestamp: BigInt\\n  \"Description for column: _lastHourlySnapshotTimestamp\"\\n  _lastHourlySnapshotTimestamp: BigInt\\n  \"Description for column: _inputTokenLiquidityBalance\"\\n  _inputTokenLiquidityBalance: BigInt\\n}', 'documented_schema': 'type Pool @entity @regularPolling {\\n  \" Smart contract address of the pool \"\\n  id: Bytes!\\n  \" The protocol this pool belongs to \"\\n  protocol: BridgeProtocol!\\n  \" Name of the pool (e.g. Curve.fi DAI/USDC/USDT) \"\\n  name: String\\n  \" Symbol of liquidity pool (e.g. 3CRV) \"\\n  symbol: String\\n  \" A unique identifier that can relate multiple pools together. e.g. a common address that they all share. This is useful for pools with multiple input tokens \"\\n  relation: Bytes\\n  \" The type of the pool, determined by the type of the input tokens. \"\\n  type: BridgePoolType!\\n  \" Tokens that can be bridged from and to this pool \"\\n  inputToken: Token!\\n  \" Equivalent to inputTokens but in the other networks \"\\n  destinationTokens: [CrosschainToken!]!\\n  \" Info about pool usage to and from each chain the pool is connected to \"\\n  routes: [PoolRoute!]!\\n  \" Token that is minted to track ownership of a liquidity position, if the pool is liquidity based. \"\\n  outputToken: Token\\n  \" Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon \"\\n  rewardTokens: [RewardToken!]\\n  \" Creation timestamp \"\\n  createdTimestamp: BigInt!\\n  \" Creation block number \"\\n  createdBlockNumber: BigInt!\\n  \" Only for MINT/BURN pools: the current supply of the minted token on this chain. \"\\n  mintSupply: BigInt\\n  \" Amount of input tokens in the pool \"\\n  inputTokenBalance: BigInt!\\n  \" Current TVL (Total Value Locked) of this pool in USD (only applies to LOCK_RELEASE and LIQUIDITY pools)\"\\n  totalValueLockedUSD: BigDecimal!\\n  \" USD value of all assets bridged into or away from this chain through this pool. For mint/burn pools, this is the USD value of the minted supplies. For lock/release pools, this is the USD value of the input token balance. \"\\n  netValueExportedUSD: BigDecimal!\\n  \" All revenue generated by the pool, from transactions originating in this network, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the pool, from transactions originating in this network, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" Total volume bridged to this pool in token amounts \"\\n  cumulativeVolumeIn: BigInt!\\n  \" Total volume bridged from this pool in token amounts \"\\n  cumulativeVolumeOut: BigInt!\\n  \" cumulativeIn - cumulativeOut \"\\n  netVolume: BigInt!\\n  \" Total volume bridged to this pool in USD \"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \" Total volume bridged from this pool in USD \"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n  \" cumulativeInUSD - cumulativeOutUSD \"\\n  netVolumeUSD: BigDecimal!\\n  \" Total supply of output token. \"\\n  outputTokenSupply: BigInt\\n  \" Price per share of output token in USD \"\\n  outputTokenPriceUSD: BigDecimal\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day, in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \" Pool daily snapshots \"\\n  dailySnapshots: [PoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" Pool hourly snapshots \"\\n  hourlySnapshots: [PoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  _lastDailySnapshotTimestamp: BigInt\\n  _lastHourlySnapshotTimestamp: BigInt\\n  \" Internal field for the SDK to be able to calculate total value imported/exported for liquidity based pools \"\\n  _inputTokenLiquidityBalance: BigInt\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Pool` entity with various fields, each having a specific role in representing the state and characteristics of a pool within a blockchain protocol. The task is to document each field with clear and concise descriptions based on the information available in the schema. The descriptions should be factual and straightforward, avoiding any assumptions or speculative language. The documentation should help developers and system architects understand the purpose and data type of each field without altering the schema's structure.\",\n    documented_schema='\"Description for table: Pool\"\\ntype Pool @entity @regularPolling {\\n  \"Unique identifier for the pool, represented as a byte array.\"\\n  id: Bytes!\\n  \"The protocol associated with the pool, defined by the BridgeProtocol enum.\"\\n  protocol: BridgeProtocol!\\n  \"The name of the pool, which may be a descriptive or user-friendly label.\"\\n  name: String\\n  \"The symbol representing the pool, often used for quick identification.\"\\n  symbol: String\\n  \"A byte array representing a relation or connection to another entity or data point.\"\\n  relation: Bytes\\n  \"The type of the pool, specified by the BridgePoolType enum.\"\\n  type: BridgePoolType!\\n  \"The primary token used as input within the pool.\"\\n  inputToken: Token!\\n  \"A list of tokens that can be received as output across different chains.\"\\n  destinationTokens: [CrosschainToken!]!\\n  \"A list of routes available for the pool, each represented by a PoolRoute entity.\"\\n  routes: [PoolRoute!]!\\n  \"The token that is output from the pool, if applicable.\"\\n  outputToken: Token\\n  \"A list of tokens that are distributed as rewards to participants.\"\\n  rewardTokens: [RewardToken!]\\n  \"The timestamp when the pool was created, stored as a BigInt.\"\\n  createdTimestamp: BigInt!\\n  \"The block number at which the pool was created, stored as a BigInt.\"\\n  createdBlockNumber: BigInt!\\n  \"The total supply of tokens minted by the pool, if applicable.\"\\n  mintSupply: BigInt\\n  \"The balance of the input token currently held in the pool.\"\\n  inputTokenBalance: BigInt!\\n  \"The total value locked in the pool, expressed in USD.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"The net value exported from the pool, expressed in USD.\"\\n  netValueExportedUSD: BigDecimal!\\n  \"The cumulative revenue generated for supply-side participants, expressed in USD.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"The cumulative revenue generated for the protocol, expressed in USD.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"The total cumulative revenue generated, combining both supply-side and protocol revenues, expressed in USD.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"The cumulative volume of tokens entering the pool.\"\\n  cumulativeVolumeIn: BigInt!\\n  \"The cumulative volume of tokens exiting the pool.\"\\n  cumulativeVolumeOut: BigInt!\\n  \"The net volume of tokens, calculated as the difference between cumulative volume in and out.\"\\n  netVolume: BigInt!\\n  \"The cumulative volume of tokens entering the pool, expressed in USD.\"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \"The cumulative volume of tokens exiting the pool, expressed in USD.\"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n  \"The net volume of tokens, expressed in USD.\"\\n  netVolumeUSD: BigDecimal!\\n  \"The total supply of the output token, if applicable.\"\\n  outputTokenSupply: BigInt\\n  \"The price of the output token, expressed in USD.\"\\n  outputTokenPriceUSD: BigDecimal\\n  \"The amount of output tokens that are staked.\"\\n  stakedOutputTokenAmount: BigInt\\n  \"The amount of reward tokens emitted, represented as a list of BigInt values.\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"The value of reward tokens emitted, expressed in USD and represented as a list of BigDecimal values.\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"A list of daily snapshots for the pool, derived from the pool field.\"\\n  dailySnapshots: [PoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"A list of hourly snapshots for the pool, derived from the pool field.\"\\n  hourlySnapshots: [PoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"The timestamp of the last daily snapshot, stored as a BigInt.\"\\n  _lastDailySnapshotTimestamp: BigInt\\n  \"The timestamp of the last hourly snapshot, stored as a BigInt.\"\\n  _lastHourlySnapshotTimestamp: BigInt\\n  \"The liquidity balance of the input token, stored as a BigInt.\"\\n  _inputTokenLiquidityBalance: BigInt\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: AuctionEvent\"\\ntype AuctionEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: bidder\"\\n  bidder: Bytes!\\n  \"Description for column: caller\"\\n  caller: Bytes!\\n  \"Description for column: ethValue\"\\n  ethValue: BigDecimal!\\n  \"Description for column: lockupUntil\"\\n  lockupUntil: BigInt\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}', 'documented_schema': '\" A table of auction events. An auction event is an event that occurs when a token is auctioned. \"\\ntype AuctionEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. \"\\n  id: ID!\\n  \" The schema version of the event being used. \"\\n  version: BigInt!\\n  \" The edition of the event. \"\\n  edition: Edition!\\n  \" The name of the event. \"\\n  name: String!\\n  \" The bidder of the event. \"\\n  bidder: Bytes!\\n  \" The caller of the event. \"\\n  caller: Bytes!\\n  \" The value of the event in ETH. \"\\n  ethValue: BigDecimal!\\n  \" The lockup until of the event. \"\\n  lockupUntil: BigInt\\n  \" The timestamp of the event. \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. \"\\n  logIndex: BigInt!\\n  \" The address of the event. \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. \"\\n  blockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines an `AuctionEvent` entity with various fields, each having a specific data type and purpose. The task is to generate detailed descriptions for each field based on their names and types, ensuring clarity and precision. The descriptions should help developers understand the role of each field without altering the schema's structure.\",\n    documented_schema='\"Description for table: AuctionEvent\"\\ntype AuctionEvent @entity(immutable: true) {\\n  \"Unique identifier for the auction event.\"\\n  id: ID!\\n  \"Version number of the auction event, used for tracking changes or updates.\"\\n  version: BigInt!\\n  \"Reference to the edition associated with the auction event.\"\\n  edition: Edition!\\n  \"Name of the auction event.\"\\n  name: String!\\n  \"Address of the bidder participating in the auction.\"\\n  bidder: Bytes!\\n  \"Address of the caller who initiated the auction event.\"\\n  caller: Bytes!\\n  \"Value of the bid in Ethereum, represented as a decimal.\"\\n  ethValue: BigDecimal!\\n  \"Timestamp indicating when the lockup period ends, if applicable.\"\\n  lockupUntil: BigInt\\n  \"Timestamp of when the auction event occurred.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction associated with the auction event.\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block.\"\\n  transactionIndex: BigInt!\\n  \"Index of the log entry within the transaction.\"\\n  logIndex: BigInt!\\n  \"Address where the auction event took place.\"\\n  eventAddress: Bytes!\\n  \"Address from which the transaction originated.\"\\n  eventTxFrom: Bytes!\\n  \"Address to which the transaction was sent, if applicable.\"\\n  eventTxTo: Bytes\\n  \"Block number in which the auction event was recorded.\"\\n  blockNumber: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: symbol\"\\n  symbol: String!\\n  \"Description for column: decimals\"\\n  decimals: Int!\\n  \"Description for column: lastPriceUSD\"\\n  lastPriceUSD: BigDecimal\\n  \"Description for column: lastPriceBlockNumber\"\\n  lastPriceBlockNumber: BigInt\\n  \"Description for column: _lastPricePool\"\\n  _lastPricePool: Bytes\\n  \"Description for column: _totalSupply\"\\n  _totalSupply: BigInt!\\n  \"Description for column: _totalValueLockedUSD\"\\n  _totalValueLockedUSD: BigDecimal!\\n  \"Description for column: _largePriceChangeBuffer\"\\n  _largePriceChangeBuffer: Int!\\n  \"Description for column: _largeTVLImpactBuffer\"\\n  _largeTVLImpactBuffer: Int!\\n}', 'documented_schema': '\" Token entity for the schema \"\\ntype Token @entity @regularPolling {\\n  \" Smart contract address of the token \"\\n  id: Bytes!\\n  \" Name of the token, mirrored from the smart contract \"\\n  name: String!\\n  \" Symbol of the token, mirrored from the smart contract \"\\n  symbol: String!\\n  \" The number of decimal places this token uses, default to 18 \"\\n  decimals: Int!\\n  \" Optional field to track the price of a token, mostly for caching purposes \"\\n  lastPriceUSD: BigDecimal\\n  \" Optional field to track the block number of the last token price \"\\n  lastPriceBlockNumber: BigInt\\n  \" last pool that gave this token a price \"\\n  _lastPricePool: Bytes\\n  \" amount of tokens in the protocol \"\\n  _totalSupply: BigInt!\\n  \" Total value locked in the protocol \"\\n  _totalValueLockedUSD: BigDecimal!\\n  _largePriceChangeBuffer: Int!\\n  _largeTVLImpactBuffer: Int!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `Token`, with various fields that describe the properties and state of a token in a blockchain context. Each field has a specific type and some fields are optional, as indicated by the absence of an exclamation mark. The task is to provide clear and concise documentation for each field based on its name and type, ensuring that the descriptions are informative and useful for developers or system architects who might interact with this schema.',\n    documented_schema='\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Unique identifier for the token, represented as a byte array.\"\\n  id: Bytes!\\n  \"Human-readable name of the token.\"\\n  name: String!\\n  \"Ticker symbol of the token, typically a short string.\"\\n  symbol: String!\\n  \"Number of decimal places used by the token.\"\\n  decimals: Int!\\n  \"Most recent price of the token in USD, if available.\"\\n  lastPriceUSD: BigDecimal\\n  \"Block number at which the last price was recorded.\"\\n  lastPriceBlockNumber: BigInt\\n  \"Identifier for the pool used to determine the last price.\"\\n  _lastPricePool: Bytes\\n  \"Total supply of the token in circulation.\"\\n  _totalSupply: BigInt!\\n  \"Total value locked in USD, representing the token\\'s value in the system.\"\\n  _totalValueLockedUSD: BigDecimal!\\n  \"Buffer value for handling large price changes.\"\\n  _largePriceChangeBuffer: Int!\\n  \"Buffer value for handling significant impacts on total value locked.\"\\n  _largeTVLImpactBuffer: Int!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: NewRoundEvent\"\\ntype NewRoundEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: blockHash\"\\n  blockHash: String!\\n}', 'documented_schema': '\"\"\"NewRoundEvent entities are created for every emitted NewRound event.\"\"\"\\ntype NewRoundEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  \"Block hash for the round\"\\n  blockHash: String!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `NewRoundEvent` which implements an interface `Event`. Each field within this type is already accompanied by a brief description. The task is to ensure that these descriptions are clear and informative, providing a concise understanding of each field's purpose and data type. The descriptions should be factual and directly related to the schema's structure without altering the schema itself.\",\n    documented_schema='\"Description for table: NewRoundEvent\"\\ntype NewRoundEvent implements Event @entity {\\n  \"Unique identifier for the NewRoundEvent.\"\\n  id: ID!\\n  \"Reference to the associated transaction.\"\\n  transaction: Transaction!\\n  \"Timestamp indicating when the event occurred, represented as an integer.\"\\n  timestamp: Int!\\n  \"Reference to the round associated with the event.\"\\n  round: Round!\\n  \"Hash of the block in which the event was included.\"\\n  blockHash: String!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Day\"\\ntype Day @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: date\"\\n  date: String!\\n  \"Description for column: transferCount\"\\n  transferCount: BigInt!\\n  \"Description for column: editionsCount\"\\n  editionsCount: BigInt!\\n  \"Description for column: bidsAcceptedCount\"\\n  bidsAcceptedCount: BigInt!\\n  \"Description for column: bidsPlacedCount\"\\n  bidsPlacedCount: BigInt!\\n  \"Description for column: bidsRejectedCount\"\\n  bidsRejectedCount: BigInt!\\n  \"Description for column: bidsWithdrawnCount\"\\n  bidsWithdrawnCount: BigInt!\\n  \"Description for column: bidsIncreasedCount\"\\n  bidsIncreasedCount: BigInt!\\n  \"Description for column: totalValuePlaceInBids\"\\n  totalValuePlaceInBids: BigDecimal!\\n  \"Description for column: totalValueCycledInBids\"\\n  totalValueCycledInBids: BigDecimal!\\n  \"Description for column: secondarySalesValue\"\\n  secondarySalesValue: BigDecimal!\\n  \"Description for column: issuedCount\"\\n  issuedCount: BigInt!\\n  \"Description for column: salesCount\"\\n  salesCount: BigInt!\\n  \"Description for column: totalValueInEth\"\\n  totalValueInEth: BigDecimal!\\n  \"Description for column: highestValueInEth\"\\n  highestValueInEth: BigDecimal!\\n  \"Description for column: highestValueToken\"\\n  highestValueToken: Token\\n  \"Description for column: issued\"\\n  issued: [Token!]!\\n  \"Description for column: editions\"\\n  editions: [Edition!]!\\n}', 'documented_schema': '\" A table of day events. A day event is an event that occurs when a day is rolled up. \"\\ntype Day @entity {\\n  \" The unique identifier for the event. \"\\n  id: ID!\\n  \" The date of the event. \"\\n  date: String!\\n  \" The transfer count during the day. \"\\n  transferCount: BigInt!\\n  \" The editions count during the day. \"\\n  editionsCount: BigInt!\\n  \" The bids accepted count during the day. \"\\n  bidsAcceptedCount: BigInt!\\n  \" The bids placed count during the day. \"\\n  bidsPlacedCount: BigInt!\\n  \" The bids rejected count during the day. \"\\n  bidsRejectedCount: BigInt!\\n  \" The bids withdrawn count during the day. \"\\n  bidsWithdrawnCount: BigInt!\\n  \" The bids increased count during the day. \"\\n  bidsIncreasedCount: BigInt!\\n  \" The total value placed in bids during the day. \"\\n  totalValuePlaceInBids: BigDecimal!\\n  \" The total value cycled in bids during the day. \"\\n  totalValueCycledInBids: BigDecimal!\\n  \" The secondary sales value in ETH during the day. \"\\n  secondarySalesValue: BigDecimal!\\n  \" The issued count during the day. \"\\n  issuedCount: BigInt!\\n  \" The sales count during the day. \"\\n  salesCount: BigInt!\\n  \" The total value in ETH during the day. \"\\n  totalValueInEth: BigDecimal!\\n  \" The highest value in ETH during the day. \"\\n  highestValueInEth: BigDecimal!\\n  \" The highest value token during the day. \"\\n  highestValueToken: Token\\n  \" The issued tokens during the day. \"\\n  issued: [Token!]!\\n  \" The editions during the day. \"\\n  editions: [Edition!]!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `Day` with various fields, each representing different metrics or data points related to a specific day. The task is to document each field with clear and concise descriptions based on the field names and types. The descriptions should provide enough context to understand what each field represents without altering the schema structure. The fields include identifiers, counts of various activities, and financial metrics, all of which are crucial for understanding daily operations or transactions.',\n    documented_schema='\"Description for table: Day\"\\ntype Day @entity {\\n  \"Unique identifier for the day.\"\\n  id: ID!\\n  \"The date represented as a string.\"\\n  date: String!\\n  \"The total number of transfers that occurred.\"\\n  transferCount: BigInt!\\n  \"The total number of editions created.\"\\n  editionsCount: BigInt!\\n  \"The number of bids that were accepted.\"\\n  bidsAcceptedCount: BigInt!\\n  \"The number of bids that were placed.\"\\n  bidsPlacedCount: BigInt!\\n  \"The number of bids that were rejected.\"\\n  bidsRejectedCount: BigInt!\\n  \"The number of bids that were withdrawn.\"\\n  bidsWithdrawnCount: BigInt!\\n  \"The number of bids that were increased.\"\\n  bidsIncreasedCount: BigInt!\\n  \"The total value of all placed bids.\"\\n  totalValuePlaceInBids: BigDecimal!\\n  \"The total value cycled through bids.\"\\n  totalValueCycledInBids: BigDecimal!\\n  \"The total value of secondary sales.\"\\n  secondarySalesValue: BigDecimal!\\n  \"The total number of tokens issued.\"\\n  issuedCount: BigInt!\\n  \"The total number of sales made.\"\\n  salesCount: BigInt!\\n  \"The total value of sales in Ethereum.\"\\n  totalValueInEth: BigDecimal!\\n  \"The highest value of a sale in Ethereum.\"\\n  highestValueInEth: BigDecimal!\\n  \"The token with the highest sale value.\"\\n  highestValueToken: Token\\n  \"List of tokens issued on this day.\"\\n  issued: [Token!]!\\n  \"List of editions created on this day.\"\\n  editions: [Edition!]!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: InterestRate\"\\ntype InterestRate @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: rate\"\\n  rate: BigDecimal!\\n  \"Description for column: duration\"\\n  duration: Int\\n  \"Description for column: maturityBlock\"\\n  maturityBlock: BigInt\\n  \"Description for column: side\"\\n  side: InterestRateSide!\\n  \"Description for column: type\"\\n  type: InterestRateType!\\n  \"Description for column: tranche\"\\n  tranche: Tranche\\n}', 'documented_schema': 'type InterestRate @entity @regularPolling {\\n  \" { Interest rate side }-{ Interest rate type }-{ Market ID }-{ Optional: Tranche }-{ Optional: # days/hours since epoch time } \"\\n  id: ID!\\n  \" Interest rate in percentage APY. E.g. 5.21% should be stored as 5.21 \"\\n  rate: BigDecimal!\\n  \" Duration of the loan in days. Only applies to fixed term lending (e.g. Notional) \"\\n  duration: Int\\n  \" Maturity of the loan in block height. Only applies to fixed term lending (e.g. Notional) \"\\n  maturityBlock: BigInt\\n  \" The party the interest is paid to / received from \"\\n  side: InterestRateSide!\\n  \" The type of interest rate (e.g. stable, fixed, variable, etc) \"\\n  type: InterestRateType!\\n  \" The level of debt priority at this interest rate \"\\n  tranche: Tranche\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines an `InterestRate` entity with several fields, each requiring documentation. The fields include `id`, `rate`, `duration`, `maturityBlock`, `side`, `type`, and `tranche`. Each field serves a specific purpose within the context of interest rates, and the documentation should reflect their roles accurately. The `id` is a unique identifier, `rate` represents the interest rate value, `duration` likely indicates the time period for which the rate is applicable, `maturityBlock` could denote a specific block number related to maturity, `side` and `type` are enums that categorize the interest rate, and `tranche` might refer to a specific segment or portion of a financial product. The documentation will provide clear and concise descriptions for each field based on these inferred roles.',\n    documented_schema='\"Description for table: InterestRate\"\\ntype InterestRate @entity @regularPolling {\\n  \"Unique identifier for the interest rate entry.\"\\n  id: ID!\\n  \"The value of the interest rate.\"\\n  rate: BigDecimal!\\n  \"The duration for which the interest rate is applicable, measured in a specific unit of time.\"\\n  duration: Int\\n  \"The block number at which the interest rate matures.\"\\n  maturityBlock: BigInt\\n  \"The side of the interest rate, indicating its classification or category.\"\\n  side: InterestRateSide!\\n  \"The type of interest rate, specifying its nature or characteristics.\"\\n  type: InterestRateType!\\n  \"The tranche associated with the interest rate, representing a specific segment or portion.\"\\n  tranche: Tranche\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: NameSignalSubgraphRelation\"\\ntype NameSignalSubgraphRelation @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: nameSignal\"\\n  nameSignal: NameSignal!\\n  \"Description for column: subgraph\"\\n  subgraph: Subgraph!\\n}', 'documented_schema': '\"\"\"Auxiliary entity to be able to batch update NameSignal entities\"\"\"\\ntype NameSignalSubgraphRelation @entity {\\n  \"Subgraph ID + index\"\\n  id: ID!\\n  nameSignal: NameSignal!\\n  subgraph: Subgraph!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a single entity, `NameSignalSubgraphRelation`, which includes three fields: `id`, `nameSignal`, and `subgraph`. Each field is already documented with a placeholder description. The task is to enhance these descriptions to provide clear and concise information about each field's purpose and role within the schema. The `id` field is typically a unique identifier for the entity. The `nameSignal` field likely represents a relationship or reference to another entity, `NameSignal`, and the `subgraph` field likely represents a relationship or reference to another entity, `Subgraph`. The goal is to document these fields accurately without altering the schema structure.\",\n    documented_schema='\"Description for table: NameSignalSubgraphRelation\"\\ntype NameSignalSubgraphRelation @entity {\\n  \"Unique identifier for the NameSignalSubgraphRelation entity.\"\\n  id: ID!\\n  \"Reference to the associated NameSignal entity.\"\\n  nameSignal: NameSignal!\\n  \"Reference to the associated Subgraph entity.\"\\n  subgraph: Subgraph!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: NameSignal\"\\ntype NameSignal @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: curator\"\\n  curator: Curator!\\n  \"Description for column: subgraph\"\\n  subgraph: Subgraph!\\n  \"Description for column: signalledTokens\"\\n  signalledTokens: BigInt!\\n  \"Description for column: unsignalledTokens\"\\n  unsignalledTokens: BigInt!\\n  \"Description for column: withdrawnTokens\"\\n  withdrawnTokens: BigInt!\\n  \"Description for column: nameSignal\"\\n  nameSignal: BigInt!\\n  \"Description for column: signal\"\\n  signal: BigDecimal!\\n  \"Description for column: signalledTokensSentToL2\"\\n  signalledTokensSentToL2: BigInt!\\n  \"Description for column: signalledTokensReceivedOnL2\"\\n  signalledTokensReceivedOnL2: BigInt!\\n  \"Description for column: transferredToL2\"\\n  transferredToL2: Boolean!\\n  \"Description for column: transferredToL2At\"\\n  transferredToL2At: BigInt\\n  \"Description for column: transferredToL2AtBlockNumber\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Description for column: transferredToL2AtTx\"\\n  transferredToL2AtTx: String\\n  \"Description for column: idOnL2\"\\n  idOnL2: String\\n  \"Description for column: idOnL1\"\\n  idOnL1: String\\n  \"Description for column: lastNameSignalChange\"\\n  lastNameSignalChange: Int!\\n  \"Description for column: realizedRewards\"\\n  realizedRewards: BigInt!\\n  \"Description for column: averageCostBasis\"\\n  averageCostBasis: BigDecimal!\\n  \"Description for column: averageCostBasisPerSignal\"\\n  averageCostBasisPerSignal: BigDecimal!\\n  \"Description for column: nameSignalAverageCostBasis\"\\n  nameSignalAverageCostBasis: BigDecimal!\\n  \"Description for column: nameSignalAverageCostBasisPerSignal\"\\n  nameSignalAverageCostBasisPerSignal: BigDecimal!\\n  \"Description for column: signalAverageCostBasis\"\\n  signalAverageCostBasis: BigDecimal!\\n  \"Description for column: signalAverageCostBasisPerSignal\"\\n  signalAverageCostBasisPerSignal: BigDecimal!\\n  \"Description for column: entityVersion\"\\n  entityVersion: Int!\\n  \"Description for column: linkedEntity\"\\n  linkedEntity: NameSignal\\n}', 'documented_schema': '\"\"\"Curator Name Signal for a single Subgraph\"\"\"\\ntype NameSignal @entity {\\n  \"Eth address + subgraph ID\"\\n  id: ID!\\n  \"Eth address of the curator\"\\n  curator: Curator!\\n  \"Subgraph being signalled\"\\n  subgraph: Subgraph!\\n  \"CUMULATIVE number of tokens the curator has signalled\"\\n  signalledTokens: BigInt!\\n  \"CUMULATIVE number of tokens the curator has unsignalled\"\\n  unsignalledTokens: BigInt!\\n  \"Tokens the curator has withdrawn from a deprecated name curve\"\\n  withdrawnTokens: BigInt!\\n  \"Shares of the name pool (GNS) that the curator has from signaling their GRT\"\\n  nameSignal: BigInt!\\n  \"Actual signal shares that the name pool minted with the GRT provided by the curator\"\\n  signal: BigDecimal!\\n  \"Amount of GRT transferred to L2\"\\n  signalledTokensSentToL2: BigInt!\\n  \"Amount of GRT received on L2\"\\n  signalledTokensReceivedOnL2: BigInt!\\n  \"Whether the name signal has been transferred from L1 to L2. Only applies to NameSignals that have been transferred, native L2 NameSignal entities will return false\"\\n  transferredToL2: Boolean!\\n  \"Timestamp for the L1 -> L2 Transfer.\"\\n  transferredToL2At: BigInt\\n  \"Block number for the L1 -> L2 Transfer.\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Transaction hash for the L1 -> L2 Transfer.\"\\n  transferredToL2AtTx: String\\n  \"ID of the NameSignal entity on L2. Null if it\\'s not transferred\"\\n  idOnL2: String\\n  \"ID of the NameSignal entity on L1. Null if it\\'s not transferred\"\\n  idOnL1: String\\n  \"Block for which the curator last entered or exited the curve\"\\n  lastNameSignalChange: Int!\\n  \"Summation of realized rewards from before the last time the curator entered the curation curve\"\\n  realizedRewards: BigInt!\\n  \"[DEPRECATED] Curator average cost basis for this name signal on this subgraph. New field for further versions will be nameSignalAverageCostBasis\"\\n  averageCostBasis: BigDecimal!\\n  \"[DEPRECATED] nameSignalAverageCostBasis / nameSignal. New field for further versions will be nameSignalAverageCostBasisPerSignal\"\\n  averageCostBasisPerSignal: BigDecimal!\\n  \"Curator average cost basis for this name signal on this subgraph\"\\n  nameSignalAverageCostBasis: BigDecimal!\\n  \"nameSignalAverageCostBasis / nameSignal\"\\n  nameSignalAverageCostBasisPerSignal: BigDecimal!\\n  \"Curator average cost basis for the version signal on this subgraph name pool\"\\n  signalAverageCostBasis: BigDecimal!\\n  \"signalAverageCostBasis / signal\"\\n  signalAverageCostBasisPerSignal: BigDecimal!\\n  entityVersion: Int!\\n  \"[DEPRECATED] Used for duplicate entities to enable old IDs from before the subgraph NFT update\"\\n  linkedEntity: NameSignal\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `NameSignal`, with various fields that represent different attributes related to signaling in a blockchain context. Each field has a specific type and purpose, which can be inferred from its name and type. The task is to provide clear and concise documentation for each field, explaining its role and significance without altering the schema structure. The documentation should be factual and based on the information available in the schema.',\n    documented_schema='\"Description for table: NameSignal\"\\ntype NameSignal @entity {\\n  \"Unique identifier for the NameSignal entity.\"\\n  id: ID!\\n  \"Reference to the curator associated with this NameSignal.\"\\n  curator: Curator!\\n  \"Reference to the subgraph associated with this NameSignal.\"\\n  subgraph: Subgraph!\\n  \"Total number of tokens that have been signaled.\"\\n  signalledTokens: BigInt!\\n  \"Total number of tokens that have been unsignaled.\"\\n  unsignalledTokens: BigInt!\\n  \"Total number of tokens that have been withdrawn.\"\\n  withdrawnTokens: BigInt!\\n  \"Current amount of name signal.\"\\n  nameSignal: BigInt!\\n  \"Current signal value represented as a decimal.\"\\n  signal: BigDecimal!\\n  \"Total number of tokens sent to Layer 2 for signaling.\"\\n  signalledTokensSentToL2: BigInt!\\n  \"Total number of tokens received on Layer 2 for signaling.\"\\n  signalledTokensReceivedOnL2: BigInt!\\n  \"Indicates whether the tokens have been transferred to Layer 2.\"\\n  transferredToL2: Boolean!\\n  \"Timestamp of when the tokens were transferred to Layer 2.\"\\n  transferredToL2At: BigInt\\n  \"Block number at which the tokens were transferred to Layer 2.\"\\n  transferredToL2AtBlockNumber: BigInt\\n  \"Transaction hash of the transfer to Layer 2.\"\\n  transferredToL2AtTx: String\\n  \"Identifier for the NameSignal on Layer 2.\"\\n  idOnL2: String\\n  \"Identifier for the NameSignal on Layer 1.\"\\n  idOnL1: String\\n  \"Timestamp of the last change in name signal.\"\\n  lastNameSignalChange: Int!\\n  \"Total realized rewards from signaling.\"\\n  realizedRewards: BigInt!\\n  \"Average cost basis of the tokens.\"\\n  averageCostBasis: BigDecimal!\\n  \"Average cost basis per unit of signal.\"\\n  averageCostBasisPerSignal: BigDecimal!\\n  \"Average cost basis of the name signal.\"\\n  nameSignalAverageCostBasis: BigDecimal!\\n  \"Average cost basis per unit of name signal.\"\\n  nameSignalAverageCostBasisPerSignal: BigDecimal!\\n  \"Average cost basis of the signal.\"\\n  signalAverageCostBasis: BigDecimal!\\n  \"Average cost basis per unit of signal.\"\\n  signalAverageCostBasisPerSignal: BigDecimal!\\n  \"Version number of the entity.\"\\n  entityVersion: Int!\\n  \"Reference to another NameSignal entity linked to this one.\"\\n  linkedEntity: NameSignal\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Tick\"\\ntype Tick @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: index\"\\n  index: BigInt!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: createdBlockNumber\"\\n  createdBlockNumber: BigInt!\\n  \"Description for column: prices\"\\n  prices: [BigDecimal!]!\\n  \"Description for column: liquidityGross\"\\n  liquidityGross: BigInt!\\n  \"Description for column: liquidityGrossUSD\"\\n  liquidityGrossUSD: BigDecimal!\\n  \"Description for column: liquidityNet\"\\n  liquidityNet: BigInt!\\n  \"Description for column: liquidityNetUSD\"\\n  liquidityNetUSD: BigDecimal!\\n  \"Description for column: lastSnapshotDayID\"\\n  lastSnapshotDayID: Int!\\n  \"Description for column: lastSnapshotHourID\"\\n  lastSnapshotHourID: Int!\\n  \"Description for column: lastUpdateTimestamp\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Description for column: lastUpdateBlockNumber\"\\n  lastUpdateBlockNumber: BigInt!\\n}', 'documented_schema': 'type Tick @entity @regularPolling {\\n  \" { pool address }-{ tick index } \"\\n  id: Bytes!\\n  \" tick index \"\\n  index: BigInt!\\n  \" Liquidity pool this tick belongs to \"\\n  pool: LiquidityPool!\\n  \" Creation timestamp \"\\n  createdTimestamp: BigInt!\\n  \" Creation block number \"\\n  createdBlockNumber: BigInt!\\n  \" calculated price of token0 of tick within this pool - constant \"\\n  prices: [BigDecimal!]!\\n  \" total liquidity pool has as tick lower or upper \"\\n  liquidityGross: BigInt!\\n  \" total liquidity in USD pool has as tick lower or upper \"\\n  liquidityGrossUSD: BigDecimal!\\n  \" how much liquidity changes when tick crossed \"\\n  liquidityNet: BigInt!\\n  \" how much liquidity in USD changes when tick crossed \"\\n  liquidityNetUSD: BigDecimal!\\n  \" Day ID of the most recent daily snapshot \"\\n  lastSnapshotDayID: Int!\\n  \" Hour ID of the most recent hourly snapshot \"\\n  lastSnapshotHourID: Int!\\n  \" Timestamp of the last time this entity was updated \"\\n  lastUpdateTimestamp: BigInt!\\n  \" Block number of the last time this entity was updated \"\\n  lastUpdateBlockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type named `Tick` with various fields, each having a specific data type and purpose. The task is to generate clear and concise descriptions for each field based on their names and types, ensuring that the documentation is informative and helpful for developers. The descriptions should be factual and derived from the field names and types without altering the schema structure.',\n    documented_schema='\"Description for table: Tick\"\\ntype Tick @entity @regularPolling {\\n  \"Unique identifier for the tick, represented as a byte array.\"\\n  id: Bytes!\\n  \"Index of the tick within the liquidity pool.\"\\n  index: BigInt!\\n  \"Reference to the associated liquidity pool.\"\\n  pool: LiquidityPool!\\n  \"Timestamp indicating when the tick was created, in seconds since the Unix epoch.\"\\n  createdTimestamp: BigInt!\\n  \"Block number at which the tick was created.\"\\n  createdBlockNumber: BigInt!\\n  \"Array of price values associated with the tick.\"\\n  prices: [BigDecimal!]!\\n  \"Total gross liquidity available at the tick.\"\\n  liquidityGross: BigInt!\\n  \"Total gross liquidity available at the tick, expressed in USD.\"\\n  liquidityGrossUSD: BigDecimal!\\n  \"Net liquidity available at the tick after accounting for active positions.\"\\n  liquidityNet: BigInt!\\n  \"Net liquidity available at the tick, expressed in USD.\"\\n  liquidityNetUSD: BigDecimal!\\n  \"Identifier for the last daily snapshot that included this tick.\"\\n  lastSnapshotDayID: Int!\\n  \"Identifier for the last hourly snapshot that included this tick.\"\\n  lastSnapshotHourID: Int!\\n  \"Timestamp of the last update to the tick, in seconds since the Unix epoch.\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Block number at which the last update to the tick occurred.\"\\n  lastUpdateBlockNumber: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: UsageMetricsDailySnapshot\"\\ntype UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: day\"\\n  day: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: dailyActiveUsers\"\\n  dailyActiveUsers: Int!\\n  \"Description for column: cumulativeUniqueUsers\"\\n  cumulativeUniqueUsers: Int!\\n  \"Description for column: dailyTransactionCount\"\\n  dailyTransactionCount: Int!\\n  \"Description for column: totalPoolCount\"\\n  totalPoolCount: Int!\\n  \"Description for column: dailyDepositCount\"\\n  dailyDepositCount: Int!\\n  \"Description for column: dailyWithdrawCount\"\\n  dailyWithdrawCount: Int!\\n  \"Description for column: dailySwapCount\"\\n  dailySwapCount: Int!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}', 'documented_schema': 'type UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \" ID is # of days since Unix epoch time \"\\n  id: Bytes!\\n  \" Number of days since Unix epoch time \"\\n  day: Int!\\n  \" Protocol this snapshot is associated with \"\\n  protocol: DexAmmProtocol!\\n  \" Number of unique daily active users \"\\n  dailyActiveUsers: Int!\\n  \" Number of cumulative unique users \"\\n  cumulativeUniqueUsers: Int!\\n  \" Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface. \"\\n  dailyTransactionCount: Int!\\n  \" Total number of pools \"\\n  totalPoolCount: Int!\\n  \" Total number of deposits (add liquidity) in an day \"\\n  dailyDepositCount: Int!\\n  \" Total number of withdrawals (remove liquidity) in an day \"\\n  dailyWithdrawCount: Int!\\n  \" Total number of trades (swaps) in an day \"\\n  dailySwapCount: Int!\\n  \" Timestamp of when this snapshot was taken/last modified (May be taken after interval has passed) \"\\n  timestamp: BigInt!\\n  \" Block number of when this snapshot was taken/last modified (May be taken after interval has passed) \"\\n  blockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema represents a GraphQL type named `UsageMetricsDailySnapshot`, which is annotated with `@entity` and `@dailySnapshot`, indicating that it is used to capture daily snapshots of usage metrics for a decentralized exchange automated market maker (DexAmmProtocol). Each field within this type has a specific role in capturing various metrics related to user activity, transactions, and protocol operations on a daily basis. The task is to provide clear and concise descriptions for each field based on their names and types, ensuring that the documentation is informative and aids in understanding the purpose of each field without altering the schema structure.',\n    documented_schema='\"Description for table: UsageMetricsDailySnapshot\"\\ntype UsageMetricsDailySnapshot @entity @dailySnapshot {\\n  \"Unique identifier for the daily snapshot entry.\"\\n  id: Bytes!\\n  \"The day for which the metrics are recorded, represented as an integer.\"\\n  day: Int!\\n  \"Reference to the decentralized exchange automated market maker protocol.\"\\n  protocol: DexAmmProtocol!\\n  \"Number of unique users who were active on the protocol during the day.\"\\n  dailyActiveUsers: Int!\\n  \"Total number of unique users who have interacted with the protocol up to and including the current day.\"\\n  cumulativeUniqueUsers: Int!\\n  \"Total number of transactions that occurred on the protocol during the day.\"\\n  dailyTransactionCount: Int!\\n  \"Total number of liquidity pools available on the protocol at the end of the day.\"\\n  totalPoolCount: Int!\\n  \"Number of deposit transactions made on the protocol during the day.\"\\n  dailyDepositCount: Int!\\n  \"Number of withdrawal transactions made on the protocol during the day.\"\\n  dailyWithdrawCount: Int!\\n  \"Number of swap transactions executed on the protocol during the day.\"\\n  dailySwapCount: Int!\\n  \"Timestamp indicating when the snapshot was recorded, represented as a BigInt.\"\\n  timestamp: BigInt!\\n  \"Block number at which the snapshot was recorded, represented as a BigInt.\"\\n  blockNumber: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: name\"\\n  name: String!\\n  \"Description for column: symbol\"\\n  symbol: String!\\n  \"Description for column: decimals\"\\n  decimals: Int!\\n  \"Description for column: lastPriceUSD\"\\n  lastPriceUSD: BigDecimal\\n  \"Description for column: lastPriceBlockNumber\"\\n  lastPriceBlockNumber: BigInt\\n  \"Description for column: _poolToken\"\\n  _poolToken: Token\\n}', 'documented_schema': 'type Token @entity @regularPolling {\\n  \" Smart contract address of the token \"\\n  id: ID!\\n  \" Name of the token, mirrored from the smart contract \"\\n  name: String!\\n  \" Symbol of the token, mirrored from the smart contract \"\\n  symbol: String!\\n  \" The number of decimal places this token uses, default to 18 \"\\n  decimals: Int!\\n  \" Optional field to track the price of a token, mostly for caching purposes \"\\n  lastPriceUSD: BigDecimal\\n  \" Optional field to track the block number of the last token price \"\\n  lastPriceBlockNumber: BigInt\\n  _poolToken: Token\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Token` type with several fields, each of which requires a clear and concise description. The `Token` type is annotated with `@entity` and `@regularPolling`, indicating it is a core entity in the schema and may be subject to regular updates. Each field within the `Token` type has a specific role:\\n\\n- `id`: Serves as the unique identifier for each token.\\n- `name`: Represents the name of the token.\\n- `symbol`: Denotes the symbol associated with the token, typically used in trading.\\n- `decimals`: Indicates the number of decimal places the token supports, which is crucial for precision in transactions.\\n- `lastPriceUSD`: Reflects the most recent price of the token in USD, if available.\\n- `lastPriceBlockNumber`: Captures the block number at which the last price was recorded, providing a reference point in the blockchain.\\n- `_poolToken`: Represents a relationship to another `Token`, possibly indicating a pool or paired token.\\n\\nThese descriptions are derived directly from the schema's structure and annotations, ensuring accuracy and relevance.\",\n    documented_schema='\"Description for table: Token\"\\ntype Token @entity @regularPolling {\\n  \"Unique identifier for the token.\"\\n  id: ID!\\n  \"Name of the token.\"\\n  name: String!\\n  \"Symbol representing the token, often used in trading.\"\\n  symbol: String!\\n  \"Number of decimal places the token supports.\"\\n  decimals: Int!\\n  \"Most recent price of the token in USD, if available.\"\\n  lastPriceUSD: BigDecimal\\n  \"Block number at which the last price was recorded.\"\\n  lastPriceBlockNumber: BigInt\\n  \"Reference to another token, possibly indicating a pool or paired token.\"\\n  _poolToken: Token\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: PoolRouteSnapshot\"\\ntype PoolRouteSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: poolRoute\"\\n  poolRoute: PoolRoute!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: snapshotVolumeIn\"\\n  snapshotVolumeIn: BigInt!\\n  \"Description for column: cumulativeVolumeIn\"\\n  cumulativeVolumeIn: BigInt!\\n  \"Description for column: snapshotVolumeOut\"\\n  snapshotVolumeOut: BigInt!\\n  \"Description for column: cumulativeVolumeOut\"\\n  cumulativeVolumeOut: BigInt!\\n  \"Description for column: snapshotVolumeInUSD\"\\n  snapshotVolumeInUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeInUSD\"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \"Description for column: snapshotVolumeOutUSD\"\\n  snapshotVolumeOutUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeOutUSD\"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n}', 'documented_schema': 'type PoolRouteSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \" poolRouteID.concat(poolSnapshotID) \"\\n  id: Bytes!\\n  \" PoolRoute this snapshot belongs to \"\\n  poolRoute: PoolRoute!\\n  \" Timestamp of this snapshot \"\\n  timestamp: BigInt!\\n  \" Block number of this snapshot \"\\n  blockNumber: BigInt!\\n  \" volume received through this route during the time of the snapshot period (hourly/daily) \"\\n  snapshotVolumeIn: BigInt!\\n  \" total volume received through this route in inputToken \"\\n  cumulativeVolumeIn: BigInt!\\n  \" volume sent through this route during the time of the snapshot period (hourly/daily) \"\\n  snapshotVolumeOut: BigInt!\\n  \" total volume sent through this route in inputToken \"\\n  cumulativeVolumeOut: BigInt!\\n  \" volume received through this route during the time of the snapshot period (hourly/daily) in USD \"\\n  snapshotVolumeInUSD: BigDecimal!\\n  \" total volume received through this route in USD \"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \" volume sent through this route during the time of the snapshot period (hourly/daily) in USD \"\\n  snapshotVolumeOutUSD: BigDecimal!\\n  \" total volume sent through this route in USD \"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines an entity called `PoolRouteSnapshot`, which is marked as immutable and is intended to capture hourly snapshots. Each field within this entity has a specific role related to tracking the volume of transactions through a pool route, both in terms of raw units and USD value. The fields include identifiers, timestamps, block numbers, and various volume metrics, both for individual snapshots and cumulative totals. The descriptions should clarify the purpose of each field without altering the schema's structure.\",\n    documented_schema='\"Description for table: PoolRouteSnapshot\"\\ntype PoolRouteSnapshot @entity(immutable: true) @hourlySnapshot {\\n  \"Unique identifier for the snapshot, represented as a byte array.\"\\n  id: Bytes!\\n  \"Reference to the associated pool route entity.\"\\n  poolRoute: PoolRoute!\\n  \"Timestamp indicating when the snapshot was taken, in Unix time format.\"\\n  timestamp: BigInt!\\n  \"Block number at which the snapshot was recorded.\"\\n  blockNumber: BigInt!\\n  \"Volume of assets entering the pool route during the snapshot period, measured in raw units.\"\\n  snapshotVolumeIn: BigInt!\\n  \"Total volume of assets that have entered the pool route up to and including this snapshot, measured in raw units.\"\\n  cumulativeVolumeIn: BigInt!\\n  \"Volume of assets exiting the pool route during the snapshot period, measured in raw units.\"\\n  snapshotVolumeOut: BigInt!\\n  \"Total volume of assets that have exited the pool route up to and including this snapshot, measured in raw units.\"\\n  cumulativeVolumeOut: BigInt!\\n  \"Volume of assets entering the pool route during the snapshot period, measured in USD.\"\\n  snapshotVolumeInUSD: BigDecimal!\\n  \"Total volume of assets that have entered the pool route up to and including this snapshot, measured in USD.\"\\n  cumulativeVolumeInUSD: BigDecimal!\\n  \"Volume of assets exiting the pool route during the snapshot period, measured in USD.\"\\n  snapshotVolumeOutUSD: BigDecimal!\\n  \"Total volume of assets that have exited the pool route up to and including this snapshot, measured in USD.\"\\n  cumulativeVolumeOutUSD: BigDecimal!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Epoch\"\\ntype Epoch @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: startBlock\"\\n  startBlock: Int!\\n  \"Description for column: endBlock\"\\n  endBlock: Int!\\n  \"Description for column: signalledTokens\"\\n  signalledTokens: BigInt!\\n  \"Description for column: stakeDeposited\"\\n  stakeDeposited: BigInt!\\n  \"Description for column: totalQueryFees\"\\n  totalQueryFees: BigInt!\\n  \"Description for column: taxedQueryFees\"\\n  taxedQueryFees: BigInt!\\n  \"Description for column: queryFeesCollected\"\\n  queryFeesCollected: BigInt!\\n  \"Description for column: curatorQueryFees\"\\n  curatorQueryFees: BigInt!\\n  \"Description for column: queryFeeRebates\"\\n  queryFeeRebates: BigInt!\\n  \"Description for column: totalRewards\"\\n  totalRewards: BigInt!\\n  \"Description for column: totalIndexerRewards\"\\n  totalIndexerRewards: BigInt!\\n  \"Description for column: totalDelegatorRewards\"\\n  totalDelegatorRewards: BigInt!\\n}', 'documented_schema': '\"\"\"\\nEpoch aggregate data for network statistics on signaling, rewards, and query fees\\n\"\"\"\\ntype Epoch @entity {\\n  \"Epoch number\"\\n  id: ID!\\n  \"Start block of the epoch\"\\n  startBlock: Int!\\n  \"End block of the epoch\"\\n  endBlock: Int!\\n  \"Signaled tokens during this epoch\"\\n  signalledTokens: BigInt!\\n  \"Stake deposited during this epoch\"\\n  stakeDeposited: BigInt!\\n  \"Total amount of query fees generated during this epoch (Includes everything)\"\\n  totalQueryFees: BigInt!\\n  \"Amount of query fees generated that were burnt by the 1% protocol tax during this epoch\"\\n  taxedQueryFees: BigInt!\\n  \"Amount of query fees generated for indexers during this epoch\"\\n  queryFeesCollected: BigInt!\\n  \"Amount of query fees generated that are going to curators during this epoch\"\\n  curatorQueryFees: BigInt!\\n  \"Rebate amount claimed from the protocol through rebates mechanism during this epoch\"\\n  queryFeeRebates: BigInt!\\n  \"Total indexing rewards earned in this epoch. Includes both delegator and indexer rewards\"\\n  totalRewards: BigInt!\\n  \"Total indexing rewards earned in this epoch by indexers\"\\n  totalIndexerRewards: BigInt!\\n  \"Total indexing rewards earned in this epoch by delegators\"\\n  totalDelegatorRewards: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `Epoch`, with various fields that represent different metrics and identifiers related to a specific epoch in a blockchain or distributed ledger context. Each field is associated with a specific data type, such as `ID!` or `BigInt!`, indicating the nature of the data it holds. The task is to generate clear and concise descriptions for each field based on their names and types, ensuring that the documentation is informative and aids in understanding the purpose of each field without altering the schema structure.',\n    documented_schema='\"Description for table: Epoch\"\\ntype Epoch @entity {\\n  \"Unique identifier for the epoch.\"\\n  id: ID!\\n  \"The block number at which the epoch starts.\"\\n  startBlock: Int!\\n  \"The block number at which the epoch ends.\"\\n  endBlock: Int!\\n  \"Total number of tokens signalled during the epoch.\"\\n  signalledTokens: BigInt!\\n  \"Total amount of stake deposited during the epoch.\"\\n  stakeDeposited: BigInt!\\n  \"Total query fees collected during the epoch.\"\\n  totalQueryFees: BigInt!\\n  \"Total query fees taxed during the epoch.\"\\n  taxedQueryFees: BigInt!\\n  \"Total query fees collected from users during the epoch.\"\\n  queryFeesCollected: BigInt!\\n  \"Total query fees allocated to curators during the epoch.\"\\n  curatorQueryFees: BigInt!\\n  \"Total query fee rebates distributed during the epoch.\"\\n  queryFeeRebates: BigInt!\\n  \"Total rewards distributed during the epoch.\"\\n  totalRewards: BigInt!\\n  \"Total rewards allocated to indexers during the epoch.\"\\n  totalIndexerRewards: BigInt!\\n  \"Total rewards allocated to delegators during the epoch.\"\\n  totalDelegatorRewards: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: _LiquidityGauge\"\\ntype _LiquidityGauge @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: vault\"\\n  vault: Vault!\\n}', 'documented_schema': 'type _LiquidityGauge @entity {\\n  \"Liquidity gauge address\"\\n  id: ID!\\n  \"Address of vault tokens the gauge accept deposits from\"\\n  vault: Vault!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines an entity named `_LiquidityGauge` with two fields: `id` and `vault`. The `id` field is of type `ID!`, indicating it is a non-nullable unique identifier for the `_LiquidityGauge` entity. The `vault` field is of type `Vault!`, which suggests it is a non-nullable reference to another entity named `Vault`. The existing descriptions for these fields are placeholders, indicating where detailed documentation should be added. The task is to provide clear and concise descriptions for these fields based on their types and roles within the schema.',\n    documented_schema='\"Description for table: _LiquidityGauge\"\\ntype _LiquidityGauge @entity {\\n  \"Unique identifier for the liquidity gauge.\"\\n  id: ID!\\n  \"Reference to the associated vault entity.\"\\n  vault: Vault!\\n}'\n)",
      4
    ],
    [
      "Example({'database_schema': '\"Description for table: Swap\"\\ntype Swap implements Event @entity @transaction {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: hash\"\\n  hash: String!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: to\"\\n  to: String!\\n  \"Description for column: from\"\\n  from: String!\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: tokenIn\"\\n  tokenIn: Token!\\n  \"Description for column: amountIn\"\\n  amountIn: BigInt!\\n  \"Description for column: amountInUSD\"\\n  amountInUSD: BigDecimal!\\n  \"Description for column: tokenOut\"\\n  tokenOut: Token!\\n  \"Description for column: amountOut\"\\n  amountOut: BigInt!\\n  \"Description for column: amountOutUSD\"\\n  amountOutUSD: BigDecimal!\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: _tradingFeeAmount\"\\n  _tradingFeeAmount: BigInt!\\n  \"Description for column: _tradingFeeAmountUSD\"\\n  _tradingFeeAmountUSD: BigDecimal!\\n}', 'documented_schema': 'type Swap implements Event @entity @transaction {\\n  \" swap-{ Transaction hash }-{ Log index } \"\\n  id: ID!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: String!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Address that received the tokens \"\\n  to: String!\\n  \" Address that sent the tokens \"\\n  from: String!\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Token deposited into pool \"\\n  tokenIn: Token!\\n  \" Amount of token deposited into pool in native units \"\\n  amountIn: BigInt!\\n  \" Amount of token deposited into pool in USD \"\\n  amountInUSD: BigDecimal!\\n  \" Token withdrawn from pool \"\\n  tokenOut: Token!\\n  \" Amount of token withdrawn from pool in native units \"\\n  amountOut: BigInt!\\n  \" Amount of token withdrawn from pool in USD \"\\n  amountOutUSD: BigDecimal!\\n  \" The pool involving this transaction \"\\n  pool: LiquidityPool!\\n  _tradingFeeAmount: BigInt!\\n  _tradingFeeAmountUSD: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Swap` type that implements the `Event` interface and is annotated with `@entity` and `@transaction`, indicating that it represents a transactional entity in a decentralized exchange (DEX) or automated market maker (AMM) protocol. Each field within the `Swap` type is already accompanied by a placeholder description. The task is to enhance these descriptions to provide clear and concise explanations of each field's purpose and data type, without altering the schema's structure.\\n\\nThe `Swap` type includes fields that capture essential details of a swap transaction, such as identifiers (`id`, `hash`, `logIndex`), participants (`to`, `from`), transaction metadata (`blockNumber`, `timestamp`), and specifics about the tokens involved (`tokenIn`, `amountIn`, `amountInUSD`, `tokenOut`, `amountOut`, `amountOutUSD`). Additionally, it includes fields related to the trading pool (`pool`) and trading fees (`_tradingFeeAmount`, `_tradingFeeAmountUSD`). The descriptions should clarify these aspects to aid developers in understanding the schema's components effectively.\",\n    documented_schema='\"Description for table: Swap\"\\ntype Swap implements Event @entity @transaction {\\n  \"Unique identifier for the swap event.\"\\n  id: ID!\\n  \"Transaction hash associated with the swap.\"\\n  hash: String!\\n  \"Index of the log entry within the block.\"\\n  logIndex: Int!\\n  \"Protocol used for the swap, represented by a DexAmmProtocol entity.\"\\n  protocol: DexAmmProtocol!\\n  \"Address of the recipient in the swap transaction.\"\\n  to: String!\\n  \"Address of the sender in the swap transaction.\"\\n  from: String!\\n  \"Block number in which the swap transaction was included.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of when the swap transaction occurred.\"\\n  timestamp: BigInt!\\n  \"Token entity representing the input token in the swap.\"\\n  tokenIn: Token!\\n  \"Amount of the input token involved in the swap.\"\\n  amountIn: BigInt!\\n  \"USD value of the input token amount.\"\\n  amountInUSD: BigDecimal!\\n  \"Token entity representing the output token in the swap.\"\\n  tokenOut: Token!\\n  \"Amount of the output token received from the swap.\"\\n  amountOut: BigInt!\\n  \"USD value of the output token amount.\"\\n  amountOutUSD: BigDecimal!\\n  \"Liquidity pool entity associated with the swap.\"\\n  pool: LiquidityPool!\\n  \"Amount of trading fee charged in the swap, denominated in the input token.\"\\n  _tradingFeeAmount: BigInt!\\n  \"USD value of the trading fee amount.\"\\n  _tradingFeeAmountUSD: BigDecimal!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: _TokenWhitelistSymbol\"\\ntype _TokenWhitelistSymbol @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: address\"\\n  address: Bytes!\\n}', 'documented_schema': 'type _TokenWhitelistSymbol @entity(immutable: true) {\\n  \" Whitelist Token Symbol \"\\n  id: ID!\\n  \" Whitelist Token Address\"\\n  address: Bytes!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema defines a GraphQL entity named `_TokenWhitelistSymbol` with two fields: `id` and `address`. The `id` field is of type `ID!`, which is a non-nullable unique identifier for the entity. The `address` field is of type `Bytes!`, indicating it stores a non-nullable byte sequence, likely representing a blockchain address. The descriptions for the table and columns are already provided, so the task is to ensure these descriptions are clear and concise without altering the schema structure.',\n    documented_schema='\"Description for table: _TokenWhitelistSymbol\"\\ntype _TokenWhitelistSymbol @entity(immutable: true) {\\n  \"Unique identifier for the token whitelist symbol.\"\\n  id: ID!\\n  \"Blockchain address associated with the token whitelist symbol.\"\\n  address: Bytes!\\n}'\n)",
      4
    ],
    [
      "Example({'database_schema': '\"Description for table: TransferEvent\"\\ntype TransferEvent @entity(immutable: true) {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: from\"\\n  from: Bytes!\\n  \"Description for column: to\"\\n  to: Bytes!\\n  \"Description for column: tokenId\"\\n  tokenId: BigInt!\\n  \"Description for column: edition\"\\n  edition: Edition!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: transactionHash\"\\n  transactionHash: Bytes!\\n  \"Description for column: transactionIndex\"\\n  transactionIndex: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: BigInt!\\n  \"Description for column: eventAddress\"\\n  eventAddress: Bytes!\\n  \"Description for column: eventTxFrom\"\\n  eventTxFrom: Bytes!\\n  \"Description for column: eventTxTo\"\\n  eventTxTo: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n}', 'documented_schema': '\" TransferEvent is a table for recording events related to transfers of tokens \"\\ntype TransferEvent @entity(immutable: true) {\\n  \" The unique identifier for the event. A composite key made from multiple items. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the event. Type: BigInt! \"\\n  version: BigInt!\\n  \" The from address of the transfer. The address of the account that initiated the transfer. Type: Bytes! \"\\n  from: Bytes!\\n  \" The to address of the transfer. The address of the account that received the transfer. Type: Bytes! \"\\n  to: Bytes!\\n  \" The token ID of the transfer. The ID of the token being transferred. Type: BigInt! \"\\n  tokenId: BigInt!\\n  \" The edition associated with the transfer. References the Edition entity. Type: Edition! \"\\n  edition: Edition!\\n  \" The timestamp of the event. Based on the unix timestamp of the block the event was recorded in. Type: BigInt! \"\\n  timestamp: BigInt!\\n  \" The transaction hash of the event. Based on the transaction that recorded the event. Type: Bytes! \"\\n  transactionHash: Bytes!\\n  \" The transaction index of the event. The index of the transaction in the block. Type: BigInt! \"\\n  transactionIndex: BigInt!\\n  \" The log index of the event. The index of the log in the transaction. Type: BigInt! \"\\n  logIndex: BigInt!\\n  \" The address of the event. The address of the contract that recorded the event. Type: Bytes! \"\\n  eventAddress: Bytes!\\n  \" The transaction from address of the event. The address of the account that initiated the transaction. Type: Bytes! \"\\n  eventTxFrom: Bytes!\\n  \" The transaction to address of the event. The address of the account that received the transaction. Type: Bytes \"\\n  eventTxTo: Bytes\\n  \" The block number of the event. The block number of the block the event was recorded in. \"\\n  blockNumber: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a single entity, `TransferEvent`, which represents an immutable record of a transfer event. Each field within this entity has a specific role, and the descriptions should reflect their purpose and data type. The `id` field is a unique identifier for the event. The `version` field likely indicates the version of the event or schema. The `from` and `to` fields represent the addresses involved in the transfer. The `tokenId` is the identifier for the token being transferred. The `edition` field is linked to an `Edition` type, which might represent a specific version or series of the token. The `timestamp` records when the event occurred. The `transactionHash` is the unique identifier for the transaction on the blockchain. The `transactionIndex` and `logIndex` provide the position of the transaction and log within the block, respectively. The `eventAddress` is the address where the event was emitted. The `eventTxFrom` and `eventTxTo` fields represent the sender and receiver addresses in the transaction, with `eventTxTo` being optional. Finally, the `blockNumber` indicates the block in which the transaction was included.',\n    documented_schema='\"Description for table: TransferEvent\"\\ntype TransferEvent @entity(immutable: true) {\\n  \"Unique identifier for the transfer event.\"\\n  id: ID!\\n  \"Version number of the transfer event.\"\\n  version: BigInt!\\n  \"Address from which the token is transferred.\"\\n  from: Bytes!\\n  \"Address to which the token is transferred.\"\\n  to: Bytes!\\n  \"Identifier of the token being transferred.\"\\n  tokenId: BigInt!\\n  \"Associated edition of the token.\"\\n  edition: Edition!\\n  \"Timestamp of when the transfer event occurred.\"\\n  timestamp: BigInt!\\n  \"Hash of the transaction containing the transfer event.\"\\n  transactionHash: Bytes!\\n  \"Index of the transaction within the block.\"\\n  transactionIndex: BigInt!\\n  \"Index of the log within the transaction.\"\\n  logIndex: BigInt!\\n  \"Address that emitted the transfer event.\"\\n  eventAddress: Bytes!\\n  \"Sender address in the transaction.\"\\n  eventTxFrom: Bytes!\\n  \"Receiver address in the transaction, if applicable.\"\\n  eventTxTo: Bytes\\n  \"Block number in which the transaction was included.\"\\n  blockNumber: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Deposit\"\\ntype Deposit @entity(immutable: true) @transaction {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hash\"\\n  hash: Bytes!\\n  \"Description for column: nonce\"\\n  nonce: BigInt!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: gasLimit\"\\n  gasLimit: BigInt\\n  \"Description for column: gasUsed\"\\n  gasUsed: BigInt\\n  \"Description for column: gasPrice\"\\n  gasPrice: BigInt\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: account\"\\n  account: Account!\\n  \"Description for column: position\"\\n  position: Position\\n  \"Description for column: pool\"\\n  pool: LiquidityPool!\\n  \"Description for column: tickLower\"\\n  tickLower: BigInt\\n  \"Description for column: tickUpper\"\\n  tickUpper: BigInt\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n  \"Description for column: liquidity\"\\n  liquidity: BigInt!\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: inputTokenAmounts\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Description for column: reserveAmounts\"\\n  reserveAmounts: [BigInt!]\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n}', 'documented_schema': '\"\"\"\\nAn event is any user action that occurs in a protocol. Generally, they are Ethereum events\\nemitted by a function in the smart contracts, stored in transaction receipts as event logs.\\nHowever, some user actions of interest are function calls that don\\'t emit events. For example,\\nthe deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still\\nstore them as events, although they are not technically Ethereum events emitted by smart\\ncontracts.\\n\"\"\"\\ntype Deposit @entity(immutable: true) @transaction {\\n  \" { Transaction hash }-{ Log index } \"\\n  id: Bytes!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: Bytes!\\n  \" Nonce of the transaction that emitted this event \"\\n  nonce: BigInt!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" Gas limit of the transaction that emitted this event \"\\n  gasLimit: BigInt\\n  \" Gas used in this transaction. (Optional because not every chain will support this) \"\\n  gasUsed: BigInt\\n  \" Gas price of the transaction that emitted this event \"\\n  gasPrice: BigInt\\n  \" The protocol this transaction belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Account that emitted this event \"\\n  account: Account!\\n  \" The user position changed by this event \"\\n  position: Position\\n  \" The pool involving this event \"\\n  pool: LiquidityPool!\\n  \" lower tick of position \"\\n  tickLower: BigInt\\n  \" upper tick of position \"\\n  tickUpper: BigInt\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n  \" Amount of liquidity minted \"\\n  liquidity: BigInt!\\n  \" Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool \"\\n  inputTokens: [Token!]!\\n  \" Amount of input tokens in the token\\'s native unit \"\\n  inputTokenAmounts: [BigInt!]!\\n  \" Amount of input tokens in the liquidity pool \"\\n  reserveAmounts: [BigInt!]\\n  \" USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool) \"\\n  amountUSD: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `Deposit` entity with various fields, each having a specific data type and some marked as non-nullable. The task is to generate clear and concise descriptions for each field based on their names and types, ensuring that the documentation is informative and aids in understanding the schema's purpose. The descriptions should be factual and avoid assumptions beyond the provided schema details.\",\n    documented_schema='\"Description for table: Deposit\"\\ntype Deposit @entity(immutable: true) @transaction {\\n  \"Unique identifier for the deposit, represented as a byte array.\"\\n  id: Bytes!\\n  \"Transaction hash associated with the deposit, represented as a byte array.\"\\n  hash: Bytes!\\n  \"Nonce value of the transaction, used to ensure uniqueness.\"\\n  nonce: BigInt!\\n  \"Index of the log entry within the block.\"\\n  logIndex: Int!\\n  \"Maximum amount of gas allowed for the transaction.\"\\n  gasLimit: BigInt\\n  \"Amount of gas actually used by the transaction.\"\\n  gasUsed: BigInt\\n  \"Price of gas at the time of the transaction.\"\\n  gasPrice: BigInt\\n  \"Reference to the decentralized exchange or automated market maker protocol.\"\\n  protocol: DexAmmProtocol!\\n  \"Account associated with the deposit.\"\\n  account: Account!\\n  \"Position related to the deposit, if applicable.\"\\n  position: Position\\n  \"Liquidity pool involved in the deposit.\"\\n  pool: LiquidityPool!\\n  \"Lower tick boundary for the liquidity position.\"\\n  tickLower: BigInt\\n  \"Upper tick boundary for the liquidity position.\"\\n  tickUpper: BigInt\\n  \"Block number in which the transaction was included.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of when the transaction was processed.\"\\n  timestamp: BigInt!\\n  \"Amount of liquidity added in the deposit.\"\\n  liquidity: BigInt!\\n  \"List of tokens deposited.\"\\n  inputTokens: [Token!]!\\n  \"Amounts of each input token deposited.\"\\n  inputTokenAmounts: [BigInt!]!\\n  \"Amounts of tokens reserved in the pool after the deposit.\"\\n  reserveAmounts: [BigInt!]\\n  \"Total value of the deposit in USD.\"\\n  amountUSD: BigDecimal!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: _RewardData\"\\ntype _RewardData @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: rate\"\\n  rate: BigInt!\\n  \"Description for column: PeriodFinish\"\\n  PeriodFinish: BigInt!\\n}', 'documented_schema': 'type _RewardData @entity {\\n  \" {Liquidity gauge address}-{reward token address} \"\\n  id: ID!\\n  \" rate of emission \"\\n  rate: BigInt!\\n  \" timestamp of reward period finish \"\\n  PeriodFinish: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided schema defines a GraphQL entity named `_RewardData` with three fields: `id`, `rate`, and `PeriodFinish`. Each field has a type and a brief description. The task is to expand these descriptions to provide more detailed documentation for each field, ensuring clarity and understanding for developers or system architects who might interact with this schema.',\n    documented_schema='\"Description for table: _RewardData\"\\ntype _RewardData @entity {\\n  \"A unique identifier for the reward data entry.\"\\n  id: ID!\\n  \"The rate associated with the reward, represented as a BigInt.\"\\n  rate: BigInt!\\n  \"The timestamp indicating when the reward period finishes, represented as a BigInt.\"\\n  PeriodFinish: BigInt!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: LivepeerAccount\"\\ntype LivepeerAccount @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: lastUpdatedTimestamp\"\\n  lastUpdatedTimestamp: Int!\\n  \"Description for column: delegator\"\\n  delegator: Delegator\\n  \"Description for column: delegate\"\\n  delegate: Transcoder\\n}', 'documented_schema': '\"\"\"Abstraction for accounts/delegators bonded with the protocol\"\"\"\\ntype LivepeerAccount @entity {\\n  \"ETH address of the bonded delegator\"\\n  id: ID!\\n  \"The date the account was last associated with an event, beginning at 12:00am UTC\"\\n  lastUpdatedTimestamp: Int!\\n  \"Delegator details for this account\"\\n  delegator: Delegator\\n  \"Reference to the Delegate this address is bonded to\"\\n  delegate: Transcoder\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided schema represents a GraphQL entity named `LivepeerAccount`. Each field within this entity has a brief description, which is intended to clarify the purpose and type of data it holds. The `id` field is a unique identifier for the account. The `lastUpdatedTimestamp` field records the last time the account information was updated, represented as an integer. The `delegator` field is a reference to a `Delegator` entity, indicating the account's role or association with a delegator. Similarly, the `delegate` field references a `Transcoder` entity, suggesting a relationship or role with a transcoder. The task is to ensure these descriptions are clear and informative without altering the schema structure.\",\n    documented_schema='\"Description for table: LivepeerAccount\"\\ntype LivepeerAccount @entity {\\n  \"Unique identifier for the Livepeer account.\"\\n  id: ID!\\n  \"Timestamp of the last update to the account, represented as an integer.\"\\n  lastUpdatedTimestamp: Int!\\n  \"Reference to the associated Delegator entity.\"\\n  delegator: Delegator\\n  \"Reference to the associated Transcoder entity.\"\\n  delegate: Transcoder\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: PauseEvent\"\\ntype PauseEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n}', 'documented_schema': '\"\"\"PauseEvent entities are created for every emitted Pause event.\"\"\"\\ntype PauseEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided schema defines a GraphQL type `PauseEvent` which implements the `Event` interface. Each field within the `PauseEvent` type is already documented with a brief description. The task is to ensure that these descriptions are clear and informative, providing a concise understanding of each field's purpose and data type. The descriptions should be factual and directly related to the schema's structure without altering the schema itself.\",\n    documented_schema='\"Represents an event where a pause action is recorded, implementing the Event interface.\"\\ntype PauseEvent implements Event @entity {\\n  \"Unique identifier for the pause event.\"\\n  id: ID!\\n  \"Reference to the transaction associated with the pause event.\"\\n  transaction: Transaction!\\n  \"Unix timestamp indicating when the pause event occurred.\"\\n  timestamp: Int!\\n  \"Reference to the round during which the pause event took place.\"\\n  round: Round!\\n}'\n)",
      9
    ],
    [
      "Example({'database_schema': '\"Description for table: BridgeTransfer\"\\ntype BridgeTransfer implements Event @entity(immutable: true) @transaction {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: hash\"\\n  hash: Bytes!\\n  \"Description for column: logIndex\"\\n  logIndex: Int!\\n  \"Description for column: protocol\"\\n  protocol: BridgeProtocol!\\n  \"Description for column: account\"\\n  account: Account!\\n  \"Description for column: to\"\\n  to: Bytes!\\n  \"Description for column: from\"\\n  from: Bytes!\\n  \"Description for column: isOutgoing\"\\n  isOutgoing: Boolean!\\n  \"Description for column: fromChainID\"\\n  fromChainID: BigInt!\\n  \"Description for column: toChainID\"\\n  toChainID: BigInt!\\n  \"Description for column: transferTo\"\\n  transferTo: Bytes!\\n  \"Description for column: transferFrom\"\\n  transferFrom: Bytes\\n  \"Description for column: type\"\\n  type: TransferType!\\n  \"Description for column: pool\"\\n  pool: Pool!\\n  \"Description for column: route\"\\n  route: PoolRoute!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: amount\"\\n  amount: BigInt!\\n  \"Description for column: amountUSD\"\\n  amountUSD: BigDecimal!\\n  \"Description for column: crosschainToken\"\\n  crosschainToken: CrosschainToken!\\n  \"Description for column: isSwap\"\\n  isSwap: Boolean!\\n  \"Description for column: crossTransactionID\"\\n  crossTransactionID: Bytes\\n  \"Description for column: blockNumber\"\\n  blockNumber: BigInt!\\n  \"Description for column: timestamp\"\\n  timestamp: BigInt!\\n}', 'documented_schema': 'type BridgeTransfer implements Event @entity(immutable: true) @transaction {\\n  \" event.transaction.hash.concatI32(event.logIndex) \"\\n  id: Bytes!\\n  \" Transaction hash of the transaction that emitted this event \"\\n  hash: Bytes!\\n  \" Event log index. For transactions that don\\'t emit event, create arbitrary index starting from 0 \"\\n  logIndex: Int!\\n  \" The protocol this transaction belongs to \"\\n  protocol: BridgeProtocol!\\n  \" Account that sent or received the transfer. Should match with either transferFrom or transferTo \"\\n  account: Account!\\n  \" Address that received the tokens \"\\n  to: Bytes!\\n  \" Address that sent the tokens \"\\n  from: Bytes!\\n  \" Are we briding in or out? \"\\n  isOutgoing: Boolean!\\n  \" Chain ID from where the transfer is being sent \"\\n  fromChainID: BigInt!\\n  \" Chain ID where the transfer is being sent to \"\\n  toChainID: BigInt!\\n  \" This is the address that\\'s receiving the bridged funds (not a pool contract). When bridging out, it will be the address on the destination chain. \"\\n  transferTo: Bytes!\\n  \" This is the address initiating the transfer, where the initial funds came from. It might not match the address initiating the actual EVM transaction. \"\\n  transferFrom: Bytes\\n  \" Indicates how this transfer is ocurring on the current chain \"\\n  type: TransferType!\\n  \" The pool where the transfer originated or arrived \"\\n  pool: Pool!\\n  \" The route through which the funds where sent or received \"\\n  route: PoolRoute!\\n  \" The token sent/received in this transfer on the current chain \"\\n  token: Token!\\n  \" Amount of token transferred \"\\n  amount: BigInt!\\n  \" Amount of token transferred in USD \"\\n  amountUSD: BigDecimal!\\n  \" The equivalent of our token in the other chain \"\\n  crosschainToken: CrosschainToken!\\n  \" Indicates is the transfer involved a swap while bridging \"\\n  isSwap: Boolean!\\n  \" The transaction ID on the other chain, if available \"\\n  crossTransactionID: Bytes\\n  \" Block number of this event \"\\n  blockNumber: BigInt!\\n  \" Timestamp of this event \"\\n  timestamp: BigInt!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a type `BridgeTransfer` which implements an `Event` and is marked as immutable and transactional. Each field within the `BridgeTransfer` type is already accompanied by a brief description. The task is to ensure these descriptions are clear and informative, providing a concise understanding of each field's purpose and data type without altering the schema structure. The descriptions should be factual and straightforward, avoiding any speculative language.\",\n    documented_schema='\"Description for table: BridgeTransfer\"\\ntype BridgeTransfer implements Event @entity(immutable: true) @transaction {\\n  \"Unique identifier for the bridge transfer event.\"\\n  id: Bytes!\\n  \"Hash of the transaction associated with the bridge transfer.\"\\n  hash: Bytes!\\n  \"Index of the log entry within the block for the transaction.\"\\n  logIndex: Int!\\n  \"Protocol used for the bridge transfer.\"\\n  protocol: BridgeProtocol!\\n  \"Account involved in the bridge transfer.\"\\n  account: Account!\\n  \"Destination address for the transfer.\"\\n  to: Bytes!\\n  \"Source address from which the transfer originated.\"\\n  from: Bytes!\\n  \"Indicates if the transfer is outgoing.\"\\n  isOutgoing: Boolean!\\n  \"Chain ID of the source blockchain.\"\\n  fromChainID: BigInt!\\n  \"Chain ID of the destination blockchain.\"\\n  toChainID: BigInt!\\n  \"Address to which the transfer is directed.\"\\n  transferTo: Bytes!\\n  \"Address from which the transfer is initiated, if applicable.\"\\n  transferFrom: Bytes\\n  \"Type of the transfer operation.\"\\n  type: TransferType!\\n  \"Pool associated with the bridge transfer.\"\\n  pool: Pool!\\n  \"Route taken by the pool during the transfer.\"\\n  route: PoolRoute!\\n  \"Token being transferred.\"\\n  token: Token!\\n  \"Amount of tokens being transferred.\"\\n  amount: BigInt!\\n  \"Equivalent amount of the transfer in USD.\"\\n  amountUSD: BigDecimal!\\n  \"Token used for cross-chain transactions.\"\\n  crosschainToken: CrosschainToken!\\n  \"Indicates if the transfer involves a swap operation.\"\\n  isSwap: Boolean!\\n  \"Identifier for the cross-chain transaction, if applicable.\"\\n  crossTransactionID: Bytes\\n  \"Block number in which the transaction was included.\"\\n  blockNumber: BigInt!\\n  \"Timestamp of when the transaction occurred.\"\\n  timestamp: BigInt!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: StakeClaimedEvent\"\\ntype StakeClaimedEvent implements Event @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: transaction\"\\n  transaction: Transaction!\\n  \"Description for column: timestamp\"\\n  timestamp: Int!\\n  \"Description for column: round\"\\n  round: Round!\\n  \"Description for column: delegator\"\\n  delegator: String!\\n  \"Description for column: delegate\"\\n  delegate: String!\\n  \"Description for column: stake\"\\n  stake: BigDecimal!\\n  \"Description for column: fees\"\\n  fees: BigDecimal!\\n}', 'documented_schema': '\"\"\"\\nStakeClaimedEvent entities are created for every emitted StakeClaimed event.\\n\"\"\"\\ntype StakeClaimedEvent implements Event @entity {\\n  \"Ethereum transaction hash + event log index\"\\n  id: ID!\\n  \"Reference to the transaction the event was included in\"\\n  transaction: Transaction!\\n  \"Timestamp of the transaction the event was included in\"\\n  timestamp: Int!\\n  \"Reference to the round the event occured in\"\\n  round: Round!\\n  delegator: String!\\n  delegate: String!\\n  stake: BigDecimal!\\n  fees: BigDecimal!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines a type `StakeClaimedEvent` which implements the `Event` interface. Each field within this type is associated with a specific data type and has a brief description. The task is to expand these descriptions to provide more detailed and informative documentation for each field, ensuring clarity and understanding for developers and system architects. The descriptions should be factual and based solely on the information provided in the schema.',\n    documented_schema='\"Description for table: StakeClaimedEvent\"\\ntype StakeClaimedEvent implements Event @entity {\\n  \"Unique identifier for the stake claimed event.\"\\n  id: ID!\\n  \"Reference to the transaction associated with this stake claimed event.\"\\n  transaction: Transaction!\\n  \"Unix timestamp indicating when the stake was claimed.\"\\n  timestamp: Int!\\n  \"Reference to the round during which the stake was claimed.\"\\n  round: Round!\\n  \"Address of the delegator who claimed the stake.\"\\n  delegator: String!\\n  \"Address of the delegate associated with the claimed stake.\"\\n  delegate: String!\\n  \"Amount of stake claimed, represented as a decimal.\"\\n  stake: BigDecimal!\\n  \"Fees associated with the stake claim, represented as a decimal.\"\\n  fees: BigDecimal!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: Edition\"\\ntype Edition @entity {\\n  \"Description for column: id\"\\n  id: ID!\\n  \"Description for column: version\"\\n  version: BigInt!\\n  \"Description for column: editionNmber\"\\n  editionNmber: String!\\n  \"Description for column: editionType\"\\n  editionType: BigInt!\\n  \"Description for column: editionData\"\\n  editionData: Bytes\\n  \"Description for column: creatorContract\"\\n  creatorContract: CreatorContract\\n  \"Description for column: salesType\"\\n  salesType: BigInt!\\n  \"Description for column: revokedApproval\"\\n  revokedApproval: Boolean!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: tokenIds\"\\n  tokenIds: [String!]!\\n  \"Description for column: tokens\"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \"Description for column: tokenURI\"\\n  tokenURI: String!\\n  \"Description for column: artistAccount\"\\n  artistAccount: Bytes!\\n  \"Description for column: artistCommission\"\\n  artistCommission: BigInt!\\n  \"Description for column: optionalCommissionAccount\"\\n  optionalCommissionAccount: Bytes\\n  \"Description for column: optionalCommissionRate\"\\n  optionalCommissionRate: BigInt\\n  \"Description for column: collaborators\"\\n  collaborators: [Bytes!]!\\n  \"Description for column: collective\"\\n  collective: Collective\\n  \"Description for column: offersOnly\"\\n  offersOnly: Boolean!\\n  \"Description for column: totalSupply\"\\n  totalSupply: BigInt!\\n  \"Description for column: totalAvailable\"\\n  totalAvailable: BigInt!\\n  \"Description for column: remainingSupply\"\\n  remainingSupply: BigInt!\\n  \"Description for column: totalSold\"\\n  totalSold: BigInt!\\n  \"Description for column: totalBurnt\"\\n  totalBurnt: BigInt!\\n  \"Description for column: originalEditionSize\"\\n  originalEditionSize: BigInt!\\n  \"Description for column: secondaryRoyaltyV4EditionOverride\"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \"Description for column: sales\"\\n  sales: [Token!]!\\n  \"Description for column: totalEthSpentOnEdition\"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \"Description for column: active\"\\n  active: Boolean!\\n  \"Description for column: metadata\"\\n  metadata: MetaData\\n  \"Description for column: isGenesisEdition\"\\n  isGenesisEdition: Boolean!\\n  \"Description for column: isEnhancedEdition\"\\n  isEnhancedEdition: Boolean!\\n  \"Description for column: isOpenEdition\"\\n  isOpenEdition: Boolean\\n  \"Description for column: hasCoverImage\"\\n  hasCoverImage: Boolean!\\n  \"Description for column: artist\"\\n  artist: Artist\\n  \"Description for column: startDate\"\\n  startDate: BigInt!\\n  \"Description for column: endDate\"\\n  endDate: BigInt!\\n  \"Description for column: reserveAuctionSeller\"\\n  reserveAuctionSeller: Bytes!\\n  \"Description for column: reserveAuctionBidder\"\\n  reserveAuctionBidder: Bytes!\\n  \"Description for column: reservePrice\"\\n  reservePrice: BigInt!\\n  \"Description for column: reserveAuctionBid\"\\n  reserveAuctionBid: BigInt!\\n  \"Description for column: reserveAuctionStartDate\"\\n  reserveAuctionStartDate: BigInt!\\n  \"Description for column: previousReserveAuctionEndTimestamp\"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionEndTimestamp\"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \"Description for column: reserveAuctionNumTimesExtended\"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \"Description for column: isReserveAuctionInSuddenDeath\"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \"Description for column: reserveAuctionTotalExtensionLengthInSeconds\"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \"Description for column: isReserveAuctionResulted\"\\n  isReserveAuctionResulted: Boolean!\\n  \"Description for column: isReserveAuctionResultedDateTime\"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \"Description for column: reserveAuctionResulter\"\\n  reserveAuctionResulter: Bytes!\\n  \"Description for column: reserveAuctionCanEmergencyExit\"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \"Description for column: priceInWei\"\\n  priceInWei: BigInt!\\n  \"Description for column: stepSaleBasePrice\"\\n  stepSaleBasePrice: BigInt!\\n  \"Description for column: stepSaleStepPrice\"\\n  stepSaleStepPrice: BigInt!\\n  \"Description for column: currentStep\"\\n  currentStep: BigInt!\\n  \"Description for column: auctionEnabled\"\\n  auctionEnabled: Boolean!\\n  \"Description for column: activeBid\"\\n  activeBid: AuctionEvent\\n  \"Description for column: gatedSale\"\\n  gatedSale: GatedSale\\n  \"Description for column: biddingHistory\"\\n  biddingHistory: [AuctionEvent!]!\\n  \"Description for column: transfers\"\\n  transfers: [TransferEvent!]!\\n  \"Description for column: allOwners\"\\n  allOwners: [Collector!]!\\n  \"Description for column: currentOwners\"\\n  currentOwners: [Collector!]!\\n  \"Description for column: primaryOwners\"\\n  primaryOwners: [Collector!]!\\n  \"Description for column: metadataName\"\\n  metadataName: String!\\n  \"Description for column: metadataArtist\"\\n  metadataArtist: String!\\n  \"Description for column: metadataTagString\"\\n  metadataTagString: String!\\n  \"Description for column: metadataArtistAccount\"\\n  metadataArtistAccount: String!\\n  \"Description for column: metadataPrice\"\\n  metadataPrice: BigInt!\\n  \"Description for column: metadataFormat\"\\n  metadataFormat: String\\n  \"Description for column: metadataTheme\"\\n  metadataTheme: String\\n  \"Description for column: primaryAssetShortType\"\\n  primaryAssetShortType: String\\n  \"Description for column: primaryAssetActualType\"\\n  primaryAssetActualType: String\\n}', 'documented_schema': '\" A table of editions. An edition is a collection of tokens. \"\\ntype Edition @entity {\\n  \" The unique identifier for the edition. This is the composite ID made up of the edition ID and the optional contract address for the creator contract. Type: ID! \"\\n  id: ID!\\n  \" The version of the KODA schema used to record the edition. KODA 2, 3 or 4. Type: BigInt! \"\\n  version: BigInt!\\n  \" The edition number. This is the edition number. This is not a composite key. Type: String! \"\\n  editionNmber: String!\\n  \" The edition type. This is a legacy field from KODA V2. Type: BigInt! \"\\n  editionType: BigInt!\\n  \" The edition data. This is a legacy field from KODA V2 which contains some additional data about the edition. Type: Bytes! \"\\n  editionData: Bytes\\n  \" The creator contract. This references the CreatorContract entity. Type: CreatorContract! \"\\n  creatorContract: CreatorContract\\n  \" The sales type. This is the current sales mechanic being used on this edition. Type: BigInt! \"\\n  salesType: BigInt!\\n  \" The revoked approval flag. This is a boolean that indicates if the seller has revoked approved the marketplace, which is set to true once if the seller has revoked approved the marketplace. Type: Boolean! \"\\n  revokedApproval: Boolean!\\n  \" The created timestamp. This is a number, the timestamp of the creation of the edition. Type: BigInt! \"\\n  createdTimestamp: BigInt!\\n  \" The token IDs. This is an array of token IDs. Type: [String!]! \"\\n  tokenIds: [String!]!\\n  \" The tokens. This is an array of tokens. Type: [Token!]! \"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \" The token URI. This is a string, the URI of the token. Type: String! \"\\n  tokenURI: String!\\n  \" The artist account. This is the address of the artist for the edition. Type: Bytes! \"\\n  artistAccount: Bytes!\\n  \" The artist commission. This is the base artists commission. Type: BigInt! \"\\n  artistCommission: BigInt!\\n  \" The optional commission account. This is the address of the optional commission account. NOTE: deprecated - V2 only - use collaborators for this. Type: Bytes! \"\\n  optionalCommissionAccount: Bytes\\n  \" The optional commission rate. This is the rate of the optional commission. Type: BigInt! \"\\n  optionalCommissionRate: BigInt\\n  \" The collaborators. This is an array of addresses who have collaborated on this edition. Type: [Bytes!]! \"\\n  collaborators: [Bytes!]!\\n  \" The collective. This references the Collective entity. NOTE: nullable V3 collective i.e. its split funds. Type: Collective! \"\\n  collective: Collective\\n  \" The offers only flag. This is a boolean that indicates if the edition is only for offers. Type: Boolean! \"\\n  offersOnly: Boolean!\\n  \" The total supply. This is the total purchases or mints i.e. total number of primary transfers. Type: BigInt! \"\\n  totalSupply: BigInt!\\n  \" The total available. This is the total number available to be purchased i.e. edition size. Type: BigInt! \"\\n  totalAvailable: BigInt!\\n  \" The remaining supply. This is the total remaining i.e. number of primary sale tokens left to buy from this edition. Type: BigInt! \"\\n  remainingSupply: BigInt!\\n  \" The total sold. This is the total number sold i.e. number of primary sale tokens sold. sold = purchase/bid accepted with price > 0. Type: BigInt! \"\\n  totalSold: BigInt!\\n  \" The total burnt. This is the total number burnt i.e. number of primary sale tokens burnt. burnt = send to 0xDead or 0x0 (only applicable for V3). Type: BigInt! \"\\n  totalBurnt: BigInt!\\n  \" The original edition size. This is the original edition size of the edition at mint - this field should NEVER change once set. Type: BigInt! \"\\n  originalEditionSize: BigInt!\\n  \" The secondary royalty V4 edition override. This is the EIP2981 percentage requested by the creator(s) at the edition level. Type: BigInt! \"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \" The sales. This is an array of tokens that have been sold from this edition. Type: [Token!]! \"\\n  sales: [Token!]!\\n  \" The total eth spent on the edition. This is the total amount of ETH spent on the edition. Type: BigDecimal! \"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \" The active flag. This is a boolean that indicates if the edition is active. Type: Boolean! \"\\n  active: Boolean!\\n  \" The metadata. This references the MetaData entity. Type: MetaData! \"\\n  metadata: MetaData\\n  \" The isGenesisEdition flag. This is a boolean that indicates if the edition is the first edition. This is set true if edition is an artists first edition. Type: Boolean! \"\\n  isGenesisEdition: Boolean!\\n  \" The isEnhancedEdition flag. This is a boolean that indicates if the edition is an enhanced edition. This is set true if any of the tokens are enhanced i.e. composed. Type: Boolean! \"\\n  isEnhancedEdition: Boolean!\\n  \" The isOpenEdition flag. This is a boolean that indicates if the edition is an open edition. This is applicable to version 4 and editions where the artist does not mint all of the tokens up front. Type: Boolean! \"\\n  isOpenEdition: Boolean\\n  \" The hasCoverImage flag. This is a boolean that indicates if the edition has a cover image. Type: Boolean! \"\\n  hasCoverImage: Boolean!\\n  \" The artist. This references the Artist entity, and reference the primary minter. Type: Artist! \"\\n  artist: Artist\\n  \" The start date. This is a number, the timestamp of the start date of the edition. Type: BigInt! \"\\n  startDate: BigInt!\\n  \" The end date. The date when the edition is available until (only applicable for V2). Type: BigInt! \"\\n  endDate: BigInt!\\n  \" The reserve auction seller. This is the address of the edition seller. Type: Bytes! \"\\n  reserveAuctionSeller: Bytes!\\n  \" The reserve auction bidder. This is the address of the current bidder. Type: Bytes! \"\\n  reserveAuctionBidder: Bytes!\\n  \" The reserve price. This is the listed reserve price. Type: BigInt! \"\\n  reservePrice: BigInt!\\n  \" The reserve auction bid. This is the current bid. Type: BigInt! \"\\n  reserveAuctionBid: BigInt!\\n  \" The reserve auction start date. This is the timestamp of the auction start. Type: BigInt! \"\\n  reserveAuctionStartDate: BigInt!\\n  \" The previous reserve auction end timestamp. This is set to the same as reserve unless an extension is in flight. Type: BigInt! \"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction end timestamp. This is the timestamp of the auction end. Type: BigInt! \"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \" The reserve auction number of times extended. This is the number of times the auction has been extended. Type: BigInt! \"\\n  reserveAuctionNumTimesExtended: BigInt!\\n  \" The reserve auction in sudden death flag. This is a boolean that indicates if the auction is in sudden death. Type: Boolean! \"\\n  isReserveAuctionInSuddenDeath: Boolean!\\n  \" The reserve auction total extension length in seconds. This is the total length of the extension. Type: BigInt! \"\\n  reserveAuctionTotalExtensionLengthInSeconds: BigInt!\\n  \" The reserve auction resulted flag. This is a boolean that indicates if the auction has resulted. Type: Boolean! \"\\n  isReserveAuctionResulted: Boolean!\\n  \" The reserve auction resulted timestamp. This is the timestamp of the auction result. Type: BigInt! \"\\n  isReserveAuctionResultedDateTime: BigInt!\\n  \" The reserve auction resulter. This is the address of the auction resulter. Type: Bytes! \"\\n  reserveAuctionResulter: Bytes!\\n  \" The reserve auction can emergency exit flag. This is a boolean that indicates if the auction can emergency exit. Type: Boolean! \"\\n  reserveAuctionCanEmergencyExit: Boolean!\\n  \" The price in wei. This is the buy now price / current step price. Type: BigInt! \"\\n  priceInWei: BigInt!\\n  \" The step sale base price. This is the base price of the step sale. Type: BigInt! \"\\n  stepSaleBasePrice: BigInt!\\n  \" The step sale step price. This is the step price of the step sale. Type: BigInt! \"\\n  stepSaleStepPrice: BigInt!\\n  \" The current step. This is the current step of the step sale. Type: BigInt! \"\\n  currentStep: BigInt!\\n  \" The auction enabled flag. This is a boolean that indicates if the auction is enabled. Type: Boolean! \"\\n  auctionEnabled: Boolean!\\n  \" The active bid. This references the AuctionEvent entity. Type: AuctionEvent! \"\\n  activeBid: AuctionEvent\\n  \" The gated sale. This references the GatedSale entity. Represents if the edition is gated, which means the edition is only available to a certain set of users. Type: GatedSale! \"\\n  gatedSale: GatedSale\\n  \" The bidding history. This is an array of AuctionEvent entities. Type: [AuctionEvent!]! \"\\n  biddingHistory: [AuctionEvent!]!\\n  \" The transfers. The total number of token transfers made for all tokens from the edition. Type: [TransferEvent!]! \"\\n  transfers: [TransferEvent!]!\\n  \" The all owners. The list (set) of all unique owners for all tokens. Type: [Collector!]! \"\\n  allOwners: [Collector!]!\\n  \" The current owners. The current set of owners for this edition. Type: [Collector!]! \"\\n  currentOwners: [Collector!]!\\n  \" The primary owners. The owner is set when sold in primary sale. Type: [Collector!]! \"\\n  primaryOwners: [Collector!]!\\n  \" The metadata name. This is the name of the edition. Type: String! \"\\n  metadataName: String!\\n  \" The metadata artist. This is the artist of the edition. Type: String! \"\\n  metadataArtist: String!\\n  \" The metadata tag string. This is the tags of the edition. Type: String! \"\\n  metadataTagString: String!\\n  \" The metadata artist account. This is the artist account of the edition. Type: String! \"\\n  metadataArtistAccount: String!\\n  \" The metadata price. A consolidated price for all sale types, making it orderable in lists. Type: BigInt! \"\\n  metadataPrice: BigInt!\\n  \" The metadata format. This is the format of the edition (null-able as V3 only). Type: String! \"\\n  metadataFormat: String\\n  \" The metadata theme. This is the theme of the edition (null-able as V3 only). Type: String! \"\\n  metadataTheme: String\\n  \" The primary asset short type. This is the short type of the primary asset (null-able leading mime-type field i.e. image or video etc). Type: String! \"\\n  primaryAssetShortType: String\\n  \" The primary asset actual type. This is the actual type of the primary asset (null-able ending mime-type field e.g. mp4, gif, png etc). Type: String! \"\\n  primaryAssetActualType: String\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning='The provided GraphQL schema defines an `Edition` entity with various fields, each having a brief description. The task is to enhance these descriptions to provide more detailed and clear documentation for each field. The descriptions should be factual and based on the field names and types, avoiding any assumptions or speculative language. The goal is to ensure that developers and system architects can easily understand the purpose and usage of each field within the `Edition` entity.',\n    documented_schema='\"Description for table: Edition\"\\ntype Edition @entity {\\n  \"Unique identifier for the edition.\"\\n  id: ID!\\n  \"Version number of the edition, represented as a BigInt.\"\\n  version: BigInt!\\n  \"Name or number of the edition.\"\\n  editionNmber: String!\\n  \"Type of the edition, represented as a BigInt.\"\\n  editionType: BigInt!\\n  \"Data associated with the edition, stored as bytes.\"\\n  editionData: Bytes\\n  \"Reference to the creator\\'s contract associated with the edition.\"\\n  creatorContract: CreatorContract\\n  \"Type of sales mechanism used for the edition, represented as a BigInt.\"\\n  salesType: BigInt!\\n  \"Indicates whether approval for the edition has been revoked.\"\\n  revokedApproval: Boolean!\\n  \"Timestamp indicating when the edition was created.\"\\n  createdTimestamp: BigInt!\\n  \"List of token IDs associated with the edition.\"\\n  tokenIds: [String!]!\\n  \"List of tokens derived from this edition.\"\\n  tokens: [Token!]! @derivedFrom(field: \"edition\")\\n  \"URI for the token metadata.\"\\n  tokenURI: String!\\n  \"Account of the artist associated with the edition, stored as bytes.\"\\n  artistAccount: Bytes!\\n  \"Commission rate for the artist, represented as a BigInt.\"\\n  artistCommission: BigInt!\\n  \"Optional account for additional commission, stored as bytes.\"\\n  optionalCommissionAccount: Bytes\\n  \"Optional rate for additional commission, represented as a BigInt.\"\\n  optionalCommissionRate: BigInt\\n  \"List of collaborators\\' accounts, stored as bytes.\"\\n  collaborators: [Bytes!]!\\n  \"Reference to the collective associated with the edition.\"\\n  collective: Collective\\n  \"Indicates if the edition is available for offers only.\"\\n  offersOnly: Boolean!\\n  \"Total supply of the edition, represented as a BigInt.\"\\n  totalSupply: BigInt!\\n  \"Total number of editions available, represented as a BigInt.\"\\n  totalAvailable: BigInt!\\n  \"Remaining supply of the edition, represented as a BigInt.\"\\n  remainingSupply: BigInt!\\n  \"Total number of editions sold, represented as a BigInt.\"\\n  totalSold: BigInt!\\n  \"Total number of editions burnt, represented as a BigInt.\"\\n  totalBurnt: BigInt!\\n  \"Original size of the edition, represented as a BigInt.\"\\n  originalEditionSize: BigInt!\\n  \"Override for secondary royalty in version 4, represented as a BigInt.\"\\n  secondaryRoyaltyV4EditionOverride: BigInt\\n  \"List of sales transactions associated with the edition.\"\\n  sales: [Token!]!\\n  \"Total amount of Ether spent on the edition, represented as a BigDecimal.\"\\n  totalEthSpentOnEdition: BigDecimal!\\n  \"Indicates whether the edition is currently active.\"\\n  active: Boolean!\\n  \"Metadata associated with the edition.\"\\n  metadata: MetaData\\n  \"Indicates if the edition is a genesis edition.\"\\n  isGenesisEdition: Boolean!\\n  \"Indicates if the edition is enhanced.\"\\n  isEnhancedEdition: Boolean!\\n  \"Indicates if the edition is open.\"\\n  isOpenEdition: Boolean\\n  \"Indicates if the edition has a cover image.\"\\n  hasCoverImage: Boolean!\\n  \"Reference to the artist associated with the edition.\"\\n  artist: Artist\\n  \"Start date of the edition, represented as a BigInt.\"\\n  startDate: BigInt!\\n  \"End date of the edition, represented as a BigInt.\"\\n  endDate: BigInt!\\n  \"Account of the seller in a reserve auction, stored as bytes.\"\\n  reserveAuctionSeller: Bytes!\\n  \"Account of the bidder in a reserve auction, stored as bytes.\"\\n  reserveAuctionBidder: Bytes!\\n  \"Reserve price for the auction, represented as a BigInt.\"\\n  reservePrice: BigInt!\\n  \"Current bid in the reserve auction, represented as a BigInt.\"\\n  reserveAuctionBid: BigInt!\\n  \"Start date of the reserve auction, represented as a BigInt.\"\\n  reserveAuctionStartDate: BigInt!\\n  \"Timestamp of the previous reserve auction\\'s end.\"\\n  previousReserveAuctionEndTimestamp: BigInt!\\n  \"End timestamp of the reserve auction.\"\\n  reserveAuctionEndTimestamp: BigInt!\\n  \"Number of times the reserve auction has been extended.\"\\n  reserve'\n)",
      1
    ],
    [
      "Example({'database_schema': '\"Description for table: RewardToken\"\\ntype RewardToken @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: token\"\\n  token: Token!\\n  \"Description for column: type\"\\n  type: RewardTokenType!\\n}', 'documented_schema': 'type RewardToken @entity @regularPolling {\\n  \" { Reward token type }-{ Smart contract address of the reward token } \"\\n  id: Bytes!\\n  \" Reference to the actual token \"\\n  token: Token!\\n  \" The type of the reward token \"\\n  type: RewardTokenType!\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided schema defines a GraphQL entity named `RewardToken`, which includes three fields: `id`, `token`, and `type`. Each field is associated with a specific data type, and the schema already includes brief descriptions for each field. The task is to expand these descriptions to provide more detailed information about each field's purpose and usage within the context of the `RewardToken` entity. The descriptions should be clear and informative, aiding developers in understanding the role of each field without altering the schema's structure.\",\n    documented_schema='\"Description for table: RewardToken\"\\ntype RewardToken @entity @regularPolling {\\n  \"Unique identifier for the reward token, represented as a byte array.\"\\n  id: Bytes!\\n  \"Reference to the associated token entity, indicating the specific token that is rewarded.\"\\n  token: Token!\\n  \"Specifies the type of reward token, using the RewardTokenType enumeration to define possible types.\"\\n  type: RewardTokenType!\\n}'\n)",
      16
    ],
    [
      "Example({'database_schema': '\"Description for table: LiquidityPool\"\\ntype LiquidityPool @entity @regularPolling {\\n  \"Description for column: id\"\\n  id: Bytes!\\n  \"Description for column: protocol\"\\n  protocol: DexAmmProtocol!\\n  \"Description for column: name\"\\n  name: String\\n  \"Description for column: symbol\"\\n  symbol: String\\n  \"Description for column: liquidityToken\"\\n  liquidityToken: Token\\n  \"Description for column: liquidityTokenType\"\\n  liquidityTokenType: TokenType\\n  \"Description for column: inputTokens\"\\n  inputTokens: [Token!]!\\n  \"Description for column: rewardTokens\"\\n  rewardTokens: [RewardToken!]\\n  \"Description for column: fees\"\\n  fees: [LiquidityPoolFee!]!\\n  \"Description for column: isSingleSided\"\\n  isSingleSided: Boolean!\\n  \"Description for column: createdTimestamp\"\\n  createdTimestamp: BigInt!\\n  \"Description for column: createdBlockNumber\"\\n  createdBlockNumber: BigInt!\\n  \"Description for column: tick\"\\n  tick: BigInt\\n  \"Description for column: totalValueLockedUSD\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Description for column: totalLiquidity\"\\n  totalLiquidity: BigInt!\\n  \"Description for column: totalLiquidityUSD\"\\n  totalLiquidityUSD: BigDecimal!\\n  \"Description for column: activeLiquidity\"\\n  activeLiquidity: BigInt!\\n  \"Description for column: activeLiquidityUSD\"\\n  activeLiquidityUSD: BigDecimal!\\n  \"Description for column: uncollectedProtocolSideTokenAmounts\"\\n  uncollectedProtocolSideTokenAmounts: [BigInt!]!\\n  \"Description for column: uncollectedProtocolSideValuesUSD\"\\n  uncollectedProtocolSideValuesUSD: [BigDecimal!]!\\n  \"Description for column: uncollectedSupplySideTokenAmounts\"\\n  uncollectedSupplySideTokenAmounts: [BigInt!]!\\n  \"Description for column: uncollectedSupplySideValuesUSD\"\\n  uncollectedSupplySideValuesUSD: [BigDecimal!]!\\n  \"Description for column: cumulativeSupplySideRevenueUSD\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeProtocolSideRevenueUSD\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeTotalRevenueUSD\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Description for column: cumulativeVolumeByTokenAmount\"\\n  cumulativeVolumeByTokenAmount: [BigInt!]!\\n  \"Description for column: cumulativeVolumeByTokenUSD\"\\n  cumulativeVolumeByTokenUSD: [BigDecimal!]!\\n  \"Description for column: cumulativeVolumeUSD\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Description for column: inputTokenBalances\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Description for column: inputTokenBalancesUSD\"\\n  inputTokenBalancesUSD: [BigDecimal!]!\\n  \"Description for column: inputTokenWeights\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Description for column: stakedOutputTokenAmount\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Description for column: rewardTokenEmissionsAmount\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Description for column: rewardTokenEmissionsUSD\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"Description for column: cumulativeDepositCount\"\\n  cumulativeDepositCount: Int!\\n  \"Description for column: cumulativeWithdrawCount\"\\n  cumulativeWithdrawCount: Int!\\n  \"Description for column: cumulativeSwapCount\"\\n  cumulativeSwapCount: Int!\\n  \"Description for column: positions\"\\n  positions: [Position!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: positionCount\"\\n  positionCount: Int!\\n  \"Description for column: openPositionCount\"\\n  openPositionCount: Int!\\n  \"Description for column: closedPositionCount\"\\n  closedPositionCount: Int!\\n  \"Description for column: lastSnapshotDayID\"\\n  lastSnapshotDayID: Int!\\n  \"Description for column: lastSnapshotHourID\"\\n  lastSnapshotHourID: Int!\\n  \"Description for column: lastUpdateTimestamp\"\\n  lastUpdateTimestamp: BigInt!\\n  \"Description for column: lastUpdateBlockNumber\"\\n  lastUpdateBlockNumber: BigInt!\\n  \"Description for column: dailySnapshots\"\\n  dailySnapshots: [LiquidityPoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: hourlySnapshots\"\\n  hourlySnapshots: [LiquidityPoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: deposits\"\\n  deposits: [Deposit!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: withdraws\"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"pool\")\\n  \"Description for column: swaps\"\\n  swaps: [Swap!]! @derivedFrom(field: \"pool\")\\n}', 'documented_schema': 'type LiquidityPool @entity @regularPolling {\\n  \" Smart contract address of the pool \"\\n  id: Bytes!\\n  \" The protocol this pool belongs to \"\\n  protocol: DexAmmProtocol!\\n  \" Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT) \"\\n  name: String\\n  \" Symbol of liquidity pool (e.g. 3CRV) \"\\n  symbol: String\\n  \" Token that is to represent ownership of liquidity \"\\n  liquidityToken: Token\\n  \" Type of token used to track liquidity \"\\n  liquidityTokenType: TokenType\\n  \" Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer \"\\n  inputTokens: [Token!]!\\n  \" Additional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon \"\\n  rewardTokens: [RewardToken!]\\n  \" Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee. ) \"\\n  fees: [LiquidityPoolFee!]!\\n  \" Whether this pool is single-sided (e.g. Bancor, Platypus\\'s Alternative Pool). The specifics of the implementation depends on the protocol. \"\\n  isSingleSided: Boolean!\\n  \" Creation timestamp \"\\n  createdTimestamp: BigInt!\\n  \" Creation block number \"\\n  createdBlockNumber: BigInt!\\n  \" Current tick representing the price of token0/token1 \"\\n  tick: BigInt\\n  \" Current TVL (Total Value Locked) of this pool in USD \"\\n  totalValueLockedUSD: BigDecimal!\\n  \" The sum of all active and non-active liquidity for this pool. \"\\n  totalLiquidity: BigInt!\\n  \" The sum of all active and non-active liquidity in USD for this pool. \"\\n  totalLiquidityUSD: BigDecimal!\\n  \" All liquidity `k` that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick. \"\\n  activeLiquidity: BigInt!\\n  \" All liquidity in USD that is active. Will be equal to totalLiquidity except for in concentrated liquidity - where activeLiquidity is all liquidity positions that contain the pools current tick. \"\\n  activeLiquidityUSD: BigDecimal!\\n  \" All protocol-side value locked in token amounts that remains uncollected and unused in the pool. \"\\n  uncollectedProtocolSideTokenAmounts: [BigInt!]!\\n  \" All protocol-side value locking in USD that remains uncollected and unused in the pool. \"\\n  uncollectedProtocolSideValuesUSD: [BigDecimal!]!\\n  \" All supply-side value locked in token amounts that remains uncollected and unused in the pool. \"\\n  uncollectedSupplySideTokenAmounts: [BigInt!]!\\n  \" All supply-side value locked in USD that remains uncollected and unused in the pool. \"\\n  uncollectedSupplySideValuesUSD: [BigDecimal!]!\\n  \" All revenue generated by the liquidity pool, accrued to the supply side. \"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool, accrued to the protocol. \"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \" All revenue generated by the liquidity pool. \"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \" All trade volume occurred for a specific input token, in native amount. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  cumulativeVolumeByTokenAmount: [BigInt!]!\\n  \" All trade volume occurred for a specific input token, in USD. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  cumulativeVolumeByTokenUSD: [BigDecimal!]!\\n  \" All historical trade volume occurred in this pool, in USD \"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \" Amount of input tokens in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalances: [BigInt!]!\\n  \" Amount of input tokens in USD in the pool. The ordering should be the same as the pool\\'s `inputTokens` field. \"\\n  inputTokenBalancesUSD: [BigDecimal!]!\\n  \" Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool \"\\n  inputTokenWeights: [BigDecimal!]!\\n  \" Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. \"\\n  stakedOutputTokenAmount: BigInt\\n  \" Per-block reward token emission as of the current block normalized to a day, in token\\'s native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \" Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. \"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \" Total number of deposits (add liquidity) \"\\n  cumulativeDepositCount: Int!\\n  \" Total number of withdrawals (remove liquidity) \"\\n  cumulativeWithdrawCount: Int!\\n  \" Total number of trades (swaps) \"\\n  cumulativeSwapCount: Int!\\n  \" All positions in this market \"\\n  positions: [Position!]! @derivedFrom(field: \"pool\")\\n  \" Number of positions in this market \"\\n  positionCount: Int!\\n  \" Number of open positions in this market \"\\n  openPositionCount: Int!\\n  \" Number of closed positions in this market \"\\n  closedPositionCount: Int!\\n  \" Day ID of the most recent daily snapshot \"\\n  lastSnapshotDayID: Int!\\n  \" Hour ID of the most recent hourly snapshot \"\\n  lastSnapshotHourID: Int!\\n  \" Timestamp of the last time this entity was updated \"\\n  lastUpdateTimestamp: BigInt!\\n  \" Block number of the last time this entity was updated \"\\n  lastUpdateBlockNumber: BigInt!\\n  \" Liquidity pool daily snapshots \"\\n  dailySnapshots: [LiquidityPoolDailySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" Liquidity pool hourly snapshots \"\\n  hourlySnapshots: [LiquidityPoolHourlySnapshot!]! @derivedFrom(field: \"pool\")\\n  \" All deposit (add liquidity) events occurred in this pool \"\\n  deposits: [Deposit!]! @derivedFrom(field: \"pool\")\\n  \" All withdraw (remove liquidity) events occurred in this pool \"\\n  withdraws: [Withdraw!]! @derivedFrom(field: \"pool\")\\n  \" All trade (swap) events occurred in this pool \"\\n  swaps: [Swap!]! @derivedFrom(field: \"pool\")\\n}'}) (input_keys={'database_schema'})",
      "Prediction(\n    reasoning=\"The provided GraphQL schema defines a `LiquidityPool` entity with various fields, each representing a specific attribute or metric related to a liquidity pool in a decentralized exchange (DEX) automated market maker (AMM) protocol. The task is to generate detailed descriptions for each field based on the information given in the schema. The descriptions should be clear, concise, and factual, providing insight into what each field represents without altering the schema's structure. The descriptions should avoid speculative language and focus on the role and data type of each field.\",\n    documented_schema='\"Description for table: LiquidityPool\"\\ntype LiquidityPool @entity @regularPolling {\\n  \"Unique identifier for the liquidity pool.\"\\n  id: Bytes!\\n  \"Reference to the decentralized exchange automated market maker protocol associated with the pool.\"\\n  protocol: DexAmmProtocol!\\n  \"Human-readable name of the liquidity pool.\"\\n  name: String\\n  \"Symbol representing the liquidity pool.\"\\n  symbol: String\\n  \"Token representing the liquidity provided to the pool.\"\\n  liquidityToken: Token\\n  \"Type of the liquidity token.\"\\n  liquidityTokenType: TokenType\\n  \"List of tokens that are input into the pool.\"\\n  inputTokens: [Token!]!\\n  \"List of reward tokens distributed by the pool.\"\\n  rewardTokens: [RewardToken!]\\n  \"List of fees associated with the liquidity pool.\"\\n  fees: [LiquidityPoolFee!]!\\n  \"Indicates if the pool supports single-sided liquidity provision.\"\\n  isSingleSided: Boolean!\\n  \"Timestamp when the liquidity pool was created.\"\\n  createdTimestamp: BigInt!\\n  \"Block number when the liquidity pool was created.\"\\n  createdBlockNumber: BigInt!\\n  \"Current tick value of the pool, if applicable.\"\\n  tick: BigInt\\n  \"Total value locked in the pool, denominated in USD.\"\\n  totalValueLockedUSD: BigDecimal!\\n  \"Total liquidity in the pool, measured in token units.\"\\n  totalLiquidity: BigInt!\\n  \"Total liquidity in the pool, denominated in USD.\"\\n  totalLiquidityUSD: BigDecimal!\\n  \"Active liquidity in the pool, measured in token units.\"\\n  activeLiquidity: BigInt!\\n  \"Active liquidity in the pool, denominated in USD.\"\\n  activeLiquidityUSD: BigDecimal!\\n  \"Amounts of protocol-side tokens that are uncollected.\"\\n  uncollectedProtocolSideTokenAmounts: [BigInt!]!\\n  \"Values of uncollected protocol-side tokens, denominated in USD.\"\\n  uncollectedProtocolSideValuesUSD: [BigDecimal!]!\\n  \"Amounts of supply-side tokens that are uncollected.\"\\n  uncollectedSupplySideTokenAmounts: [BigInt!]!\\n  \"Values of uncollected supply-side tokens, denominated in USD.\"\\n  uncollectedSupplySideValuesUSD: [BigDecimal!]!\\n  \"Cumulative revenue from the supply side, denominated in USD.\"\\n  cumulativeSupplySideRevenueUSD: BigDecimal!\\n  \"Cumulative revenue from the protocol side, denominated in USD.\"\\n  cumulativeProtocolSideRevenueUSD: BigDecimal!\\n  \"Total cumulative revenue, denominated in USD.\"\\n  cumulativeTotalRevenueUSD: BigDecimal!\\n  \"Cumulative volume of tokens traded, measured in token units.\"\\n  cumulativeVolumeByTokenAmount: [BigInt!]!\\n  \"Cumulative volume of tokens traded, denominated in USD.\"\\n  cumulativeVolumeByTokenUSD: [BigDecimal!]!\\n  \"Total cumulative trading volume, denominated in USD.\"\\n  cumulativeVolumeUSD: BigDecimal!\\n  \"Balances of input tokens in the pool, measured in token units.\"\\n  inputTokenBalances: [BigInt!]!\\n  \"Balances of input tokens in the pool, denominated in USD.\"\\n  inputTokenBalancesUSD: [BigDecimal!]!\\n  \"Weights of input tokens in the pool.\"\\n  inputTokenWeights: [BigDecimal!]!\\n  \"Amount of output tokens staked in the pool.\"\\n  stakedOutputTokenAmount: BigInt\\n  \"Amounts of reward tokens emitted by the pool.\"\\n  rewardTokenEmissionsAmount: [BigInt!]\\n  \"Values of reward tokens emitted by the pool, denominated in USD.\"\\n  rewardTokenEmissionsUSD: [BigDecimal!]\\n  \"Total number of deposits made into the pool.\"\\n  cumulativeDepositCount: Int!\\n  \"Total number of withdrawals made from the pool.\"\\n  cumulativeWithdrawCount: Int!\\n  \"Total number of swaps executed in the pool.\"\\n  cumulativeSwapCount: Int!\\n  \"List of positions associated with the pool.\"\\n  positions: [Position!]! @derivedFrom(field: \"pool\")\\n  \"Total number of positions in the pool.\"\\n  positionCount: Int!\\n  \"Number of open positions in the pool.\"\\n  openPositionCount: Int!\\n  \"Number of closed positions in the pool.\"\\n  closedPosition'\n)",
      1
    ]
  ]
}